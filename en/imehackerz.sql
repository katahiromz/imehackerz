-- phpMyAdmin SQL Dump
-- version 5.2.1
-- https://www.phpmyadmin.net/
--
-- ホスト: 127.0.0.1
-- 生成日時: 2024-08-13 12:37:47
-- サーバのバージョン： 10.4.32-MariaDB
-- PHP のバージョン: 8.2.12

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- データベース: `imehackerz`
--

-- --------------------------------------------------------

--
-- テーブルの構造 `entries`
--

CREATE TABLE `entries` (
  `entry_name` varchar(60) NOT NULL,
  `entry_type` varchar(32) NOT NULL,
  `description` varchar(8192) DEFAULT NULL,
  `syntax` varchar(2048) DEFAULT NULL,
  `parameters` varchar(2048) DEFAULT NULL,
  `return_value` varchar(1024) DEFAULT NULL,
  `remarks` varchar(4096) DEFAULT NULL,
  `see_also` varchar(2048) DEFAULT NULL,
  `added_time` timestamp NOT NULL DEFAULT current_timestamp(),
  `modified_time` timestamp NOT NULL DEFAULT current_timestamp(),
  `header` varchar(128) DEFAULT NULL,
  `modules` varchar(128) DEFAULT NULL,
  `sources` varchar(256) DEFAULT NULL,
  `translators` varchar(128) DEFAULT NULL,
  `ros_location` varchar(256) DEFAULT NULL,
  `analysis` varchar(512) DEFAULT NULL,
  `prev_page` varchar(64) NOT NULL,
  `next_page` varchar(64) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- テーブルのデータのダンプ `entries`
--

INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('ABM_ACTIVATE', 'message', 'Notifies the system that an appbar has been activated. An appbar should call this message in response to the WM_ACTIVATE message.', 'SHAppBarMessage(ABM_ACTIVATE, pabd);', 'pabd --- A pointer to an APPBARDATA structure that identifies the appbar to activate. You must specify the cbSize and hWnd members when sending this message; all other members are ignored.', 'Always returns TRUE.', 'This message is ignored if the hWnd member of the structure pointed to by pabd identifies an autohide appbar. The system automatically sets the z-order for autohide appbars.', 'SHAppBarMessage|APPBARDATA', '2016-09-21 09:06:07', '2016-09-21 09:06:07', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787943.aspx', '', '', '', '', ''),
('ABM_GETAUTOHIDEBAR', 'message', 'Retrieves the handle to the autohide appbar associated with an edge of the screen. If the system has multiple monitors, the monitor that contains the primary taskbar is used.\r\n\r\nNote: To query for an autohide appbar on a specific monitor, use ABM_GETAUTOHIDEBAREX.', 'hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, pabd);', 'pabd --- A pointer to an APPBARDATA structure that specifies the screen edge. You must specify the cbSize and uEdge members when sending this message; all other members are ignored.', 'Returns the handle to the autohide appbar. The return value is NULL if an error occurs or if no autohide appbar is associated with the given edge.', '', 'SHAppBarMessage|APPBARDATA|ABM_GETAUTOHIDEBAREX', '2016-09-21 09:07:28', '2016-09-21 09:07:28', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787945.aspx', '', '', '', '', ''),
('ABM_GETAUTOHIDEBAREX', 'message', 'Retrieves the handle to the autohide appbar associated with an edge of the screen. This message extends ABM_GETAUTOHIDEBAR by enabling you to specify a particular monitor, for use in multiple monitor situations.', 'hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, pabd);', 'pabd --- A pointer to an APPBARDATA structure that specifies the screen edge and monitor. You must specify the cbSize, uEdge, and rc members when sending this message; all other members are ignored.', 'Returns the handle to the autohide appbar. The return value is NULL if an error occurs or if no autohide appbar is associated with the given edge of the given monitor.', '', 'SHAppBarMessage|APPBARDATA|ABM_GETAUTOHIDEBAR', '2016-09-21 09:08:31', '2016-09-21 09:08:31', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/hh706878.aspx', '', '', '', '', ''),
('ABM_GETSTATE', 'message', 'Retrieves the autohide and always-on-top states of the Windows taskbar.', 'uState = (UINT) SHAppBarMessage(ABM_GETSTATE, pabd);', 'pabd --- Pointer to an APPBARDATA structure. You must specify the cbSize member when sending this message; all other members are ignored.', 'Returns zero if the taskbar is neither in the autohide nor always-on-top state. Otherwise, the return value is one or both of the following:\r\n\r\n[table:ABM_GETSTATE_Table1]', '', 'SHAppBarMessage|APPBARDATA|ABM_SETSTATE', '2016-09-21 09:09:44', '2016-09-21 09:09:44', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787947.aspx', '', '', '', '', ''),
('ABM_GETTASKBARPOS', 'message', 'Retrieves the bounding rectangle of the Windows taskbar.', 'fResult = (BOOL) SHAppBarMessage(ABM_GETTASKBARPOS, pabd);', 'pabd --- A pointer to an APPBARDATA structure whose rc member receives the bounding rectangle, in screen coordinates, of the taskbar. You must specify the cbSize when sending this message; all other members are ignored.', 'Returns TRUE if successful; otherwise, FALSE.', 'Note that this applies only to the system taskbar. Other objects, particularly toolbars supplied with third-party software, also can be present. As a result, some of the screen area not covered by the Windows taskbar might not be visible to the user. To retrieve the area of the screen not covered by both the taskbar and other app bars—the working area available to your application—, use the GetMonitorInfo function.', 'SHAppBarMessage|APPBARDATA', '2016-09-21 09:11:32', '2016-09-21 09:11:32', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787949.aspx', '', '', '', '', ''),
('ABM_NEW', 'message', 'Registers a new appbar and specifies the message identifier that the system should use to send it notification messages. An appbar should send this message before sending any other appbar messages.', 'fRegistered = (BOOL) SHAppBarMessage(ABM_NEW, pabd);', 'pabd --- A pointer to an APPBARDATA structure that contains the new appbar\'s window handle and message identifier. You must specify the cbSize, hWnd, and uCallbackMessage members when sending this message; all other members are ignored.', 'Returns TRUE if successful, or FALSE if an error occurs or if the appbar is already registered.', '', 'SHAppBarMessage|APPBARDATA|ABM_REMOVE', '2016-09-21 09:12:27', '2016-09-21 09:12:27', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787951.aspx', '', '', '', '', ''),
('ABM_QUERYPOS', 'message', 'Requests a size and screen position for an appbar. When the request is made, the message proposes a screen edge and a bounding rectangle for the appbar. The system adjusts the bounding rectangle so that the appbar does not interfere with the Windows taskbar or any other appbars.', 'SHAppBarMessage(ABM_QUERYPOS, pabd);', 'pabd --- A pointer to an APPBARDATA structure. The uEdge member specifies a screen edge, and the rc member contains the proposed bounding rectangle. When the SHAppBarMessage function returns, rc contains the approved bounding rectangle. You must specify the cbSize, hWnd, uEdge, and rc members when sending this message; all other members are ignored.', 'Always returns TRUE.', 'An appbar should send this message before sending the ABM_SETPOS message.', 'SHAppBarMessage|APPBARDATA|ABM_SETPOS', '2016-09-21 09:13:34', '2016-09-21 09:13:34', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787953.aspx', '', '', '', '', ''),
('ABM_REMOVE', 'message', 'Unregisters an appbar by removing it from the system\'s internal list. The system no longer sends notification messages to the appbar or prevents other applications from using the screen area used by the appbar.', 'SHAppBarMessage(ABM_REMOVE, pabd);', 'pabd --- A pointer to an APPBARDATA structure that contains the handle to the appbar to unregister. You must specify the cbSize and hWnd members when sending this message; all other members are ignored.', 'Always returns TRUE.', 'This message causes the system to send the ABN_POSCHANGED notification message to all appbars.', 'SHAppBarMessage|APPBARDATA|ABM_NEW', '2016-09-21 09:14:28', '2016-09-21 09:14:28', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787955.aspx', '', '', '', '', ''),
('ABM_SETAUTOHIDEBAR', 'message', 'Registers or unregisters an autohide appbar for a given edge of the screen. If the system has multiple monitors, the monitor that contains the primary taskbar is used.\r\n\r\nNote: To register or unregister an autohide appbar on a specific monitor, use ABM_SETAUTOHIDEBAREX.', 'fSuccess = (BOOL) SHAppBarMessage(ABM_SETAUTOHIDEBAR, pabd);', 'pabd --- A pointer to an APPBARDATA structure. Set the lParam member to TRUE to register the appbar or FALSE to unregister it. You must specify the cbSize, hWnd, uEdge, and lParam members when sending this message; all other members are ignored.', 'Returns TRUE if successful, or FALSE if an error occurs or if an autohide appbar is already registered for the given edge.', 'The system allows only one autohide appbar for each edge of the screen. This is determined when the member uEdge of the APPBARDATA structure is set.', 'SHAppBarMessage|APPBARDATA|ABM_SETAUTOHIDEBAREX', '2016-09-21 09:15:48', '2016-09-21 09:15:48', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787957.aspx', '', '', '', '', ''),
('ABM_SETAUTOHIDEBAREX', 'message', 'Registers or unregisters an autohide appbar for a given edge of the screen. This message extends ABM_SETAUTOHIDEBAR by enabling you to specify a particular monitor, for use in multiple monitor situations.', 'fSuccess = (BOOL) SHAppBarMessage(ABM_SETAUTOHIDEBAR, pabd);', 'pabd --- A pointer to an APPBARDATA structure. Set the lParam member is to TRUE to register the appbar or FALSE to unregister it. You must specify the cbSize, hWnd, uEdge, rc, and lParam members when sending this message; all other members are ignored.', 'Returns TRUE if successful, or FALSE if an error occurs or if an autohide appbar is already registered for the given edge on the given monitor.', 'The system allows only one autohide appbar for each edge of each monitor. The monitor is determined by the rc member and the edge is determined by the uEdge member of the APPBARDATA structure.', 'SHAppBarMessage|APPBARDATA|ABM_SETAUTOHIDEBAR', '2016-09-21 09:16:49', '2016-09-21 09:16:49', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/hh706879.aspx', '', '', '', '', ''),
('ABM_SETPOS', 'message', 'Sets the size and screen position of an appbar. The message specifies a screen edge and the bounding rectangle for the appbar. The system may adjust the bounding rectangle so that the appbar does not interfere with the Windows taskbar or any other appbars.', 'SHAppBarMessage(ABM_SETPOS, pabd);', 'pabd --- A pointer to an APPBARDATA structure. The uEdge member specifies a screen edge, and the rc member contains the bounding rectangle. When the SHAppBarMessage function returns, rc contains the approved bounding rectangle. You must specify the cbSize, hWnd, uEdge, and rc members when sending this message; all other members are ignored.', 'Always returns TRUE.', 'This message causes the system to send the ABN_POSCHANGED notification message to all appbars.', 'SHAppBarMessage|APPBARDATA|ABM_QUERYPOS', '2016-09-21 09:17:46', '2016-09-21 09:17:46', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787959.aspx', '', '', '', '', ''),
('ABM_SETSTATE', 'message', 'Sets the autohide and always-on-top states of the Windows taskbar.', 'SHAppBarMessage(ABM_SETSTATE, pabd);', 'pabd --- A pointer to an APPBARDATA structure. You must specify the cbSize and hWnd members when sending this message. Data for the desired state is sent in the lParam member using one of the following values.\r\n\r\n[table:ABM_SETSTATE_Table1]', 'Always returns TRUE.', '', 'SHAppBarMessage|APPBARDATA|ABM_GETSTATE', '2016-09-21 09:18:50', '2016-09-21 09:18:50', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787961.aspx', '', '', '', '', ''),
('ABM_WINDOWPOSCHANGED', 'message', 'Notifies the system when an appbar\'s position has changed. An appbar should call this message in response to the WM_WINDOWPOSCHANGED message.', 'SHAppBarMessage(ABM_WINDOWPOSCHANGED, pabd);', 'pabd --- A pointer to an APPBARDATA structure that identifies the appbar to activate. You must specify the cbSize and hWnd members when sending this message; all other members are ignored.', 'Always returns TRUE.', 'This message is ignored if the hWnd member of the structure pointed to by pabd identifies an autohide appbar.', 'SHAppBarMessage|APPBARDATA', '2016-09-21 09:20:53', '2016-09-21 09:20:53', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787963.aspx', '', '', '', '', ''),
('ABN_FULLSCREENAPP', 'message', 'Notifies an appbar when a full-screen application is opening or closing. This notification is sent in the form of an application-defined message that is set by the ABM_NEW message.', 'ABN_FULLSCREENAPP\r\n    fOpen = (BOOL) lParam;', 'fOpen --- A flag specifying whether a full-screen application is opening or closing. This parameter is TRUE if the application is opening or FALSE if it is closing.', 'No return value.', 'When a full-screen application is opening, an appbar must drop to the bottom of the z-order. When it is closing, the appbar should restore its z-order position.', 'ABM_NEW', '2016-09-21 09:21:56', '2016-09-21 09:21:56', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787965.aspx', '', '', '', '', ''),
('ABN_POSCHANGED', 'message', 'Notifies an appbar when an event has occurred that may affect the appbar\'s size and position. Events include changes in the taskbar\'s size, position, and visibility state, as well as the addition, removal, or resizing of another appbar on the same side of the screen.', 'ABN_POSCHANGED', 'This message has no parameters.', 'No return value.', 'An appbar should respond to this notification message by sending the ABM_QUERYPOS and ABM_SETPOS messages. If its position has changed, the appbar should call the MoveWindow function to move itself to the new position.', 'ABM_QUERYPOS', '2016-09-21 09:22:57', '2016-09-21 09:22:57', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787967.aspx', '', '', '', '', ''),
('ABN_STATECHANGE', 'message', 'Notifies an appbar that the taskbar\'s autohide or always-on-top state has changed—that is, the user has selected or cleared the \"Always on top\" or \"Auto hide\" check box on the taskbar\'s property sheet.', 'ABN_STATECHANGE', 'This message has no parameters.', 'No return value.', 'An appbar can use this notification message to set its state to conform to that of the taskbar, if desired.', '', '2016-09-21 09:24:07', '2016-09-21 09:24:07', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787969.aspx', '', '', '', '', ''),
('ABN_WINDOWARRANGE', 'message', 'Notifies an appbar that the user has selected the Cascade, Tile Horizontally, or Tile Vertically command from the taskbar\'s shortcut menu.', 'ABN_WINDOWARRANGE\r\n    fBeginning = (BOOL) lParam;', 'fBeginning --- A flag specifying whether the cascade or tile operation is beginning. This parameter is TRUE if the operation is beginning and the windows have not yet been moved. It is FALSE if the operation has completed.', 'No return value.', 'The system sends this notification message twice—first with lParam set to TRUE and then with lParam set to FALSE. The first notification is sent before the windows are cascaded or tiled, and the second is sent after the cascade or tile operation has occurred.', '', '2016-09-21 09:26:03', '2016-09-21 09:26:03', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787971.aspx', '', '', '', '', ''),
('About Messages and Message Queues', '', 'Unlike MS-DOS-based applications, Windows-based applications are event-driven. They do not make explicit function calls (such as C run-time library calls) to obtain input. Instead, they wait for the system to pass input to them.\r\n\r\nThe system passes all input for an application to the various windows in the application. Each window has a function, called a window procedure, that the system calls whenever it has input for the window. The window procedure processes the input and returns control to the system. For more information about window procedures, see Window Procedures.\r\n\r\nIf a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding. In this case, the system hides the window and replaces it with a ghost window that has the same Z order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When in the debugger mode, the system does not generate a ghost window.', '', '', '', '', 'Window Procedure', '2016-09-03 06:39:56', '2016-09-03 06:39:56', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', '', 'Windows Messages'),
('About Supplementary Characters', '', 'A supplementary character is a character located beyond the BMP, and a \"surrogate\" is a UTF-16 code value. For UTF-16, a \"surrogate pair\" is required to represent a single supplementary character. The first (high) surrogate is a 16-bit code value in the range U+D800 to U+DBFF. The second (low) surrogate is a 16-bit code value in the range U+DC00 to U+DFFF. Using the surrogate mechanism, UTF-16 can support all 1,114,112 potential Unicode characters. For more details about supplementary characters, surrogates, and surrogate pairs, refer to The Unicode Standard.\r\n\r\nNote: Windows 2000 introduces support for basic input, output, and simple sorting of supplementary characters. However, not all system components are compatible with supplementary characters.\r\n\r\nThe operating system supports supplementary characters in the following ways:\r\n\r\n * Format 12 of the OpenType font cmap table directly supports the 4-byte character code. For more information, see the OpenType font specification.\r\n * Windows supports surrogate-enabled input method editors (IMEs).\r\n * The Windows GDI API supports format 12 cmap tables in fonts so that surrogates can be displayed correctly.\r\n * The Uniscribe API supports supplementary characters.\r\n * Windows controls, including Edit and Rich Edit, support supplementary characters.\r\n * The HTML engine supports HTML pages that include supplementary characters for display, editing (through Outlook Express), and forms submission.\r\n * The operating system sorting table supports supplementary characters.', '', '', '', '', '', '2016-09-17 06:58:52', '2016-09-17 06:58:52', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069.aspx', '', '', '', '', ''),
('About Unicode and Character Sets', '', 'The world\'s character-based data was developed using both Unicode and traditional character sets. Because of this, Windows provides character set functions that help applications convert the character-based data from its original character set to Unicode or another traditional character set. These character set functions also help applications create character-based data that can be transferred to and used on any operating system, including those that do not support Unicode.\r\n\r\nFor details about Unicode beyond the scope of this overview, see The Unicode Standard.\r\n\r\nThis section covers the following topics.\r\n\r\n * Character Sets \r\n * End-User-Defined and Private Use Area Characters \r\n * Unicode in the Windows API', '', '', '', '', 'Character Sets|End-User-Defined and Private Use Area Characters|Unicode in the Windows API', '2016-09-17 06:49:43', '2016-09-17 06:49:43', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317711.aspx', '', '', '', '', ''),
('Accessing the HIMC', '', 'When an IME accesses the Input Context, the IME has to call ImmLockIMC to get the pointer of the Input Context. ImmLockIMC increments the IMM lock count for IMC, while ImmUnlockIMC decrements the IMM lock count for IMC.', '', '', '', '', 'ImmLockIMC|ImmUnlockIMC', '2016-09-10 08:50:42', '2016-09-10 08:50:42', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Accessing the HIMCC', '', 'When an IME accesses a component of the Input Context, the IME has to call ImmLockIMCC to get the pointer of the IMCC. ImmLockIMCC increments the IMM lock count for IMCC, while ImmUnlockIMC decrements the IMM lock count for IMCC. ImmReSizeIMCC can resize the IMCC to the size specified in the input parameter.\r\n\r\nOn occasion, an IME needs to create a new component in the Input Context. The IME can call ImmCreateIMCC to do so. To destroy a newly created component in the Input Context, the IME can call ImmDestroyIMCC.', '', '', '', '', 'ImmLockIMCC|ImmUnlockIMCC|ImmCreateIMCC|ImmDestroyIMCC', '2016-09-10 08:52:06', '2016-09-10 08:52:06', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('ActivateKeyboardLayout', 'function', 'Sets the input locale identifier (formerly called the keyboard layout handle) for the calling thread or the current process. The input locale identifier specifies a locale as well as the physical layout of the keyboard.', 'HKL WINAPI ActivateKeyboardLayout(\r\n  _In_ HKL  hkl,\r\n  _In_ UINT Flags\r\n);', 'hkl [in] Type: HKL --- Input locale identifier to be activated.\r\n\r\nThe input locale identifier must have been loaded by a previous call to the LoadKeyboardLayout function. This parameter must be either the handle to a keyboard layout or one of the following values. \r\n\r\n[table:ActivateKeyboardLayout_Table1]\r\n///\r\nFlags [in] Type: UINT --- Specifies how the input locale identifier is to be activated. This parameter can be one of the following values.\r\n\r\n[table:ActivateKeyboardLayout_Table2]', 'The return value is of type HKL. If the function succeeds, the return value is the previous input locale identifier. Otherwise, it is zero. \r\n\r\nTo get extended error information, use the GetLastError function.', 'This function only affects the layout for the current process or thread.\r\n\r\nThis function is not restricted to keyboard layouts. The hkl parameter is actually an input locale identifier. This is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input. Several input locale identifiers can be loaded at any one time, but only one is active at a time. Loading multiple input locale identifiers makes it possible to rapidly switch between them. \r\n\r\nWhen multiple IMEs are allowed for each locale, passing an input locale identifier in which the high word (the device handle) is zero activates the first IME in the list belonging to the locale.\r\n\r\nThe KLF_RESET and KLF_SHIFTLOCK flags alter the method by which the Caps Lock state is turned off. By default, the Caps Lock state is turned off by hitting the Caps Lock key again. If only KLF_RESET is set, the default state is reestablished. If KLF_RESET and KLF_SHIFTLOCK are set, the Caps Lock state is turned off by pressing either Caps Lock key. This feature is used to conform to local keyboard behavior standards as well as for personal preferences.', 'LoadKeyboardLayout|GetKeyboardLayoutName|UnloadKeyboardLayout', '2016-09-11 03:20:29', '2016-09-11 03:20:29', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646289.aspx', '', '', '', '', ''),
('APPBARDATA', 'structure', 'Contains information about a system appbar message.', 'typedef struct {\r\n  DWORD  cbSize;\r\n  HWND   hWnd;\r\n  UINT   uCallbackMessage;\r\n  UINT   uEdge;\r\n  RECT   rc;\r\n  LPARAM lParam;\r\n} APPBARDATA, *PAPPBARDATA;', 'cbSize Type: DWORD --- The size of the structure, in bytes.\r\n///\r\nhWnd Type: HWND --- The handle to the appbar window. Not all messages use this member. See the individual message page to see if you need to provide an hWind value.\r\n///\r\nuCallbackMessage Type: UINT --- An application-defined message identifier. The application uses the specified identifier for notification messages that it sends to the appbar identified by the hWnd member. This member is used when sending the ABM_NEW message.\r\n///\r\nuEdge Type: UINT --- A value that specifies an edge of the screen. This member is used when sending one of these messages:\r\n\r\n * ABM_GETAUTOHIDEBAR\r\n * ABM_SETAUTOHIDEBAR\r\n * ABM_GETAUTOHIDEBAREX\r\n * ABM_SETAUTOHIDEBAREX\r\n * ABM_QUERYPOS\r\n * ABM_SETPOS\r\n\r\nThis member can be one of the following values.\r\n\r\n[table:APPBARDATA_Table1]\r\n///\r\nrc Type: RECT --- A RECT structure whose use varies depending on the message:\r\n\r\n * ABM_GETTASKBARPOS, ABM_QUERYPOS, ABM_SETPOS: The bounding rectangle, in screen coordinates, of an appbar or the Windows taskbar.\r\n * ABM_GETAUTOHIDEBAREX, ABM_SETAUTOHIDEBAREX: The monitor on which the operation is being performed. This information can be retrieved through the GetMonitorInfo function.\r\n///\r\nlParam Type: LPARAM --- A message-dependent value. This member is used with these messages:\r\n\r\n * ABM_SETAUTOHIDEBAR\r\n * ABM_SETAUTOHIDEBAREX\r\n * ABM_SETSTATE\r\n\r\nSee the individual message pages for details.', '', '', '', '2016-09-21 09:04:11', '2016-09-21 09:04:11', 'shellapi.h', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb773184.aspx', '', '', '', '', ''),
('Application-Created Input Context', '', 'A window of an application can associate its window handle to an Input Context to maintain any status of the IME, \r\nincluding an intermediate composition string. Once an application associates an Input Context to a window handle, \r\nthe system automatically selects the context whenever the window is activated. In this way, an application is free \r\nfrom complicated in and out focus processing.', '', '', '', '', 'IME Input Context|Default Input Context', '2016-09-10 08:47:44', '2016-09-10 08:47:44', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Application-Defined Messages', '', 'An application can create messages to be used by its own windows or to communicate with windows in other processes. If an application creates its own messages, the window procedure that receives them must interpret the messages and provide appropriate processing. \r\n\r\nMessage-identifier values are used as follows: \r\n\r\n * The system reserves message-identifier values in the range 0x0000 through 0x03FF (the value of WM_USER  – 1) for system-defined messages. Applications cannot use these values for private messages. \r\n * Values in the range 0x0400 (the value of WM_USER) through 0x7FFF are available for message identifiers for private window classes. \r\n * If your application is marked version 4.0, you can use message-identifier values in the range 0x8000 (WM_APP) through 0xBFFF for private messages. \r\n * The system returns a message identifier in the range 0xC000 through 0xFFFF when an application calls the RegisterWindowMessage function to register a message. The message identifier returned by this function is guaranteed to be unique throughout the system. Use of this function prevents conflicts that can arise if other applications use the same message identifier for different purposes.', '', '', '', '', '', '2016-09-03 06:48:48', '2016-09-03 06:48:48', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'System-Defined Messages', 'Message Routing'),
('Broadcasting Messages', '', 'Each message consists of a message identifier and two parameters, wParam and lParam. The message identifier is a unique value that specifies the message purpose. The parameters provide additional information that is message-specific, but the wParam parameter is generally a type value that provides more information about the message.\r\n\r\nA message broadcast is simply the sending of a message to multiple recipients in the system. To broadcast a message from an application, use the BroadcastSystemMessage function, specifying the recipients of the message. Rather than specify individual recipients, you must specify one or more types of recipients. These types are applications, installable drivers, network drivers, and system-level device drivers. The system sends broadcast messages to all members of each specified type. \r\n\r\nThe system typically broadcasts messages in response to changes that take place within system-level device drivers or related components. The driver or related component broadcasts the message to applications and other components to notify them of the change. For example, the component responsible for disk drives broadcasts a message whenever the device driver for the floppy disk drive detects a change of media such as when the user inserts a disk in the drive.\r\n\r\nThe system broadcasts messages to recipients in this order: system-level device drivers, network drivers, installable drivers, and applications. This means that system-level device drivers, if chosen as recipients, always get the first opportunity to respond to a message. Within a given recipient type, no driver is guaranteed to receive a given message before any other driver. This means that a message intended for a specific driver must have a globally-unique message identifier so that no other driver unintentionally processes it.\r\n\r\nYou can also broadcast messages to all top-level windows by specifying HWND_BROADCAST in the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. \r\n\r\nApplications receive messages through the window procedure of their top-level windows. Messages are not sent to child windows. Services can receive messages through a window procedure or their service control handlers.\r\n\r\nNote  System-level device drivers use a related, system-level function to broadcast system messages.', '', '', '', '', '', '2016-09-03 06:58:35', '2016-09-03 06:58:35', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Message Deadlocks', 'Query Messages'),
('CANDIDATEFORM', 'structure', 'Contains the position information for the candidate window.', 'typedef struct {\r\n  DWORD dwIndex;\r\n  DWORD dwStyle;\r\n  POINT ptCurrentPos;\r\n  RECT  rcArea;\r\n} CANDIDATEFORM;', 'dwIndex --- Unsigned long integer value that contains the candidate list identifier. This can be a value between 0 and 31.\r\n/// \r\ndwStyle --- Unsigned long integer value that contains the position style. This can be one of the following values:\r\n\r\n[table:CANDIDATEFORM_Table1]\r\n///\r\nptCurrentPos --- POINT value that contains the coordinates of the upper-left corner of the candidate window or the caret position, depending on the value of dwStyle. \r\n///\r\nrcArea --- RECT value that contains the coordinates of the upper-left and lower-right corners of the exclusion area.', '', 'This structure maps to the CANDIDATEFORM structure documented in the Windows Software Development Kit (SDK).', '', '2016-08-28 05:39:42', '2016-08-28 05:39:42', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741223.aspx', '', '', '', '', ''),
('CANDIDATEINFO', 'structure', 'A header of the entire candidate information. This structure can contain 32 \r\ncandidate lists at most, and these candidate lists have to be in the same memory block.', 'typedef struct {\r\n    DWORD dwSize;\r\n    DWORD dwCount;\r\n    DWORD dwOffset[32];\r\n    DWORD dwPrivateSize;\r\n    DWORD dwPrivateOffset;\r\n} CANDIDATEINFO;', 'dwSize --- Memory block size of this structure.\r\n///\r\ndwCount --- Number of the candidate lists that are included in this memory block.\r\n///\r\ndwOffset[32] --- Contents are the offset from the start position of this structure. Each offset specifies the start position of each candidate list.\r\n///\r\ndwPrivateSize --- Private area in this memory block.\r\n///\r\ndwPrivateOffset --- Offset from the start position of this structure. The private area is stored here.', '', '', 'CANDIDATELIST', '2016-09-10 03:47:19', '2016-09-10 03:47:19', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('CANDIDATELIST', 'structure', 'Contains information about a candidate list.', 'typedef struct {\r\n  DWORD dwSize;\r\n  DWORD dwStyle;\r\n  DWORD dwCount;\r\n  DWORD dwSelection;\r\n  DWORD dwPageStart;\r\n  DWORD dwPageSize;\r\n  DWORD dwOffset[1];\r\n} CANDIDATELIST;', 'dwSize --- Unsigned long integer value that contains the size, in bytes, of the structure, the offset array, and all candidate strings. \r\n///\r\ndwStyle --- Unsigned long integer value that contains the candidate style values. This can be one or more of the following values.\r\n\r\n[table:CANDIDATELIST_Table1]\r\n///\r\ndwCount --- Unsigned long integer value that contains the number of candidate strings. \r\n///\r\ndwSelection --- Unsigned long integer value that contains the index of the selected candidate string. \r\n///\r\ndwPageStart --- Unsigned long integer value that contains the index of the first candidate string in the candidate window. This varies as the user presses the PAGE UP and PAGE DOWN keys. \r\n///\r\ndwPageSize --- Unsigned long integer value that contains the number of candidate strings to be shown in one page in the candidate window. The user can move to the next page by pressing Active IME-defined keys, such as the PAGE UP or PAGE DOWN key. If this number is zero, an application can define a proper value by itself. \r\n///\r\ndwOffset --- Address of an array of unsigned long integer values that contains the offset to the start of the first candidate string, relative to the start of this structure. The offsets for subsequent strings immediately follow this member, forming an array of 32-bit offsets.', '', 'This structure maps to the CANDIDATELIST structure documented in the Windows Software Development Kit (SDK).', 'CANDIDATEINFO', '2016-08-28 05:42:43', '2016-08-28 05:42:43', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741224.aspx', '', '', '', '', ''),
('Character Messages', '', 'Keystroke messages provide a lot of information about keystrokes, but they do not provide character codes for character keystrokes. To retrieve character codes, an application must include the TranslateMessage function in its thread message loop. TranslateMessage passes a WM_KEYDOWN or WM_SYSKEYDOWN message to the keyboard layout. The layout examines the message\'s virtual-key code and, if it corresponds to a character key, provides the character code equivalent (taking into account the state of the SHIFT and CAPS LOCK keys). It then generates a character message that includes the character code and places the message at the top of the message queue. The next iteration of the message loop removes the character message from the queue and dispatches the message to the appropriate window procedure.\r\n\r\nThis section covers the following topics:\r\n\r\n * Nonsystem Character Messages\r\n * Dead-Character Messages', '', '', '', '', '', '2016-09-11 13:03:23', '2016-09-11 13:03:23', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Character Sets', '', 'A \"character set\" is a mapping of characters to their identifying code values. The character set most commonly used in computers today is Unicode, a global standard for character encoding. Internally, Windows applications use the UTF-16 implementation of Unicode. In UTF-16, most characters are identified by two-byte codes. The less commonly used supplementary characters are each represented by a surrogate pair, which is a pair of two-byte codes. For more information, see Surrogates and Supplementary Characters.\r\n\r\nSome Windows applications must work with the older character sets that are native to Windows Me/98/95. Windows code pages allow your application to work with these character sets. These character sets can be divided into:\r\n\r\n * Single-byte character sets (SBCS). In an SBCS, each character is identified by a value one byte wide.\r\n * Multibyte character sets, in particular the double-byte character sets (DBCS). Multibyte character sets provide a means to represent the large number of characters in many Asian languages.\r\n\r\nFor more information, see the following topics:\r\n\r\n * Code Pages \r\n * Double-byte Character Sets \r\n * Single-byte Character Sets \r\n * Surrogates and Supplementary Characters \r\n * Unicode', '', '', '', '', 'Code Pages|Double-byte Character Sets|Single-byte Character Sets|Surrogates and Supplementary Characters|Unicode', '2016-09-17 06:51:39', '2016-09-17 06:51:39', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317743.aspx', '', '', '', '', ''),
('Code Page Identifiers', '', 'The following table defines the available code page identifiers.\r\n\r\nNote: ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, applications should use Unicode, such as UTF-8 or UTF-16, instead of a specific code page.\r\n\r\n[table:Code Page Identifiers_Table1]', '', '', '', '', '', '2016-09-22 03:39:19', '2016-09-22 03:39:19', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317756.aspx', '', '', '', '', ''),
('Code Pages', '', 'Most applications written today handle character data primarily as Unicode, using the UTF-16 encoding. However, many legacy applications continue to use character sets based on code pages. Even new applications sometimes have to work with code pages, often for one of the following reasons:\r\n\r\n * To communicate with legacy applications.\r\n * To communicate with older mail and news servers, which might not always support Unicode.\r\n * To communicate with the Windows Console, which does not support Unicode.\r\n\r\nNote: New Windows applications should use Unicode to avoid the inconsistencies of varied code pages and for ease of localization.\r\n\r\nEach code page is represented by a code page identifier, for example, 1252, and is handled by the Unicode and character set API functions. For a list of supported code page identifiers, see Code Page Identifiers. The \"Code Pages\" reference on the Microsoft Go Global Developer Center gives full descriptions of many code pages.\r\n\r\nWindows code pages, commonly called \"ANSI code pages\", are code pages for which non-ASCII values (values greater than 127) represent international characters. These code pages are used natively in Windows Me, and are also available on Windows NT and later.\r\n\r\nNote: Originally, Windows code page 1252, the code page commonly used for English and other Western European languages, was based on an American National Standards Institute (ANSI) draft. That draft eventually became ISO 8859-1, but Windows code page 1252 was implemented before the standard became final, and is not exactly the same as ISO 8859-1.\r\n\r\nMany Windows API functions have \"A\" (ANSI) and \"W\" (wide, Unicode) versions. The \"A\" version handles text based on Windows code pages, while the \"W\" version handles Unicode text. See Windows Data Types for Strings and Conventions for Function Prototypes.\r\n\r\nWindows code pages are also sometimes referred to as \"active code pages\" or \"system active code pages\". A Windows operating system always has one currently active Windows code page. All ANSI versions of API functions use the currently active code page.\r\n\r\nOriginal equipment manufacturer (OEM) code pages are code pages for which non-ASCII values represent line drawing and punctuation characters. These code pages were originally used for MS-DOS and are still used for console applications. They are also used for the non-extended file names in the FAT12, FAT16, and FAT32 file systems, as described in Character Sets Used in File Names. The usual OEM code page for English is code page 437.\r\n\r\nFor both Windows code pages and OEM code pages, the code values 0x00 through 0x7F correspond to the 7-bit ASCII character set. Code values 0x00 through 0x19 and 0x7F always represent standardized control characters and 0x20 through 0x7E represent standardized displayable characters. Characters represented by the remaining codes, 0x80 through 0xff, vary among character sets. Each character set includes different special characters, typically customized for a language or group of languages. Windows code page 1252 and OEM code page 437 are generally used in the United States.\r\n\r\nIn addition to Windows and OEM code pages, your applications can use non-native code pages. Examples are EBCDIC and Macintosh code pages.\r\n\r\nTwo encodings of Unicode (UTF-7 and UTF-8) are implemented as code pages. Like other code pages, each page is known by a numeric identifier and can be handled with many of the same Unicode and character set API functions.\r\n\r\nCode pages can be either single-byte character set (SBCS) pages or double-byte character set (DBCS) pages. In SBCS pages, each byte directly encodes a single character, so that it is possible to represent exactly 256 distinct characters (including control characters, letters, digits, punctuation, symbols, and the like). DBCS code pages are used for languages such as Japanese and Chinese. In such a code page, some characters have two-byte encodings with certain byte values (always values greater than 127) serving as \"lead bytes\". Instead of encoding characters in their own right, lead bytes can be mapped to a character only in conjunction with a \"trail byte\".\r\n\r\nSome legacy protocols require the use of SBCS and DBCS code pages. Each SBCS/DBCS code page supports different characters, but no code page supports the full breadth of characters provided by Unicode. Each SBCS/DBCS code page supports a different subset, differently encoded.\r\n\r\nNote: Data converted from one SBCS or DBCS code page to another is subject to corruption, because the same data value on different code pages can encode a different character. Data converted from Unicode to SBCS or DBCS is subject to data loss, because a given code page might not be able to represent every character used in that particular Unicode data.\r\n\r\nIn addition to SBCS and DBCS code pages, your applications have available the multibyte character set code pages 52936, 54936, 51949, and 5022x, which use an approach similar to that for a DBCS. A multibyte character set code page goes beyond two-byte encodings of some characters, however. UTF-7 and UTF-8 use a similar approach to encode Unicode based on a 7-bit and 8-bit bytes, respectively. For more information, see Unicode.\r\n\r\nSeveral Unicode and character set functions allow your applications to handle code pages. An application can use the GetCPInfo and GetCPInfoEx functions to obtain information about a code page. This information includes the default character used when a character in a converted string has no corresponding entry in the code page.\r\n\r\nAn application can use the MultiByteToWideChar and WideCharToMultiByte functions to convert between strings based on Windows code pages and Unicode strings. Although their names refer to \"MultiByte\", these functions work equally well with SBCS, DBCS, and multibyte character set code pages.\r\n\r\nNote: WideCharToMultiByte can lose some data if the supplied code page cannot represent all characters in a Unicode string.\r\n\r\nYour application can convert between Windows code pages and OEM code pages using the standard C runtime library functions. However, use of these functions presents a risk of data loss because the characters that can be represented by each code page do not match exactly.\r\n\r\nYour applications can also call the GetACP function. This function retrieves the identifier of the current Windows (ANSI) code page.', '', '', '', '', 'Unicode|Conventions for Function Prototypes', '2016-09-17 06:54:25', '2016-09-17 06:54:25', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317752.aspx', '', '', '', '', ''),
('Components of the UI Window', '', 'The UI window can register and show the composition window and the status window by referring to the current Input Context. The class style of the components of the UI window must include the CS_IME bit. A window instance of the UI window gets information about the composition string, font, and position from the current Input Context.  \r\n\r\nWhen a window of the application is getting focused, the system gives the Input Context to this window and sets the current Input Context to the UI window. The system then sends a WM_IME_SETCONTEXT message with the handle of its Input Context to the application. The application then passes this message to the UI window. If current Input Context is replaced by another Input Context, the UI window should repaint the composition window. Any time the current Input Context is changed, the UI window displays a correct composition window. Thus, the status of the IME is assured.\r\n\r\nA UI window can create a child window or pop-up window to display its status, composition string, or candidate lists. However, these windows have to be owned by the UI window and created as disabled windows. Any windows that are created by the IME should not get the focus.', '', '', '', '', 'WM_IME_SETCONTEXT', '2016-09-10 08:44:15', '2016-09-10 08:44:15', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Composition String', '', 'The composition string is the current text in the composition window. This is the text that the IME converts to final characters. Each composition string consists of one or more \"clauses\". A clause is the smallest combination of characters that the IME can convert to a final character. To get and set the composition string, the application calls the ImmGetCompositionString and ImmSetCompositionString functions, respectively.\r\n\r\nAs the user enters text in the composition window, the IME tracks the status of the composition string. This status includes attribute information, clause information, typing information, and cursor position. The application can retrieve the composition status by using the ImmGetCompositionString function.\r\n\r\nAttribute information is rendered in an array of 8-bit values that specifies the status of characters in the composition string. All characters of one clause must have the same attribute. The array includes one value for each byte in the string, including one byte each for the lead and second bytes of any double-byte characters in the string. For each value in the array, bits 0 through 3 can be one combination of the following values.\r\n\r\n[table:Composition String_Table1]\r\n\r\nAll other values are reserved. In Japanese, any unconverted character having the ATTR_INPUT attribute is a hiragana, katakana, or alphanumeric character. In Korean, this attribute represents a Hangul character that the IME has not yet converted. In Traditional Chinese and Simplified Chinese, each IME can limit its character within some range.\r\n\r\nThe clause information included in the composition string status is an array of 32-bit values that specifies the positions of the clauses in the composition string. The array includes one value for each clause and a final value that specifies the length of the full string. Each value in the array specifies the offset, in bytes, from the beginning of the string to the clause. The first value is always 0 because the first clause always starts at the beginning of the string. For example, if a string has two clauses, the clause information has three values: the first value is 0, the second value is the offset of the second clause, and the third value is the length of the string. For Unicode, the position of a clause is counted in Unicode characters, and the length of a string is the size in Unicode characters.\r\n\r\nThe typing information included in the composition string status is a null-terminated character string representing the characters that the user enters at the keyboard.\r\n\r\nThe cursor position included in the composition string status is a value indicating the position of the cursor relative to the characters in the composition string. The value is the offset, in bytes, from the beginning of the string. If this value is 0, the cursor is immediately before the first character in the string. If the value is equal to the length of the string, the cursor is immediately after the last character. If the value is 1, the cursor is not present. For Unicode, both position and length are measured in Unicode characters.\r\n\r\nYour application can set the composition string or elements of the composition status by using the ImmSetCompositionString function. To ensure that the composition window updates its appearance based on these changes, the function allows the application to send a notification message to the window. Applications that set a combination of composition status elements typically disable notifications for all but the last call to this function so that only one notification message is generated for the composition window.\r\n\r\nFinally, the edit control supports two messages for changing the handling of composition strings by the IME. For more information, see EM_GETIMESTATUS and EM_SETIMESTATUS. For more information on the edit control, see Edit Control.', '', '', '', '', 'ImmGetCompositionString|ImmSetCompositionString|EM_GETIMESTATUS|EM_SETIMESTATUS', '2016-09-03 01:46:37', '2016-09-03 01:46:37', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317765.aspx', '', '', '', '', ''),
('COMPOSITIONFORM', 'structure', 'Contains position information for a composition window.', 'typedef struct {\r\n  DWORD dwStyle;\r\n  POINT ptCurrentPos;\r\n  RECT  rcArea;\r\n} COMPOSITIONFORM;', 'dwStyle --- Unsigned long integer value that contains the position style. This can be one of the following values:\r\n\r\n[table:COMPOSITIONFORM_Table1]\r\n///\r\nptCurrentPos --- POINT value that contains the coordinates of the upper-left corner of the composition window. \r\n///\r\nrcArea --- RECT value that contains the coordinates of the upper-left and lower-right corners of the composition window.', '', 'This structure maps to the COMPOSITIONFORM structure documented in the Windows Software Development Kit (SDK).', 'COMPOSITIONSTRING', '2016-08-28 05:44:43', '2016-08-28 05:44:43', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741225.aspx', '', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('COMPOSITIONSTRING', 'structure', 'Contains the composition information. During conversion, an IME places conversion information into this structure.', 'typedef struct {\r\n    DWORD dwSize;\r\n    DWORD dwCompReadAttrLen;\r\n    DWORD dwCompReadAttrOffset;\r\n    DWORD dwCompReadClsLen;\r\n    DWORD dwCompReadClsOffset;\r\n    DWORD dwCompReadStrLen;\r\n    DWORD dwCompReadStrOffset;\r\n    DWORD dwCompAttrLen;\r\n    DWORD dwCompAttrOffset;\r\n    DWORD dwCompClsLen;\r\n    DWORD dwCompClsOffset;\r\n    DWORD dwCompStrLen;\r\n    DWORD dwCompStrOffset;\r\n    DWORD dwCursorPos;\r\n    DWORD dwDeltaStart;\r\n    DWORD dwResultReadClsLen;\r\n    DWORD dwResultReadClsOffset;\r\n    DWORD dwResultReadStrLen;\r\n    DWORD dwResultReadStrOffset;\r\n    DWORD dwResultClsLen;\r\n    DWORD dwResultClsOffset;\r\n    DWORD dwResultStrLen;\r\n    DWORD dwResultStrOffset;\r\n    DWORD dwPrivateSize;\r\n    DWORD dwPrivateOffset;\r\n} COMPOSITIONSTRING;', 'dwSize --- Memory block size of this structure.\r\n///\r\ndwCompReadAttrLen --- Length of the attribute information of the reading string of the composition string.\r\n///\r\ndwCompReadAttrOffset --- Offset from the start position of this structure. Attribute information is stored here.\r\n///\r\ndwCompReadClsLen --- Length of the clause information of the reading string of the composition string.\r\n///\r\ndwCompReadClsOffset --- Offset from the start position of this structure. Clause information is stored here.\r\n///\r\ndwCompReadStrLen --- Length of the reading string of the composition string.\r\n///\r\ndwCompReadStrOffset --- Offset from the start position of this structure. Reading string of the composition string is stored here.\r\n///\r\ndwCompAttrLen --- Length of the attribute information of the composition string.\r\n///\r\ndwCompAttrOffset --- Offset from the start position of this structure. Attribute information is stored here.\r\n///\r\ndwCompClsLen --- Length of the clause information of the composition string.\r\n///\r\ndwCompClsOffset --- Offset from the start position of this structure. Clause information is stored here.\r\n///\r\ndwCompStrLen --- Length of the composition string.\r\n///\r\ndwCompStrOffset --- Offset from the start position of this structure. The composition string is stored here.\r\n///\r\ndwCursorPos --- Cursor position in the composition string.\r\n///\r\ndwDeltaStart --- Start position of change in the composition string. If the composition string has changed from the previous state, the first position of such a change is stored here.\r\n///\r\ndwResultReadClsLen --- Length of the clause information of the reading string of the result string.\r\n///\r\ndwResultReadClsOffset --- Offset from the start position of this structure. Clause information is stored here.\r\n///\r\ndwResultRieadStrLen --- Length of the reading string of the result string.\r\n///\r\ndwResultReadStrOffset --- Offset from the start position of this structure. Reading string of the result string is stored at this point.\r\n///\r\ndwResultClsLen --- Length of the clause informat', '', 'For Unicode: All dw*StrLen members contain the size in Unicode characters of the string in the corresponding \r\nbuffer. Other dw*Len and dw*Offset members contain the size in bytes of the corresponding buffer. \r\n \r\nThe format of the attribute information is a single-byte array and specifies the attribute of string. The following \r\nvalues are provided. Those not listed are reserved.\r\n\r\n[table:COMPOSITIONSTRING_Table1]\r\n\r\nFollowing is a description of the content for the values provided in the preceding table.\r\n\r\n[table:COMPOSITIONSTRING_Table2]\r\n\r\nThe length of the attribute information is the same as the length of the string. Each byte corresponds to each byte \r\nof the string. Even if the string includes DBCS characters, the attribute information has the information bytes of \r\nboth the lead byte and the second byte. \r\n\r\nFor Windows NT Unicode, the length of the attribute information is the same as the length in Unicode character \r\ncounts. Each attribute byte corresponds to each Unicode character of the string. \r\n\r\nThe format of the clause information is a double-word array and specifies the numbers that indicate the position of \r\nthe clause. The position of the clause is the position of the composition string, with the clause starting from this \r\nposition. At the least, the length of information is two double words. This means the length of the clause \r\ninformation is 8 bytes. The first double word has to be zero and is the start position of the first clause. The last \r\ndouble word has to be the length of this string. For example, if the string has three clauses, the clause information \r\nhas four double words. The first double word is zero. The second double word specifies the start position of the \r\nsecond clause. The third double word specifies the start position of the third clause. The last double word is the \r\nlength of this string. \r\n\r\nFor Windows NT Unicode, the position of each clause and the length of the string is counted in Unicode characters. \r\n\r\nThe dwCursorPos member specifies the cursor position and indicates where the cursor is located within the \r\ncomposition string, in terms of the count of that character. The counting starts at zero. If the cursor is to be \r\npositioned immediately after the composition string, this value should be equal to the length of the composition \r\nstring. In the event there is no cursor, a value of -1 is specified here. If a composition string does not exist, this \r\nmember is invalid. \r\n\r\nFor Windows NT Unicode, the cursor position is counted in Unicode characters.', '', '2016-09-10 03:42:04', '2016-09-10 03:42:04', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Context Code', '', 'The context code indicates whether the ALT key was down when the keystroke message was generated. The code is 1 if the ALT key was down and 0 if it was up.', '', '', '', '', '', '2016-09-11 13:01:28', '2016-09-11 13:01:28', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Dead-Character Messages', '', 'Some non-English keyboards contain character keys that are not expected to produce characters by themselves. Instead, they are used to add a diacritic to the character produced by the subsequent keystroke. These keys are called dead keys. The circumflex key on a German keyboard is an example of a dead key. To enter the character consisting of an \"o\" with a circumflex, a German user would type the circumflex key followed by the \"o\" key. The window with the keyboard focus would receive the following sequence of messages:\r\n\r\n1. WM_KEYDOWN \r\n2. WM_DEADCHAR \r\n3. WM_KEYUP \r\n4. WM_KEYDOWN \r\n5. WM_CHAR \r\n6. WM_KEYUP \r\n\r\nTranslateMessage generates the WM_DEADCHAR message when it processes the WM_KEYDOWN message from a dead key. Although the wParam parameter of the WM_DEADCHAR message contains the character code of the diacritic for the dead key, an application typically ignores the message. Instead, it processes the WM_CHAR message generated by the subsequent keystroke. The wParam parameter of the WM_CHAR message contains the character code of the letter with the diacritic. If the subsequent keystroke generates a character that cannot be combined with a diacritic, the system generates two WM_CHAR messages. The wParam parameter of the first contains the character code of the diacritic; the wParam parameter of the second contains the character code of the subsequent character key.\r\n\r\nThe TranslateMessage function generates the WM_SYSDEADCHAR message when it processes the WM_SYSKEYDOWN message from a system dead key (a dead key that is pressed in combination with the ALT key). An application typically ignores the WM_SYSDEADCHAR message.', '', '', '', '', '', '2016-09-11 13:05:25', '2016-09-11 13:05:25', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Default and Application IME Window', '', 'The system creates a default IME window at thread initialization time, which is given to a thread automatically. This window then handles any IME user interface for an IME unaware application.\r\n\r\nWhen the IME or IMM generates WM_IME_xxx messages, an IME unaware application passes them to DefWindowProc. Then, DefWindowProc sends necessary messages to the default IME window, which provides default behavior of the IME User Interface for an unaware application. An IME aware application also uses this window when it does not hook messages from the IME. An application can use its own application IME window when it is necessary.', '', '', '', '', 'DefWindowProc', '2016-09-10 08:34:01', '2016-09-10 08:34:01', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Default Input Context', '', 'By default, the system creates a default Input Context for each thread. All IME unaware windows of the thread \r\nshare this context.', '', '', '', '', 'IME Input Context|Application-Created Input Context', '2016-09-10 08:46:52', '2016-09-10 08:46:52', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('DefWindowProc', 'function', 'Calls the default window procedure to provide default processing for any window messages that an application does not process. This function ensures that every message is processed. DefWindowProc is called with the same parameters received by the window procedure.', 'LRESULT WINAPI DefWindowProc(\r\n  _In_ HWND   hWnd,\r\n  _In_ UINT   Msg,\r\n  _In_ WPARAM wParam,\r\n  _In_ LPARAM lParam\r\n);', 'hWnd [in] Type: HWND --- A handle to the window procedure that received the message.\r\n/// \r\nMsg [in] Type: UINT --- The message. \r\n///\r\nwParam [in] Type: WPARAM --- Additional message information. The content of this parameter depends on the value of the Msg parameter. \r\n///\r\nlParam [in] Type: LPARAM --- Additional message information. The content of this parameter depends on the value of the Msg parameter.', 'The return value is the result of the message processing and depends on the message.', '', 'Window|Procedure|CallWindowProc|DefDlgProc|WindowProc', '2016-08-25 05:10:12', '2016-08-25 05:10:12', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms633572.aspx', '', '', '', '', ''),
('Double-byte Character Sets', '', 'A double-byte character set (DBCS), also known as an \"expanded 8-bit character set\", is an extended single-byte character set (SBCS), implemented as a code page. DBCSs were originally developed to extend the SBCS design to handle languages such as Japanese and Chinese. Some characters in a DBCS, including the digits and letters used for writing English, have single-byte code values. Other characters, such as Chinese ideographs or Japanese kanji, have double-byte code values. A DBCS can correspond either to a Windows code page or an OEM code page. A DBCS code page can also include a non-native code page, for example, an EBCDIC code page. For definitions of these code pages, see Code Pages.\r\n\r\nNote: New Windows applications should use Unicode to avoid the inconsistencies of varied code pages and for ease of localization. However, some legacy protocols might require the use of DBCS code pages. Each DBCS code page supports different characters, but no page supports the full breadth of characters provided by Unicode. Each DBCS code page supports a different subset, differently encoded. Data converted from one DBCS code page to another is subject to corruption because the same data value on different code pages can encode a different character. Data converted from Unicode to DBCS is subject to data loss, because a given code page might not be able to represent every character used in that particular Unicode data.\r\n\r\nTo interpret a DBCS string, an application must start at the beginning of the string and scan forward. It keeps track when it encounters a lead byte in the string, and treats the next byte as the trailing part of the same character. If the application simply scans the string one byte at a time and encounters a byte that appears to be the code value representing a backslash (\"\\\"), that byte might simply be the trail byte of a two-byte character. The application cannot just back up one byte to see if the preceding byte is a lead byte, as that byte value might be eligible to be used as both a lead byte and a trail byte. Thus the application has essentially the same problem with it as with the possible backslash. In other words, substring searches are much more complicated with a DBCS than with either SBCSs or Unicode. Accordingly, applications that support a DBCS must use special functions, such as _mbsstr, instead of the StrStr function.\r\n\r\nYour applications use DBCS Windows code pages with the \"A\" versions of Windows functions. See Conventions for Function Prototypes and Code Pages. To help identify a DBCS code page, an application can use the GetCPInfo or GetCPInfoEx function. An application can use the IsDBCSLeadByte function to determine if a given value can be used as the lead byte of a 2-byte character. In addition, an application can use the MultiByteToWideChar and WideCharToMultiByte functions to map between Unicode and DBCS strings.', '', '', '', '', 'Code Pages', '2016-09-17 06:55:23', '2016-09-17 06:55:23', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317794.aspx', '', '', '', '', ''),
('EM_GETIMESTATUS', 'message', 'Gets a set of status flags that indicate how the edit control interacts with the Input Method Editor (IME).', 'EM_GETIMESTATUS', 'wParam --- The type of status to retrieve. This parameter can be the following value.\r\n\r\n[table:EM_GETIMESTATUS_Table1]\r\n///\r\nlParam --- This parameter is not used.', 'Data specific to the type of status to retrieve. With the EMSIS_COMPOSITIONSTRING value for status, this return value is one or more of the following values.\r\n\r\n[table:EM_GETIMESTATUS_Table2]', 'Rich Edit: The EM_GETIMESTATUS message is not supported.', 'EM_SETIMESTATUS', '2016-09-03 02:42:30', '2016-09-03 02:42:30', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb761580.aspx', '', '', '', '', ''),
('EM_SETIMESTATUS', 'message', 'Sets the status flags that determine how an edit control interacts with the Input Method Editor (IME).', 'EM_SETIMESTATUS', 'wParam --- The type of status to set. This parameter can be the following value.\r\n\r\n[table:EM_SETIMESTATUS_Table1]\r\n///\r\nlParam --- Data specific to the status type. If wParam is EMSIS_COMPOSITIONSTRING, this parameter can be one or more of the following values.\r\n\r\n[table:EM_SETIMESTATUS_Table2]', 'Returns the previous value of the lParam parameter.', 'Rich Edit: The EM_SETIMESTATUS message is not supported.', 'EM_GETIMESTATUS', '2016-09-03 02:45:43', '2016-09-03 02:45:43', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb761645.aspx', '', '', '', '', ''),
('End-User-Defined and Private Use Area Characters', '', 'End-user-defined characters (EUDC) in double-byte character sets (DBCSs) and private use area (PUA) characters in Unicode are custom characters. They can be defined and implemented either by an end user or by another party, such as an equipment manufacturer, a user group, a government body, or a font design company. Their use enables users to form names and other words using characters that are not available in standard screen and printer fonts.\r\n\r\nThe EUDC and PUA characters can be assigned differently, or not assigned at all, on different computers. Some code pages have extensions that reuse the EUDC range, and these extensions can conflict with each other. In other cases, a manufacturer might provide a custom set of characters in one of these ranges. Additionally, user groups can attempt to provide additional characters in the PUA. Different combinations of these cases can cause conflict. When creating applications that rely on EUDC or PUA characters, you should keep in mind the conflicting interpretations of an individual code point.\r\n\r\nThe following topics discuss the fonts that support EUDCs, and access and management for these characters:\r\n\r\n * Character Sets and Fonts \r\n * EUDC Registry Entries', '', '', '', '', '', '2016-09-22 03:38:05', '2016-09-22 03:38:05', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317802.aspx', '', '', '', '', ''),
('Enhanced Reconversion', '', 'Applications can set a target string that is different from the composition string. The target string (or part of the \r\ntarget string) is then included in a target clause in high priority by the IME. The target string in the \r\nRECONVERTSTRING structure must be part of the composition string. When the application does not want to \r\nchange the user’s focus during the reconversion, the target string should be specified. The IME can then reference \r\nit.', '', '', '', '', 'RECONVERTSTRING', '2016-09-10 09:04:04', '2016-09-10 09:04:04', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Extended-Key Flag', '', 'The extended-key flag indicates whether the keystroke message originated from one of the additional keys on the enhanced keyboard. The extended keys consist of the ALT and CTRL keys on the right-hand side of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; the NUM LOCK key; the BREAK (CTRL+PAUSE) key; the PRINT SCRN key; and the divide (/) and ENTER keys in the numeric keypad. The extended-key flag is set if the key is an extended key.', '', '', '', '', '', '2016-09-11 13:01:02', '2016-09-11 13:01:02', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('General Guidelines for Software Development Using Supplement', '', 'UTF-16 handles supplementary characters as surrogate pairs. The operating system processes a surrogate pair similarly to the way it processes nonspacing marks. At display time, the surrogate pair displays as one glyph by means of Uniscribe, as prescribed by the Unicode Standard.\r\n\r\nWindows Vista introduces three new macros to help identify surrogates and surrogate pairs in UTF-16 strings. These are IS_HIGH_SURROGATE, IS_LOW_SURROGATE, and IS_SURROGATE_PAIR.\r\n\r\nApplications automatically support supplementary characters if they support Unicode and use system controls and standard API functions, such as ExtTextOut and DrawText. Thus, if your application uses standard system controls or uses general ExtTextOut-type calls to display, supplementary characters should work without any special coding.\r\n\r\nApplications that implement their own editing support by working out glyph positions in a customized way can use Uniscribe for all text processing. Uniscribe has separate functions to deal with complex script processing, such as text display, hit testing, and cursor movement. An application must call the Uniscribe functions specifically to get these advanced features. Note that applications using the Uniscribe functions are fully multilingual, but this imposes a performance penalty. Thus some applications should do their own processing of supplementary characters.\r\n\r\nBecause the surrogate mechanism to represent supplementary characters is well-defined, your application can include code to handle UTF-16 surrogate text processing. When the application encounters a separated UTF-16 value from either the lower reserved surrogate range (a low surrogate) or the upper reserved surrogate range (a high surrogate), the value must be one half of a surrogate pair. Thus, the application can detect a surrogate pair by doing simple range checking. If it encounters a UTF-16 value in the lower or upper range, it must track backward or forward one 16-bit width to get the rest of the character. When writing your application, keep in mind that CharNext and CharPrev move by 16-bit code points, not by surrogate pairs.\r\n\r\nNote: Standalone surrogate code points have either a high surrogate without an adjacent low surrogate, or vice versa. These code points are invalid and are not supported. Their behavior is undefined.\r\n\r\nIf you are developing a font or IME provider, note that pre-Windows XP operating systems disable supplementary character support by default. Windows XP and later enable supplementary characters by default. If you provide a font and IME package that requires supplementary characters, your application must set the following registry values:\r\n\r\n<pre>[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\LanguagePack]\r\nSURROGATE=(REG_DWORD)0x00000002\r\n \r\n[HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\International\\Scripts\\42]\r\nIEFixedFontName=[Surrogate Font Face Name]\r\nIEPropFontName=[Surrogate Font Face Name]</pre>', '', '', '', '', '', '2016-09-17 07:00:06', '2016-09-17 07:00:06', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069.aspx', '', '', '', '', ''),
('Generating Messages', '', 'IMEs need to generate IME messages. When an IME initiates the conversion process, the IME has to generate a WM_IME_STARTCOMPOSITION message. If the IME changes the composition string, the IME has to generate a WM_IME_COMPOSITION message.\r\n\r\nThere are two ways an IME can generate a message: one is by using the lpdwTransKey buffer provided by ImeToAsciiEx, and the other is by calling ImmGenerateMessage.\r\n\r\n * Using lpTransMsgList to Generate Messages\r\n * Using the Message Buffer to Generate Messages', '', '', '', '', 'Using lpTransMsgList to Generate Messages|Using the Message Buffer to Generate Messages|WM_IME_STARTCOMPOSITION|WM_IME_COMPOSITION|ImeToAsciiEx|ImmGenerateMessage', '2016-09-10 08:53:27', '2016-09-10 08:53:27', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('GetActiveWindow', 'function', 'Retrieves the window handle to the active window attached to the calling thread\'s message queue.', 'HWND WINAPI GetActiveWindow(void);', 'This function has no parameters.', 'The return value is the handle to the active window attached to the calling thread\'s message queue. Otherwise, the return value is NULL.', 'To get the handle to the foreground window, you can use GetForegroundWindow. \r\n\r\nTo get the window handle to the active window in the message queue for another thread, use GetGUIThreadInfo.', 'GetForegroundWindow|GetGUIThreadInfo|SetActiveWindow', '2016-09-11 03:23:02', '2016-09-11 03:23:02', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646292.aspx', '', '', '', '', ''),
('GetFocus', 'function', 'Retrieves the handle to the window that has the keyboard focus, if the window is attached to the calling thread\'s message queue.', 'HWND WINAPI GetFocus(void);', 'This function has no parameters.', 'The return value is the handle to the window with the keyboard focus. If the calling thread\'s message queue does not have an associated window with the keyboard focus, the return value is NULL.', 'GetFocus returns the window with the keyboard focus for the current thread\'s message queue. If GetFocus returns NULL, another thread\'s queue may be attached to a window that has the keyboard focus.\r\n\r\nUse the GetForegroundWindow function to retrieve the handle to the window with which the user is currently working. You can associate your thread\'s message queue with the windows owned by another thread by using the AttachThreadInput function.\r\n\r\nTo get the window with the keyboard focus on the foreground queue or the queue of another thread, use the GetGUIThreadInfo function.', 'GetForegroundWindow|GetGUIThreadInfo|SetFocus|WM_KILLFOCUS|WM_SETFOCUS', '2016-09-11 03:25:05', '2016-09-11 03:25:05', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646294.aspx', '', '', '', '', ''),
('GetKeyboardLayout', 'function', 'Retrieves the active input locale identifier (formerly called the keyboard layout).', 'HKL WINAPI GetKeyboardLayout(\r\n  _In_ DWORD idThread\r\n);', 'idThread [in] Type: DWORD --- The identifier of the thread to query, or 0 for the current thread.', 'The return value is the input locale identifier for the thread. The low word contains a Language Identifier for the input language and the high word contains a device handle to the physical layout of the keyboard.', 'The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.\r\n\r\nSince the keyboard layout can be dynamically changed, applications that cache information about the current keyboard layout should process the WM_INPUTLANGCHANGE message to be informed of changes in the input language.\r\n\r\nTo get the KLID (keyboard layout ID) of the currently active HKL, call the GetKeyboardLayoutName. \r\n\r\nBeginning in Windows 8: The preferred method to retrieve the language associated with the current keyboard layout or input method is a call to Windows.Globalization.Language.CurrentInputMethodLanguageTag. If your app passes language tags from CurrentInputMethodLanguageTag to any National Language Support functions, it must first convert the tags by calling ResolveLocaleName.', 'ActivateKeyboardLayout|LoadKeyboardLayout|WM_INPUTLANGCHANGE', '2016-09-11 03:26:53', '2016-09-11 03:26:53', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646296.aspx', '', '', '', '', ''),
('GetKeyboardLayoutList', 'function', 'Retrieves the input locale identifiers (formerly called keyboard layout handles) corresponding to the current set of input locales in the system. The function copies the identifiers to the specified buffer.', 'int WINAPI GetKeyboardLayoutList(\r\n  _In_  int nBuff,\r\n  _Out_ HKL *lpList\r\n);', 'nBuff [in] Type: int --- The maximum number of handles that the buffer can hold.\r\n///\r\nlpList [out] Type: HKL* --- A pointer to the buffer that receives the array of input locale identifiers.', 'If the function succeeds, the return value is the number of input locale identifiers copied to the buffer or, if nBuff is zero, the return value is the size, in array elements, of the buffer needed to receive all current input locale identifiers.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError.', 'The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.\r\n\r\nBeginning in Windows 8: The preferred method to retrieve the language associated with the current keyboard layout or input method is a call to Windows.Globalization.Language.CurrentInputMethodLanguageTag. If your app passes language tags from CurrentInputMethodLanguageTag to any National Language Support functions, it must first convert the tags by calling ResolveLocaleName.', 'GetKeyboardLayout', '2016-09-11 03:28:42', '2016-09-11 03:28:42', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646297.aspx', '', '', '', '', ''),
('GetKeyboardLayoutName', 'function', 'Retrieves the name of the active input locale identifier (formerly called the keyboard layout) for the system.', 'BOOL WINAPI GetKeyboardLayoutName(\r\n  _Out_ LPTSTR pwszKLID\r\n);', 'pwszKLID [out] Type: LPTSTR --- The buffer (of at least KL_NAMELENGTH characters in length) that receives the name of the input locale identifier, including the terminating null character. This will be a copy of the string provided to the LoadKeyboardLayout function, unless layout substitution took place.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError.', 'The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.\r\n\r\nBeginning in Windows 8: The preferred method to retrieve the language associated with the current keyboard layout or input method is a call to Windows.Globalization.Language.CurrentInputMethodLanguageTag. If your app passes language tags from CurrentInputMethodLanguageTag to any National Language Support functions, it must first convert the tags by calling ResolveLocaleName.', 'ActivateKeyboardLayout|LoadKeyboardLayout|UnloadKeyboardLayout', '2016-09-11 03:30:12', '2016-09-11 03:30:12', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646298.aspx', '', '', '', '', ''),
('GetKeyState', 'function', 'Retrieves the status of the specified virtual key. The status specifies whether the key is up, down, or toggled (on, off—alternating each time the key is pressed).', 'SHORT WINAPI GetKeyState(\r\n  _In_ int nVirtKey\r\n);', 'nVirtKey [in] Type: int --- A virtual key. If the desired virtual key is a letter or digit (A through Z, a through z, or 0 through 9), nVirtKey must be set to the ASCII value of that character. For other keys, it must be a virtual-key code. \r\n\r\nIf a non-English keyboard layout is used, virtual keys with values in the range ASCII A through Z and 0 through 9 are used to specify most of the character keys. For example, for the German keyboard layout, the virtual key of value ASCII O (0x4F) refers to the \"o\" key, whereas VK_OEM_1 refers to the \"o with umlaut\" key.', 'The return value specifies the status of the specified virtual key, as follows: \r\n\r\n * If the high-order bit is 1, the key is down; otherwise, it is up.\r\n * If the low-order bit is 1, the key is toggled. A key, such as the CAPS LOCK key, is toggled if it is turned on. The key is off and untoggled if the low-order bit is 0. A toggle key\'s indicator light (if any) on the keyboard will be on when the key is toggled, and off when the key is untoggled.', 'The key status returned from this function changes as a thread reads key messages from its message queue. The status does not reflect the interrupt-level state associated with the hardware. Use the GetAsyncKeyState function to retrieve that information.\r\n\r\nAn application calls GetKeyState in response to a keyboard-input message. This function retrieves the state of the key when the input message was generated. \r\n\r\nTo retrieve state information for all the virtual keys, use the GetKeyboardState function. \r\n\r\nAn application can use the virtual key code constants VK_SHIFT, VK_CONTROL, and VK_MENU as values for the nVirtKey parameter. This gives the status of the SHIFT, CTRL, or ALT keys without distinguishing between left and right. An application can also use the following virtual-key code constants as values for nVirtKey to distinguish between the left and right instances of those keys:\r\n\r\n * VK_LSHIFT\r\n * VK_RSHIFT\r\n * VK_LCONTROL\r\n * VK_RCONTROL\r\n * VK_LMENU\r\n * VK_RMENU\r\n\r\nThese left- and right-distinguishing constants are available to an application only through the GetKeyboardState, SetKeyboardState, GetAsyncKeyState, GetKeyState, and MapVirtualKey functions.', 'GetAsyncKeyState|GetKeyboardState|MapVirtualKey|SetKeyboardState', '2016-09-11 03:32:47', '2016-09-11 03:32:47', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646301.aspx', '', '', '', '', ''),
('GUIDELINE', 'structure', 'Contains the guideline information that the IME sends out.', 'typedef struct {\r\n    DWORD dwSize;\r\n    DWORD dwLevel;      // the error level.\r\n        // GL_LEVEL_NOGUIDELINE,\r\n        // GL_LEVEL_FATAL,\r\n        // GL_LEVEL_ERROR,\r\n        // GL_LEVEL_WARNNING,\r\n        // GL_LEVEL_INFORMATION\r\n    DWORD dwIndex;      // GL_ID_NODICTIONARY and so on.\r\n    DWORD dwStrLen;     // Error Strings, if this is 0, there\r\n                        // is no error string.\r\n    DWORD dwStrOffset;\r\n    DWORD dwPrivateSize;\r\n    DWORD dwPrivateOffset;\r\n} GUIDELINE;', 'dwLevel --- The dwLevel specifies error level. The following values are provided.\r\n\r\n[table:GUIDELINE_Table1]\r\n///\r\ndwIndex --- The following values are provided.\r\n\r\n[table:GUIDELINE_Table2]\r\n///\r\ndwPrivateSize --- Private area in this memory block.\r\n///\r\ndwPrivateOffset --- Offset from the start position of this structure. The private area is stored here.', '', 'For Unicode, the dwStrLen member specifies the size in Unicode characters of the error string. Other size \r\nparameters such as dwSize dwStrOffset, dwPrivateSize contain values counted in bytes.', '', '2016-09-10 03:49:56', '2016-09-10 03:49:56', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Hot-Key Support', '', 'A hot key is a key combination that generates a WM_HOTKEY message, a message the system places at the top of a thread\'s message queue, bypassing any existing messages in the queue. Applications use hot keys to obtain high-priority keyboard input from the user. For example, by defining a hot key consisting of the CTRL+C key combination, an application can allow the user to cancel a lengthy operation.\r\n\r\nTo define a hot key, an application calls the RegisterHotKey function, specifying the combination of keys that generates the WM_HOTKEY message, the handle to the window to receive the message, and the identifier of the hot key. When the user presses the hot key, a WM_HOTKEY message is placed in the message queue of the thread that created the window. The wParam parameter of the message contains the identifier of the hot key. The application can define multiple hot keys for a thread, but each hot key in the thread must have a unique identifier. Before the application terminates, it should use the UnregisterHotKey function to destroy the hot key.\r\nApplications can use a hot key control to make it easy for the user to choose a hot key. Hot key controls are typically used to define a hot key that activates a window; they do not use the RegisterHotKey and UnregisterHotKey functions. Instead, an application that uses a hot key control typically sends the WM_SETHOTKEY message to set the hot key. Whenever the user presses the hot key, the system sends a WM_SYSCOMMAND message specifying SC_HOTKEY. For more information about hot key controls, see \"Using Hot Key Controls\" in Hot Key Controls.', '', '', '', '', '', '2016-09-11 13:07:30', '2016-09-11 13:07:30', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('IMC_CLOSESTATUSWINDOW', 'command', 'Instructs the IME window to hide the status window. To send this command, the application uses the WM_IME_CONTROL message with the parameter settings shown below.', 'LRESULT IMC_CLOSESTATUSWINDOW', 'wParam --- Set to IMC_CLOSESTATUSWINDOW.\r\n///\r\nlParam --- Not used.', 'Returns 0 if successful, or a nonzero value otherwise.', 'When the IME status window is already hidden, this command does nothing. Although an application can send this command to the IME window, the application does not receive the corresponding IMN_CLOSESTATUSWINDOW command.', 'WM_IME_CONTROL|IMN_CLOSESTATUSWINDOW', '2016-08-25 04:22:44', '2016-08-25 04:22:44', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318152.aspx', '', '', '', '', ''),
('IMC_GETCANDIDATEPOS', 'command', 'Instructs an IME window to get the position of the candidate window. To send this command, the application uses the WM_IME_CONTROL message with the parameter settings shown below.', 'LRESULT IMC_GETCANDIDATEPOS', 'wParam --- Set to IMC_GETCANDIDATEPOS.\r\n///\r\nlParam --- Pointer to a CANDIDATEFORM structure that contains the position of the candidate window.', 'Returns 0 if successful, or a nonzero value otherwise.', 'Because the IME might adjust the position of a candidate window, an application uses this command to get the actual position to decide whether to reposition the window. The retrieved position is in window coordinates relative to the window having the current input focus.', 'WM_IME_CONTROL|CANDIDATEFORM|IMC_SETCANDIDATEPOS', '2016-08-25 04:23:37', '2016-08-25 04:23:37', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318153.aspx', '', '', '', '', ''),
('IMC_GETCOMPOSITIONFONT', 'command', 'Instructs an IME window to retrieve the logical font used for displaying intermediate characters in the composition window. To send this command, the application uses the WM_IME_CONTROL message with the parameter settings shown below.', 'LRESULT IMC_GETCOMPOSITIONFONT', 'wParam --- Set to IMC_GETCOMPOSITIONFONT.\r\n///\r\nlParam --- Pointer to a LOGFONT structure that receives information about the logical font.', 'Returns 0 if successful, or a nonzero value otherwise.', '', 'WM_IME_CONTROL|IMC_SETCOMPOSITIONFONT', '2016-08-25 04:24:39', '2016-08-25 04:24:39', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318154.aspx', '', '', '', '', ''),
('IMC_GETCOMPOSITIONWINDOW', 'command', 'Instructs an IME window to get the position of the composition window. To send this command, the application uses the WM_IME_CONTROL message with the parameter settings shown below.', 'LRESULT IMC_GETCOMPOSITIONWINDOW', 'wParam --- Set to IMC_GETCOMPOSITIONWINDOW.\r\n///\r\nlParam --- Pointer to a COMPOSITIONFORM structure that contains the position of the composition window.', 'Returns 0 if successful, or a nonzero value otherwise.', 'Because the IME might adjust the position of a composition window, an application uses this command to get the actual position to decide whether to reposition the window. The retrieved position is in window coordinates relative to the window having the current input focus.', 'WM_IME_CONTROL|IMC_SETCOMPOSITIONWINDOW|COMPOSITIONFORM', '2016-08-25 04:25:38', '2016-08-25 04:25:38', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318155.aspx', '', '', '', '', ''),
('IMC_GETSTATUSWINDOWPOS', 'command', 'Instructs an IME window to get the position of the status window. To send this command, the application uses the WM_IME_CONTROL message with the parameter settings shown below.', 'LRESULT IMC_GETSTATUSWINDOWPOS', 'wParam --- Set to IMC_GETSTATUSWINDOWPOS.\r\n///\r\nlParam --- Not used.', 'Returns a POINTS structure that contains the x coordinate and y coordinate of the status window position in screen coordinates, relative to the upper left corner of the screen.', '', 'WM_IME_CONTROL|IMC_SETSTATUSWINDOWPOS', '2016-08-25 04:26:28', '2016-08-25 04:26:28', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318156.aspx', '', '', '', '', ''),
('IMC_OPENSTATUSWINDOW', 'command', 'Instructs the IME window to show the status window. To send this command, the application uses the WM_IME_CONTROL message with the parameter settings shown below.', 'LRESULT IMC_OPENSTATUSWINDOW', 'wParam --- Set to IMC_OPENSTATUSWINDOW.\r\n///\r\nlParam --- Not used.', 'Returns 0 if successful, or a nonzero value otherwise.', 'This command is ignored if the operating system is not in the show IME status mode. The user can set or clear the show IME status mode from the task bar.\r\n\r\nIf the status window is already shown, this command does nothing. Although the application can send this command to the IME window, the application does not receive the corresponding IMN_OPENSTATUSWINDOW command.', 'WM_IME_CONTROL|IMC_CLOSESTATUSWINDOW|IMN_OPENSTATUSWINDOW', '2016-08-25 04:27:25', '2016-08-25 04:27:25', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318157.aspx', '', '', '', '', ''),
('IMC_SETCANDIDATEPOS', 'command', 'Instructs an IME window to set the position of the candidates window. To send this command, the application uses the WM_IME_CONTROL message with the parameter settings shown below.', 'LRESULT IMC_SETCANDIDATEPOS', 'wParam --- Set to IMC_SETCANDIDATEPOS.\r\n///\r\nlParam --- Pointer to a CANDIDATEFORM structure that contains the x coordinate and y coordinate for the candidates window. The application should set the dwIndex member of this structure.', 'Returns 0 if successful, or a nonzero value otherwise.', 'This command is intended for applications that display composition characters on their own but use the IME window to display candidates.', 'WM_IME_CONTROL|IMC_GETCANDIDATEPOS|CANDIDATEFORM', '2016-08-25 04:28:20', '2016-08-25 04:28:20', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318158.aspx', '', '', '', '', ''),
('IMC_SETCOMPOSITIONFONT', 'command', 'Instructs an IME window to specify the logical font to use for displaying intermediate characters in the composition window. To send this command, the application uses the WM_IME_CONTROL message with the parameter settings shown below.', 'LRESULT IMC_SETCOMPOSITIONFONT', 'wParam --- Set to IMC_SETCOMPOSITIONFONT.\r\n///\r\nlParam --- Pointer to a LOGFONT structure that contains information about the logical font.', 'Returns 0 if successful, or a nonzero value otherwise.', 'When processing this command, the IME window changes the current selected font in the input context.', 'WM_IME_CONTROL|IMC_GETCOMPOSITIONFONT', '2016-08-25 04:29:43', '2016-08-25 04:29:43', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318159.aspx', '', '', '', '', ''),
('IMC_SETCOMPOSITIONWINDOW', 'command', 'Instructs an IME window to set the style of the composition window. To send this command, the application uses the WM_IME_CONTROL message with the parameter settings shown below.', 'LRESULT IMC_SETCOMPOSITIONWINDOW', 'wParam --- Set to IMC_SETCOMPOSITIONWINDOW.\r\n///\r\nlParam --- Pointer to a COMPOSITIONFORM structure that contains the style information.', 'Returns 0 if successful, or a nonzero value otherwise.', 'This command sets the style in the current input context, and the style is subsequently applied to each IME window that receives that input context.\r\n\r\nBy default, the IME window has the CFS_POINT style. With this style, the IME window uses the current caret position and window client area when it opens any composition window.', 'WM_IME_CONTROL|IMC_GETCOMPOSITIONWINDOW|COMPOSITIONFORM', '2016-08-25 04:30:41', '2016-08-25 04:30:41', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318160.aspx', '', '', '', '', ''),
('IMC_SETSTATUSWINDOWPOS', 'command', 'Instructs an IME window to set the position of the status window. To send this command, the application uses the WM_IME_CONTROL message with parameter settings as shown below.', 'LRESULT IMC_SETSTATUSWINDOWPOS', 'wParam --- Set to IMC_SETSTATUSWINDOWPOS.\r\n///\r\nlParam --- Pointer to a POINTS structure that contains the x coordinate and y coordinate of the position of the status window. The coordinates are in screen coordinates, relative to the upper left corner of the display.', 'Returns 0 if successful, or a nonzero value otherwise.', '', 'WM_IME_CONTROL|IMC_GETSTATUSWINDOWPOS', '2016-08-25 04:31:30', '2016-08-25 04:31:30', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318161.aspx', '', '', '', '', ''),
('IME and Localized Language Compatibility', '', 'Windows 2000 has full-featured IME support in any localized language version. That is, an IME can be installed and used with any Windows 2000 language. IME developers should test their IME on these environments. This new feature also requires IME developers to prepare their IME help content to include correct charset and font information so it shows up correctly on different language operating systems.\r\n\r\nAlso, IME developers should develop Unicode IME for Windows 2000. Unicode IMEs will work with Unicode applications under any system locale. For non-Unicode IMEs, the user must change the system locale to support the same language that the IME supports in order to use them.', '', '', '', '', '', '2016-09-10 09:30:19', '2016-09-10 09:30:19', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('IME Aware Applications', '', 'One of the main advantages of the new Win32 IME architecture is that it provides better communication logic between the application and the IME. Following is an example of how an application could be involved with the IME: \r\n\r\n * IME Unaware Applications. These kinds of applications never intend to control the IME. However, as long as it accepts DBCS characters, a user can type any DBCS character to the application using IME.\r\n * IME Half-aware Applications. These kinds of applications typically control the various contexts of the IME, such as open and close, and composition form, but it does not display any user interface for the IME. \r\n * IME Full-aware Applications. These kinds of applications typically want to be fully responsible for displaying any information given by the IME. \r\n \r\nIn Windows 95 and Windows NT 4.0 or later, one IME unaware application will be supported with one Default IME window and one Default Input Context.  \r\n\r\nAn IME half-aware application will create its own IME window(s), also called an application IME window, using a predefined system IME class, and may or may not handle its own Input Context given to the application. \r\n\r\nAn IME fully aware application will handle the Input Context by itself and will display any necessary information given by the Input Context not using the IME window.', '', '', '', '', '', '2016-09-10 08:30:20', '2016-09-10 08:30:20', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('IME Cancel Reconversion', '', 'When a user cancels the composition string generated by the reconversion, the IME should determine the original \r\nreconverted string. Otherwise, the application will loose the string.', '', '', '', '', 'RECONVERTSTRING', '2016-09-10 09:04:54', '2016-09-10 09:04:54', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('IME Class', '', 'The Win32 systems provides an IME class in the system. This class is defined by the user just as the predefined \r\nEdit class is. The system IME class handles the entire UI of the IME and handles entire control messages from the \r\nIME and application, including IMM functions. An application can create its own IME User Interface by using this \r\nclass. The system IME class, itself, is not replaced by any IME, but is kept as a predefined class.\r\n\r\nThis class has a window procedure that actually handles the WM_IME_SELECT message. This message has the \r\nhKL of the newly selected IME. The system IME class retrieves the name of the class defined by each IME with \r\nthis hKL. Using this name, the system IME class creates a UI window of the currently active IME.', '', '', '', '', 'WM_IME_SELECT', '2016-09-10 08:35:08', '2016-09-10 08:35:08', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('IME Composition String Values', '', 'These values are used with ImmGetCompositionString and WM_IME_COMPOSITION.\r\n\r\n[table:IME Composition String Values_Table1]', '', '', '', '', 'ImmGetCompositionString|WM_IME_COMPOSITION', '2016-09-03 01:32:06', '2016-09-03 01:32:06', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318164.aspx', '', '', '', '', ''),
('IME Conversion Mode Values', '', 'These values are used with the ImmGetConversionStatus and ImmSetConversionStatus functions.\r\n\r\n[table:IME Conversion Mode Values_Table1]\r\n\r\nAll other bits are reserved.', '', '', '', '', 'ImmGetConversionStatus|ImmSetConversionStatus', '2016-09-03 01:35:22', '2016-09-03 01:35:22', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318165.aspx', '', '', '', '', ''),
('IME Escapes', '', 'These escapes are used with the ImmEscape function.\r\n\r\n[table:IME Escapes_Table1]\r\n\r\nThe operating system reserves the escapes in the range IME_ESC_RESERVED_FIRST to IME_ESC_RESERVED_LAST for its own use.\r\n\r\nThe operating system reserves the escapes in the range IME_ESC_PRIVATE_FIRST to IME_ESC_PRIVATE_LAST for private use by IMEs.', '', '', '', '', 'ImmEscape', '2016-09-03 01:38:36', '2016-09-03 01:38:36', '', '', 'https://technet.microsoft.com/en-us/library/security/dd318166.aspx', '', '', '', '', ''),
('IME File Format', '', 'An IME needs to specify the following fields correctly in the version information resource. This includes the fixed file information part and the variable length information part. Please refer to the Microsoft Platform SDK for detailed information on version information resource.\r\n\r\nFollowing are the specific settings the IME file should include: \r\n\r\n[table:IME File Format_Table1]', '', '', '', '', '', '2016-09-10 09:21:29', '2016-09-10 09:21:29', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('IME Help File', '', 'The IME help file is a new function added into Windows 98 and Windows NT. The right click menu of the System Pen Icon has two menu items. One is the setting for the IME system and is used to change the setting of the selected IME of the focus thread. The other menu item is an online Help file that has never been enabled. Thus, this menu item is always grayed. The purpose of this menu item was to display an IME’s online Help. However, because the system does not provide the IME with a way to specify the name of the IME help file, the system task bar program is not able to display it.', '', '', '', '', 'ImeEscape', '2016-09-10 09:08:21', '2016-09-10 09:08:21', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('IME Hot Key Identifiers', '', 'These identifiers are used with the ImmSimulateHotKey function.\r\n\r\n[table:IME Hot Key Identifiers_Table1]', '', '', '', '', 'ImmSimulateHotKey', '2016-09-03 01:43:34', '2016-09-03 01:43:34', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318167.aspx', '', '', '', '', ''),
('IME Input Context', '', 'Each window is associated with an IME Input Context. The IMM uses the Input Context to maintain IME status, data, and so forth, and communicate with the IME and with applications.\r\n\r\n * Default Input Context\r\n * Application-Created Input Context', '', '', '', '', 'Default Input Context|Application-Created Input Context', '2016-09-10 08:45:49', '2016-09-10 08:45:49', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('IME Menu Functions', '', 'The purpose of this function set is to reduce the IME-related icon in the system task bar. It is a new feature for Windows 98 and Windows 2000.\r\n\r\nThe Windows system program installs two icons in the task bar when the current hKL is an IME. One icon is the System ML icon that indicates the current keyboard layout in the system task bar. The other is the System Pen icon that shows the IME status of the focused window. Usually, an IME places an additional icon in the task bar. The context menu for this icon is completely dependent on the IME. Having IME icons in a task bar is a quick way for a user to access an IME’s special functions. However, there are three icons associated with the IME and these additional icons may be more than a user wants to deal with.\r\n\r\nIf the system provides a way for an IME to insert IME menu items into the System Pen icon, the IME then does not need to add its extra icons to the task bar.\r\n\r\nThe IMM calls the IME function ImeGetImeMenuItems to get the IME menu items.\r\n\r\nAn application can use ImmGetImeMenuItems to get an IME’s special menu items, which it can add to its context \r\nmenu. By calling ImmNotifyIME, the selected items can be processed by the IME.', '', '', '', '', 'ImmGetImeMenuItems|ImmNotifyIME', '2016-09-10 09:06:34', '2016-09-10 09:06:34', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('IME Menu Notification', '', 'When an application wants to handle an IME’s menu items, it can call ImmNotifyIME. When the menu items \r\nadded by the IME are selected, NotifyIME is called under the focused thread.', '', '', '', '', 'ImmNotifyIME|NotifyIME', '2016-09-10 09:07:30', '2016-09-10 09:07:30', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('IME Sentence Mode Values', '', 'These values are used with the ImmGetConversionStatus and ImmSetConversionStatus functions.\r\n\r\n[table:IME Sentence Mode Values_Table1]\r\n\r\nBits 16 through 31 are reserved for IME use.', '', '', '', '', 'ImmGetConversionStatus|ImmSetConversionStatus', '2016-09-03 01:41:45', '2016-09-03 01:41:45', '', '', 'https://msdn.microsoft.com/en-us/library/dd318169.aspx', '', '', '', '', ''),
('IME User Interface', '', 'The IME User Interface includes the IME window, the UI window, and the components of the UI window.\r\n\r\nAn IME class is a predefined global class that carries out any user interface portion of the IME. The normal \r\ncharacteristics of an IME class are the same as with other common controls. Its window instance can be created \r\nby CreateWindowEx. As with static controls, the IME class window does not respond to user input by itself, but \r\nreceives various types of control messages to realize the entire user interface of the IME. An application can \r\ncreate its own IME window(s) by using this IME class or by obtaining the Default IME window through \r\nImmGetDefaultIMEWnd. In comparison to Windows 3.1, an application that wants to control the IME with these \r\nwindow handles (an IME-aware application) can now achieve the following benefits:\r\n\r\n * The new IME includes candidates listing windows. Each application can have its own window instance of the UI so a user can stop in the middle of any operation to switch to another application. In the Windows 3.1 Japanese Edition, the user had to first exit an operation before switching to another application. \r\n * Since the IME User Interface window is informed about an application’s window handle, it can provide several default behaviors for the application. For example, this can include automatic repositioning of the IME window, automatic tracing of the window caret position, and mode indication for each application.\r\n\r\nEven though the system provides only one IME class, there are two kinds of IME window. One is created by the \r\nsystem for the DefWindowProc function especially for an IME unaware program. The IME User Interface for the \r\nDefWindowProc function is shared by all IME unaware windows of a thread and is called the default IME window \r\nin this documentation. The other windows are created by IME aware applications and are called the application \r\nIME window.', '', '', '', '', 'ImmGetDefaultIMEWnd|DefWindowProc', '2016-09-10 08:32:34', '2016-09-10 08:32:34', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('ImeConfigure', 'function', 'The ImeConfigure function provides a dialog box to use to request optional information for an IME.', 'BOOL WINAPI ImeConfigure( \r\n    HKL hKL, \r\n    HWND hWnd, \r\n    DWORD dwMode, \r\n    LPVOID lpData)', 'hKL --- Input language handle of this IME. \r\n///\r\nhWnd --- Parent window handle. \r\n///\r\ndwMode --- Mode of dialog. The following flags are provided.\r\n\r\n[table:ImeConfigure_Table1]\r\n///\r\nlpData --- Pointer to VOID, which will be a pointer to the REGISTERWORD structure only if \r\ndwMode==IME_CONFIG_REGISTERWORD. Otherwise, lpData should just be ignored. \r\nThis also can be NULL with the IME_CONFIG_REGISTER mode, if no initial string information is given.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', 'An IME checks lpData in the following way in the pseudo code. \r\n\r\n<pre>if (dwmode != IME_CONFIG_REGISTERWORD)\r\n{\r\n    // Does original execution\r\n}\r\nelse if (IsBadReadPtr(lpdata, sizeof(REGISTERWORD))==FALSE)\r\n{\r\n    if (IsBadStringPtr(PREGISTERWORD(lpdata)->lpReading, (UINT)-1)==FALSE)\r\n    {\r\n        // Set the reading string to word registering dialogbox\r\n    }\r\n    if (IsBadStringPtr(PREGISTERWORD(lpdata)->lpWord, (UINT)-1)==FALSE)\r\n    {\r\n        // Set the word string to word registering dialogbox\r\n    }\r\n}</pre>', 'REGISTERWORD', '2016-08-29 05:10:10', '2016-08-29 05:10:10', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeConversionList', 'function', 'The ImeConversionList function obtains a converted result list from another character or string.', 'DWORD WINAPI ImeConversionList( \r\n    HIMC hIMC, \r\n    LPCTSTRlpSrc, \r\n    LPCANDIDATELIST lpDst, \r\n    DWORD dwBufLen, \r\n    UINT uFlag)', 'hIMC --- Input context handle. \r\n///\r\nlpSrc --- Character string to be converted. \r\n///\r\nlpDst --- Pointer to the destination buffer. \r\n///\r\ndwBufLen --- Length of the destination buffer. \r\n///\r\nuFlag --- Currently can be one of the following three flags.\r\n\r\n[table:ImeConversionList_Table1]', 'The return value is the number of bytes of the result string list.', 'This function is intended to be called by an application or an IME without generating IME-related messages. \r\nTherefore, an IME should not generate any IME-related messages in this function.', '', '2016-08-29 05:06:54', '2016-08-29 05:06:54', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeDestroy', 'function', 'The ImeDestroy function terminates the IME itself.', 'BOOL WINAPI ImeDestroy( \r\n    UINT uReserved)', 'uReserved --- Reserved. Currently, it should be zero. For this version, the IME should return FALSE if it is not zero.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'ImeInquire', '2016-08-29 05:11:37', '2016-08-29 05:11:37', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeEnumRegisterWord', 'function', 'The ImeEnumRegisterWord function enumerates the information of the registered strings with specified reading \r\nstring, style, and registered string data.', 'UINT WINAPI ImeEnumRegisterWord( \r\n    HKL hKL, \r\n    REGISTERWORDENUMPROC lpfnEnumProc, \r\n    LPCTSTR lpszReading, \r\n    DWORD dwStyle, \r\n    LPCTSTR lpszString, \r\n    LPVOID lpData)', 'hKL --- Input language handle. \r\n///\r\nlpfnEnumProc --- Address of callback function. \r\n///\r\nlpszReading --- Specifies the reading string to be enumerated. If lpszReading is NULL, ImeEnumRegisterWord enumerates all \r\navailable reading strings that match the specified dwStyle and lpszString parameters. \r\n///\r\ndwStyle --- Specifies the style to be enumerated. If dwStyle is NULL, ImeEnumRegisterWord enumerates all available styles that match the specified lpszReading and lpszString parameters. \r\n///\r\nlpszString --- Specifies the registered string to be enumerated. If lpszString is NULL, ImeEnumRegisterWord enumerates all registered strings that match the specified lpszReading and dwStyle parameters. \r\n///\r\nlpData --- Address of application-supplied data.', 'If the function is successful, the return value is the last value returned by the callback function. Its meaning is \r\ndefined by the application.', 'If all lpszReading dwStyle, and lpszString parameters are NULL, ImeEnumRegisterWord enumerates all \r\nregistered strings in the IME dictionary. If any two of the input parameters are NULL, ImeEnumRegisterWord \r\nenumerates all registered strings matching the third parameter.', '', '2016-08-29 05:41:09', '2016-08-29 05:41:09', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeEscape', 'function', 'The ImeEscape function allows an application to access capabilities of a particular IME not directly available \r\nthough other IMM functions. This is necessary mainly for country-specific functions or private functions in the IME.', 'LRESULT WINAPI ImeEscape( \r\n    HIMC hIMC, \r\n    UINT uEscape, \r\n    LPVOID lpData)', 'hIMC --- Input context handle.\r\n///\r\nuEscape --- Specifies the escape function to be performed. \r\n///\r\nlpData --- Points to the data required for the specified escape. \r\n\r\nThe ImeEscape function supports the following escape functions.\r\n\r\n[table:ImeEscape_Table1]', 'If the function fails, the return value is zero. Otherwise, the return value depends on each escape function.', 'Parameter validation should be inside each escape function for robustness. \r\n\r\nWhen uEscape is IME_ESC_QUERY _SUPPORT, lpData is the pointer to the variable that contains the IME \r\nescape value. Following is an example that can be used to determine if the current IME supports \r\nIME_ESC_GETHELPFILENAME. \r\n\r\n<pre>DWORD dwEsc = IME_ESC_GETHELPFILENAME; \r\nLRESULT lRet = ImmEscape(hKL, hIMC, IME_ESC_QUERYSUPPORT, (LPVOID)&dwEsc);</pre>', '', '2016-08-29 05:13:21', '2016-08-29 05:13:21', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeGetImeMenuItems', 'function', 'The ImeGetImeMenuItems function gets the menu items that are registered in the IME menu.', 'DWORD WINAPI ImeGetImeMenuItems( \r\n    HIMC hIMC, \r\n    DWORD dwFlags, \r\n    DWORD dwType, \r\n    LPIMEMENUITEMINFO lpImeParentMenu, \r\n    LPIMEMENUITEMINFO lpImeMenu, \r\n    DWORD dwSize)', 'hIMC --- The lpMenuItem contains menu items that are related to this input context. \r\n///\r\ndwFlags --- Consists of the following bit combinations.\r\n\r\n[table:ImeGetImeMenuItems_Table1]\r\n///\r\ndwType --- Consists of the following bit combinations.\r\n\r\n[table:ImeGetImeMenuItems_Table2]\r\n///\r\nlpImeParentMenu  --- Pointer to the IMEMENUINFO structure that has MFT_SUBMENU in fType. ImeGetImeMenuItems returns the submenu items of this menu item. If this is NULL, lpImeMenu contains the top-level IME menu items.\r\n///\r\nlpImeMenu --- Pointer to the buffer to receive the contents of the menu items. This buffer is the array of IMEMENUITEMINFO structure. If this is NULL, ImeGetImeMenuItems returns the number of the registered menu items. \r\n///\r\ndwSize  --- Size of the buffer to receive the IMEMENUITEMINFO structure.', 'The return value is the number of the menu items that were set into lpIM. If lpImeMenu is NULL, \r\nImeGetImeMenuItems returns the number of menu items that are registered in the specified hKL.', 'ImeGetImeMenuItems is a new function for Windows 98 and Windows 2000.', 'IMEMENUITEMINFO', '2016-08-29 05:42:56', '2016-08-29 05:42:56', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeGetRegisterWordStyle', 'function', 'The ImeGetRegisterWordStyle function gets the available styles in this IME.', 'UINT WINAPI ImeGetRegisterWordStyle( \r\n    UINT nItem, \r\n    LPSTYLEBUF lpStyleBuf)', 'nItem --- Maximum number of styles that the buffer can hold.\r\n///\r\nlpStyleBuf --- Buffer to be filled.', 'The return value is the number of the styles copied to the buffer. If nItems is zero, the return value is the buffer size \r\nin array elements needed to receive all available styles in this IME.', '', '', '2016-08-29 05:39:43', '2016-08-29 05:39:43', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('IMEINFO', 'structure', 'Contains information about the Active Input Method Editor (IME).', 'typedef struct {\r\n  DWORD dwPrivateDataSize;\r\n  DWORD fdwProperty;\r\n  DWORD fdwConverstionCaps;\r\n  DWORD fdwSentenceCaps;\r\n  DWORD fdwUICaps;\r\n  DWORD fdwSCSCaps;\r\n  DWORD fdwSelectCaps;\r\n} IMEINFO;', 'dwPrivateDataSize --- Unsigned long integer value that contains the byte count of the private data. \r\n///\r\nfdwProperty --- Unsigned long integer value that contains the Active IME property values. \r\n///\r\nfdwConverstionCaps --- Unsigned long integer value that contains the Active IME conversion mode capability values. \r\n///\r\nfdwSentenceCaps --- Unsigned long integer value that contains the Active IME sentence mode capability. \r\n///\r\nfdwUICaps --- Unsigned long integer value that contains the Active IME user interface capability. \r\n///\r\nfdwSCSCaps --- Unsigned long integer value that contains the set composition string capability. \r\n///\r\nfdwSelectCaps --- Unsigned long integer value that contains the Active IME\'s capability to inherit input contexts.', '', 'This structure maps to the IMEINFO structure documented in the Microsoft Windows NT Driver Development Kit.', 'ImeInquire', '2016-08-28 05:46:31', '2016-08-28 05:46:31', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741226.aspx', '', '', '', '', ''),
('ImeInquire', 'function', 'The ImeInquire function handles initialization of the IME. It also returns an IMEINFO structure and the UI class \r\nname of the IME.', 'BOOL WINAPI ImeInquire( \r\n    LPIMEINFO lpIMEInfo, \r\n    LPTSTR lpszWndClass, \r\n    DWORD dwSystemInfoFlags)', 'lpIMEInfo --- Pointer to the IMEINFO structure. \r\n///\r\nlpszWndClass --- Window class name that should be filled by the IME. This name is the IME’s UI class.  \r\n///\r\ndwSystemInfoFlags --- Varying system information provided by the system. The following flags are provided.\r\n\r\n[table:ImeInquire_Table1]', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'IMEINFO', '2016-08-29 05:04:48', '2016-08-29 05:04:48', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('IMEMENUITEMINFOA', 'structure', 'Contains information about Active Input Method Editor (IME) menu items.', 'typedef struct {\r\n    UINT        cbSize;\r\n    UINT        fType;\r\n    UINT        fState;\r\n    UINT        wID;\r\n    HBITMAP     hbmpChecked;\r\n    HBITMAP     hbmpUnchecked;\r\n    DWORD       dwItemData;\r\n    CHAR        szString[IMEMENUITEM_STRING_SIZE];\r\n    HBITMAP     hbmpItem;\r\n} IMEMENUITEMINFOA;', 'cbSize --- Unsigned integer that contains the size of the structure, in bytes. \r\n///\r\nfType --- Unsigned integer that contains the menu type. This can be one of the following values. \r\n\r\n[table:IMEMENUITEMINFOA_Table1]\r\n///\r\nfState --- Unsigned integer that contains the menu item state. This can be one or more of the following values.\r\n\r\n[table:IMEMENUITEMINFOA_Table2]\r\n///\r\nwID --- Unsigned integer value that contains an application-defined value that identifies the menu item. \r\n///\r\nhbmpChecked --- Handle to the bitmap. If this member is NULL, no bitmap is used. \r\n///\r\nhbmpUnchecked --- Handle to the bitmap. If this member is NULL, no bitmap is used.\r\n/// \r\ndwItemData --- Unsigned long integer value that contains an application-defined value associated with the menu item. \r\n///\r\nszString --- Array of characters that contains the content of the menu item. This is a null-terminated string. \r\n///\r\nhbmpItem --- Handle to the bitmap to display.', '', '', 'ImeGetImeMenuItems|IMEMENUITEMINFO|IMEMENUITEMINFOW', '2016-08-28 05:49:24', '2016-08-28 05:49:24', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741227.aspx', '', '', '', '', ''),
('IMEMENUITEMINFOW', 'structure', 'Contains information about Active Input Method Editor (IME) menu items.', 'typedef struct {\r\n  UINT    cbSize;\r\n  UINT    fType;\r\n  UINT    fState;\r\n  UINT    wID;\r\n  HBITMAP hbmpChecked;\r\n  HBITMAP hbmpUnchecked;\r\n  DWORD   dwItemData;\r\n  WCHAR   szString[IMEMENUITEM_STRING_SIZE];\r\n  HBITMAP hbmpItem;\r\n} IMEMENUITEMINFOW;', 'cbSize --- Unsigned integer that contains the size of the structure in bytes.\r\n/// \r\nfType --- Unsigned integer that contains the menu type. This can be one of the following values.\r\n\r\n[table:IMEMENUITEMINFOW_Table1]\r\n///\r\nfState --- Unsigned integer that contains the menu item state. This can be one or more of the following values.\r\n\r\n[table:IMEMENUITEMINFOW_Table2]\r\n///\r\nwID --- Unsigned integer value that contains an application-defined value that identifies the menu item. \r\n///\r\nhbmpChecked --- Handle to the bitmap. If this member is NULL, no bitmap is used. \r\n///\r\nhbmpUnchecked --- Handle to the bitmap. If this member is NULL, no bitmap is used.\r\n/// \r\ndwItemData --- Unsigned long integer value that contains an application-defined value associated with the menu item. \r\n///\r\nszString --- Array of wide characters that contains the content of the menu item. This is a null-terminated string.\r\n/// \r\nhbmpItem --- Handle to the bitmap to display.', '', '', 'ImeGetImeMenuItems|IMEMENUITEMINFO|IMEMENUITEMINFOA', '2016-08-28 05:51:19', '2016-08-28 05:51:19', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741228.aspx', '', '', '', '', ''),
('ImeProcessKey', 'function', 'The ImeProcessKey function preprocesses all the keystrokes given through the IMM and returns TRUE if that key \r\nis necessary for the IME with a given Input Context.', 'BOOL WINAPI ImeProcessKey( \r\n    HIMC hIMC, \r\n    UINT uVirKey, \r\n    DWORD lParam, \r\n    CONST LPBYTE lpbKeyState)', 'hIMC --- Input context handle \r\n///\r\nuVirKey --- Virtual key to be processed. \r\n///\r\nlParam --- lParam of key messages. \r\n///\r\nlpbKeyState --- Points to a 256-byte array that contains the current keyboard state. The IME should not modify the content of the key state.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', 'The system decides whether the key is handled by IME or not by calling this function. If the function returns TRUE \r\nbefore the application gets the key message, the IME will handle the key. The system will then call the \r\nImeToAsciiEx function. If this function returns FALSE, the system recognizes that the key will not be handled by \r\nthe IME and the key message will be sent to the application. \r\n\r\nFor IMEs that support IME_PROP_ACCEPT_WIDE_VKEY on Windows 2000, ImeProcessKey will receive \r\nfull 32 bit value for uVirKey, which is injected by using SendInput API through VK_PACKET. uVirKey will \r\ninclude 16-bit Unicode in hiword even the IME may be ANSI version.  \r\n\r\nFor IMEs that do not support IME_PROP_ACCEPT_WIDE_VKEY, Unicode IME\'s ImeProcessKey will \r\nreceive VK_PACKET with zero\'ed hiword. Unicode IME still can return TRUE so ImeToAsciiEx will be called \r\nwith the injected Unicode. ANSI IME\'s ImeProcessKey will not receive anything. The injected Unicode will \r\nbe discarded if the ANSI IME is open. If the ANSI IME is closed, the injected Unicode message will be \r\nposted to application\'s queue immediately.', 'ImeToAsciiEx', '2016-08-29 05:21:24', '2016-08-29 05:21:24', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeRegisterWord', 'function', 'The ImeRegisterWord function registers a string into the dictionary of this IME.', 'BOOL WINAPI ImeRegisterWord( \r\n    LPCTSTR lpszReading, \r\n    DWORD dwStyle, \r\n    LPCTSTR lpszString)', 'lpszReading --- Reading string of the registered string.\r\n///\r\ndwStyle --- Style of the registered string. The following values are provided.\r\n\r\n[table:ImeRegisterWord_Table1]\r\n///\r\nlpszString --- String to be registered.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'ImeUnregisterWord|ImeEnumRegisterWord', '2016-08-29 05:35:20', '2016-08-29 05:35:20', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeSelect', 'function', 'The ImeSelect function is used to initialize and uninitialize the IME private context.', 'BOOL WINAPI ImeSelect( \r\n    HIMC hIMC, \r\n    BOOL fSelect)', 'hIMC --- Input context handle \r\n///\r\nfSelect --- Two flags are provided. TRUE indicates initialize and FALSE indicates uninitialize (free resource).', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', '', '2016-08-29 05:25:51', '2016-08-29 05:25:51', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeSetActiveContext', 'function', 'The ImeSetActiveContext function notifies the current IME active Input Context.', 'BOOL WINAPI ImeSetActiveContext( \r\n    HIMC hIMC, \r\n    BOOL fFlag)', 'hIMC --- Input context handle. \r\n///\r\nfFlag --- Two flags are provided. TRUE indicates activated and FALSE indicates deactivated.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', 'The IME is informed by this function about a newly selected Input Context. The IME can carry out initialization, but \r\nit is not required.', '', '2016-08-29 05:20:00', '2016-08-29 05:20:00', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeSetCompositionString', 'function', 'The ImeSetCompositionString function is used by an application to set the IME composition string structure with \r\nthe data contained in the lpComp or lpRead parameters. The IME then generates a WM_IME_COMPOSITION \r\nmessage.', 'BOOL WINAPI ImeSetCompositionString( \r\n    HIMC hIMC, \r\n    DWORD dwIndex, \r\n    LPCVOID lpComp, \r\n    DWORD dwCompLen, \r\n    LPCVOID lpRead, \r\n    DWORD dwReadLen);', 'hIMC --- Input context handle.  \r\n///\r\ndwIndex --- The following values are provided for dwIndex.\r\n\r\n[table:ImeSetCompositionString_Table1]\r\n///\r\nlpComp --- Pointer to the buffer that contains the updated string. The type of string is determined by the value of dwIndex. \r\n///\r\ndwCompLen --- Length of the buffer in bytes. \r\n///\r\nlpRead --- Pointer to the buffer that contains the updated string. The type of string is determined by the value of dwIndex. If the value of dwIndex is SCS_SETRRECONVERTSTRING or SCS_QUERYRECONVERTSTRING, lpRead will be a pointer to the RECONVERTSTRING structure that contains the updated reading string. If the selected IME has the value SCS_CAP_MAKEREAD, this can be NULL. \r\n///\r\ndwReadLen --- Length of the buffer in bytes.', 'TRUE if successful.', 'For Unicode, dwCompLen and dwReadLen specifies the length of the buffer in bytes, even if SCS_SETSTR is \r\nspecified and the buffer contains a Unicode string.\r\n\r\nSCS_SETRECONVERTSTRING or SCS_QUERYRECONVERTSTRING can be used only for IMEs that have an \r\nSCS_CAP_SETRECONVERTSTRING property. This property can be retrieved by using the ImmGetProperty \r\nfunction.', 'WM_IME_COMPOSITION|RECONVERTSTRING', '2016-08-29 05:27:53', '2016-08-29 05:27:53', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeToAsciiEx', 'function', 'The ImeToAsciiEx function generates a conversion result through the IME conversion engine according to the \r\nhIMC parameter.', 'UINT WINAPI ImeToAsciiEx( \r\n    UINT uVirKey, \r\n    UINT uScanCode, \r\n    CONST LPBYTE lpbKeyState, \r\n    LPTRANSMSGLIST lpTransMsgList, \r\n    UINT fuState, \r\n    HIMC hIMC)', 'uVirKey --- Specifies the virtual key code to be translated. When the property bit IME_PROP_KBD_CHAR_FIRST is on, the upper byte of the virtual key is the aid character code.\r\n \r\nFor Unicode, the upper word of uVirKey contains the Unicode character code if the IME_PROP_KBD_CHAR_FIRST bit is on.\r\n/// \r\nuScanCode --- Specifies the hardware scan code of the key to be translated. \r\n///\r\nlpbKeyState --- Points to a 256-byte array that contains the current keyboard state. The IME should not modify the content of the key state. \r\n///\r\nlpTransMsgList --- Point to a TRANSMSGLIST buffer to receive the translated message result. This was defined as a double word buffer in Windows 95/98 and Windows NT 4.0 IME document, and the double word buffer format is [Length of \r\nthe pass in translated message buffer] [Message1] [wParam1] [lParam1] {[Message2] [wParam2] \r\n[lParam2]{...{...{...}}}}.\r\n///\r\nfuState --- Active menu flag. \r\n///\r\nhIMC --- Input context handle.', 'The return value indicates the number of messages. If the number is greater than the length of the translated \r\nmessage buffer, the translated message buffer is not enough. The system then checks hMsgBuf to get the \r\ntranslation messages.', 'On Windows 2000, a new 32bit-width virtual key code, using VK_PACKET in LOBYTE of wParam and the high \r\nword is Unicode, can be injected by using SendInput.  \r\nFor ANSI IMEs that support IME_PROP_ACCEPT_WIDE_VKEY, ImeToAsciiEx may receive up to 16bit ANSI \r\ncode for a character. It will be packed as below.  The character is injected from SendInput API through \r\nVK_PACKET.\r\n\r\n[table:ImeToAsciiEx_Table1]', 'TRANSMSGLIST|ImeProcessKey', '2016-08-29 05:32:11', '2016-08-29 05:32:11', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImeUnregisterWord', 'function', 'The ImeUnregisterWord function removes a registered string from the dictionary of this IME.', 'BOOL WINAPI ImeUnregisterWord( \r\n    LPCTSTR lpszReading, \r\n    DWORD dwStyle, \r\n    LPCTSTR lpszString)', 'lpszReading --- Reading string of the registered string. \r\n///\r\ndwStyle --- Style of the registered string. Please refer to the ImeRegisterWord function for a description of dwStyle.\r\n///\r\nlpszString --- String to be unregistered.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'ImeRegisterWord', '2016-08-29 05:38:54', '2016-08-29 05:38:54', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmAssociateContext', 'function', 'Associates the specified input context with the specified window. By default, the operating system associates the default input context with each window as it is created.', 'HIMC ImmAssociateContext(\r\n  _In_ HWND hWnd,\r\n  _In_ HIMC hIMC\r\n);', 'hWnd [in] --- Handle to the window to associate with the input context.\r\n///\r\nhIMC [in] --- Handle to the input context. If hIMC is NULL, the function removes any association the window has with an input context. Thus IME cannot be used in the window.', 'Returns the handle to the input context previously associated with the window.', 'When associating an input context with a window, an application must remove the association before destroying the input context. One way to do this is to save the handle and reassociate it to the default input context with the window.', 'ImmAssociateContextEx', '2016-08-25 03:25:12', '2016-08-25 03:25:12', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318172.aspx', '', '', '', '', ''),
('ImmAssociateContextEx', 'function', 'Changes the association between the input method context and the specified window or its children.', 'BOOL ImmAssociateContextEx(\r\n  _In_ HWND  hWnd,\r\n  _In_ HIMC  hIMC,\r\n  _In_ DWORD dwFlags\r\n);', 'hWnd [in] --- Handle to the window to associate with the input context.\n///\nhIMC [in] --- Handle to the input method context.\n///\ndwFlags [in] --- Flags specifying the type of association between the window and the input method context. This parameter can have one of the following values.\n\n[table:ImmAssociateContextEx_Table1]', 'Returns TRUE if successful or FALSE otherwise.', 'If the application calls this function with IACE_CHILDREN, the operating system associates the specified input method context with child windows of the window indicated by hWnd. It associates the input method context only with child windows of the thread that creates hWnd. Any child window that is created after this function has been called will not be affected. Instead, the default input method context will be associated with it.\r\n\r\nIf the application calls this function with IACE_DEFAULT, the operating system restores the default input method context for the window. In this case, the hIMC parameter is ignored.', 'ImmAssociateContext', '2016-08-25 03:27:52', '2016-08-25 03:27:52', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318171.aspx', '', '', '', '', ''),
('ImmConfigureIME', 'function', 'Displays the configuration dialog box for the IME of the specified input locale identifier.', 'BOOL ImmConfigureIME(\r\n  _In_ HKL    hKL,\r\n  _In_ HWND   hWnd,\r\n  _In_ DWORD  dwMode,\r\n  _In_ LPVOID lpData\r\n);', 'hKL [in] --- Input locale identifier of an IME.\r\n///\r\nhWnd [in] --- Handle to the parent window for the dialog box.\r\n///\r\ndwMode [in] --- Flags specifying the type of dialog box to display. This parameter can have one of the following values.\r\n\r\n[table:ImmConfigureIME_Table1]\r\n///\r\nlpData [in] --- Pointer to supplemental data. If dwMode is set to IME_CONFIG_REGISTERWORD, this parameter must indicate a REGISTERWORD structure. If dwMode is not IME_CONFIG_REGISTERWORD, this parameter is ignored.', 'Returns a nonzero value if successful, or 0 otherwise.', '', 'REGISTERWORD|ImeConfigure', '2016-08-25 03:30:51', '2016-08-25 03:30:51', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318173.aspx', '', '', '', '', ''),
('ImmCreateContext', 'function', 'Creates a new input context, allocating memory for the context and initializing it. An application calls this function to prepare its own input context.', 'HIMC ImmCreateContext(void);', 'This function has no parameters.', 'Returns the handle to the new input context if successful, or NULL otherwise.', '', 'ImmDestroyContext', '2016-08-25 03:32:38', '2016-08-25 03:32:38', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318532.aspx', '', '', '', '', ''),
('ImmCreateIMCC', 'function', 'The ImmCreateIMCC function creates a new component as a member of the IMC.', 'HIMCC WINAPI \r\nImmCreateIMCC( \r\n    DWORD dwSize)', 'dwSize --- Size of the new IMC component.', 'If the function is successful, the return value is the IMC component handle (HIMCC). Otherwise, the return value is \r\nNULL.', 'The IMC component created by this function is initialized as zero.', 'ImmDestroyIMCC', '2016-08-29 03:54:29', '2016-08-29 03:54:29', '<imm.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmCreateSoftKeyboard', 'function', 'The ImmCreateSoftKeyboard function creates one type of soft keyboard window.', 'HWND WINAPI ImmCreateSoftKeyboard( \r\n    UINT uType, \r\n    UINT hOwner, \r\n    int x, \r\n    int y)', 'uType --- Specifies the type of the soft keyboard.\r\n\r\n[table:ImmCreateSoftKeyboard_Table1]\r\n///\r\nhOwner --- Specifies the owner of the soft keyboard. It must be the UI window. \r\n///\r\nx --- Specifies the initial horizontal position of the soft keyboard. \r\n///\r\ny --- Specifies the initial vertical position of the soft keyboard.', 'This function returns the window handle of the soft keyboard.', '', 'ImmDestroySoftKeyboard|ImmShowSoftKeyboard', '2016-08-29 04:04:58', '2016-08-29 04:04:58', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmDestroyContext', 'function', '', 'BOOL ImmDestroyContext(\r\n  _In_ HIMC hIMC\r\n);', 'hIMC [in] --- Handle to the input context to free.', 'Returns a nonzero value if successful, or 0 otherwise.', 'Any application that creates an input context by using the ImmCreateContext function must call this function to free the context before it terminates. However, before calling ImmDestroyContext, the application must remove the input context from any association with windows in the thread by using the ImmAssociateContext function.', 'ImmCreateContext', '2016-08-25 03:33:55', '2016-08-25 03:33:55', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318533.aspx', '', '', '', '', ''),
('ImmDestroyIMCC', 'function', 'The ImmDestroyIMCC function is used by the IME to destroy the IMC component that was created as a member \r\nof the IMC.', 'HIMCC WINAPI \r\nImmDestroyIMCC( \r\n    HIMCC hIMCC)', 'hIMCC --- Handle of the IMC component.', 'If the function is successful, the return value is NULL. Otherwise, the return value is equal to the HIMCC.', '', 'ImmCreateIMCC', '2016-08-29 03:55:27', '2016-08-29 03:55:27', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmDestroySoftKeyboard', 'function', 'The ImmDestroySoftKeyboard function destroys the soft keyboard window.', 'BOOL WINAPI ImmDestroySoftKeyboard( \r\n    HWND hSoftKbdWnd)', 'hSoftKbdWnd --- Window handle of the soft keyboard to destroy.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'ImmCreateSoftKeyboard', '2016-08-29 04:06:49', '2016-08-29 04:06:49', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmDisableIME', 'function', 'Disables the IME for a thread or for all threads in a process.', 'BOOL ImmDisableIME(\r\n  _In_ DWORD idThread\r\n);', 'idThread [in] --- Identifier of the thread for which to disable the IME. The thread must be in the same process as the application calling this function. The application sets this parameter to 0 to disable the IME for the current thread. The application specifies -1 to disable the IME for all threads in the current process.', 'Returns TRUE if successful or FALSE otherwise.', 'The application must call this function before the first top-level window in the thread receives the WM_CREATE message. Thus, the application must call this function in one of the following places:\r\n\r\n * Any time before calling CreateWindow to create the first top-level window\r\n * In the WM_NCCREATE handler for first top-level window', '', '2016-08-25 03:35:11', '2016-08-25 03:35:11', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318535.aspx', '', '', '', '', ''),
('ImmDisableLegacyIME', 'function', 'Indicates that this thread is a Windows Store app UI thread.', 'BOOL IMMDisableLegacyIME(void);', 'This function has no parameters.', 'Returns TRUE if successful; otherwise, FALSE.', 'Windows Store app brokers such as explorer.exe should call this function in Windows Store app UI threads to ensure that only IMEs that are compatible with Windows Store apps are made available. Those Windows Store app threads that don\'t require IME input should call ImmDisableIME to disable IMM entirely for that thread.\r\n\r\nThe app must call this function before the first top-level window in the thread receives the WM_CREATE message. Thus, the app must call this function in one of the following places:\r\n\r\n * Any time before CreateWindow is called to create the first top-level window.\r\n * In the WM_NCCREATE handler for the first top-level window.', '', '2016-08-27 02:00:35', '2016-08-27 02:00:35', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/hh706738.aspx', '', '', '', '', ''),
('ImmEnumInputContext', 'function', 'Retrieves the input context for the specified thread.', 'BOOL ImmEnumInputContext(\r\n  _In_ DWORD       idThread,\r\n  _In_ IMCENUMPROC lpfn,\r\n  _In_ LPARAM      lParam\r\n);', 'idThread [in] --- Identifier for the thread. This parameter can have one of the following values.\r\n\r\n[table:ImmEnumInputContext_Table1]\r\n///\r\nlpfn [in] --- Pointer to the enumeration callback function. For more information, see EnumInputContext.\r\n///\r\nlParam [in] --- Application-supplied data. The function passes this data to the callback function.', 'Returns TRUE if successful or FALSE otherwise.', 'This function calls the application callback function for each enumerated input context, and passes the specified lParam value.', '', '2016-08-25 03:37:16', '2016-08-25 03:37:16', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318539.aspx', '', '', '', '', ''),
('ImmEnumRegisterWord', 'function', 'Enumerates the register strings having the specified reading string, style, and register string.', 'UINT ImmEnumRegisterWord(\r\n  _In_     HKL                  hKL,\r\n  _In_     REGISTERWORDENUMPROC lpfnEnumProc,\r\n  _In_opt_ LPCTSTR              lpszReading,\r\n  _In_     DWORD                dwStyle,\r\n  _In_opt_ LPCTSTR              lpszRegister,\r\n  _In_', 'hKL [in] --- Input locale identifier.\r\n///\r\nlpfnEnumProc [in] --- Pointer to the callback function. For more information, see EnumRegisterWordProc.\r\n///\r\nlpszReading [in, optional] --- Pointer to the reading string to enumerate. The application sets this parameter to NULL if the function is to enumerate all available reading strings that match the dwStyle and lpszRegister settings.\r\n///\r\ndwStyle [in] --- Style to enumerate. The application specifies 0 if the function is to enumerate all available styles that match the lpszReading and lpszRegister settings.\r\n///\r\nlpszRegister [in, optional] --- Pointer to the register string to enumerate. The application sets this parameter to NULL if the function is to enumerate all register strings that match the lpszReading and dwStyle settings.\r\n///\r\nlpData [in] --- Pointer to application-supplied data. The function passes this data to the callback function.', 'Returns the last value returned by the callback function, with the meaning defined by the application. The function returns 0 if it cannot enumerate the register strings.', 'If dwStyle is set to 0 and both lpszReading and lpszRegister are set to NULL, this function enumerates all register strings in the IME dictionary.', 'ImmRegisterWord', '2016-08-25 03:38:41', '2016-08-25 03:38:41', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318542.aspx', '', '', '', '', ''),
('ImmEscape', 'function', 'Accesses capabilities of particular IMEs that are not available through other IME API functions. This function is used mainly for country-specific operations.', 'LRESULT WINAPI ImmEscape(\r\n  _In_    HKL    hKL,\r\n  _In_    HIMC   hIMC,\r\n  _In_    UINT   uEscape,\r\n  _Inout_ LPVOID lpData\r\n);', 'hKL [in] --- Input locale identifier.\r\n///\r\nhIMC [in] --- Handle to the input context.\r\n///\r\nuEscape [in] --- Index of the operations. For more information, see IME Escapes.\r\n///\r\nlpData [in, out] --- Pointer to the data required for the escape specified in uEscape. On output, this parameter indicates the result of the escape. For more information, see IME Escapes.', 'Returns an operation-specific value if successful, or 0 otherwise.', 'When uEscape is set to IME_ESC_QUERY_SUPPORT, lpData indicates the buffer containing the IME escape value. For example, to see if the current IME supports IME_ESC_GETHELPFILENAME, your application uses the following call:\r\n\r\n<pre>DWORD dwEsc = IME_ESC_GETHELPFILENAME;\r\nLRESULT lRet = ImmEscape(hKL,\r\n                         hIMC,\r\n                         IME_ESC_QUERY_SUPPORT,\r\n                         (LPVOID)&dwEsc);</pre>', 'IME Escapes', '2016-08-25 03:40:09', '2016-08-25 03:40:09', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318544.aspx', '', '', '', '', ''),
('ImmGenerateMessage', 'function', 'The IME uses the ImmGenerateMessage function to send messages to the hWnd of hIMC. The messages to be \r\nsent are stored in hMsgBuf of hIMC.', 'BOOL WINAPI \r\nImmGenerateMessage( \r\n    HIMC hIMC);', 'hIMC --- Input context handle containing hMsgBuf.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', 'This is a general purpose function. Typically, an IME uses this function when it is notified about the context update \r\nthrough ImmNotifyIME from IMM. In this case, even if IME needs to provide messages to an application, there is \r\nno keystroke in the application’s message queue.\r\n\r\nAn IME User Interface should not use this function when it only wants to update the UI appearance. The IME User \r\nInterface should have been updated when the IME is informed about the updated Input Context. It is \r\nrecommended that you use this function from the IME only when the IME changes the Input Context without any \r\nkeystroke given and needs to inform an application of the change.', 'ImmNotifyIME', '2016-08-29 03:47:23', '2016-08-29 03:47:23', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmGetCandidateList', 'function', 'Retrieves a candidate list.', 'DWORD ImmGetCandidateList(\r\n  _In_      HIMC            hIMC,\r\n  _In_      DWORD           dwIndex,\r\n  _Out_opt_ LPCANDIDATELIST lpCandList,\r\n  _In_      DWORD           dwBufLen\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\ndwIndex [in] --- Zero-based index of the candidate list.\r\n///\r\nlpCandList [out, optional] --- Pointer to a CANDIDATELIST structure in which the function retrieves the candidate list.\r\n///\r\ndwBufLen [in] --- Size, in bytes, of the buffer to receive the candidate list. The application can specify 0 for this parameter if the function is to return the required size of the output buffer only.', 'Returns the number of bytes copied to the candidate list buffer if successful. If the application has supplied 0 for the dwBufLen parameter, the function returns the size required for the candidate list buffer.\r\n\r\nThe function returns 0 if it does not succeed.', '', 'ImmGetCandidateListCount|CANDIDATELIST', '2016-08-25 03:41:14', '2016-08-25 03:41:14', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318545.aspx', '', '', '', '', ''),
('ImmGetCandidateListCount', 'function', 'Retrieves the size of the candidate lists.', 'DWORD ImmGetCandidateListCount(\r\n  _In_  HIMC    hIMC,\r\n  _Out_ LPDWORD lpdwListCount\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\nlpdwListCount [out] --- Pointer to the buffer in which this function retrieves the size of the candidate lists.', 'Returns the number of bytes required for all candidate lists if successful, or 0 otherwise.', 'Applications typically call this function in response to an IMN_OPENCANDIDATE or IMN_CHANGECANDIDATE command.', 'ImmGetCandidateList|IMN_OPENCANDIDATE|IMN_CHANGECANDIDATE', '2016-08-25 03:42:29', '2016-08-25 03:42:29', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318547.aspx', '', '', '', '', ''),
('ImmGetCandidateWindow', 'function', 'Retrieves information about the candidates window.', 'BOOL ImmGetCandidateWindow(\r\n  _In_  HIMC            hIMC,\r\n  _In_  DWORD           dwIndex,\r\n  _Out_ LPCANDIDATEFORM lpCandidate\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\ndwIndex [in] --- Index of the candidates window.\r\n///\r\nlpCandidate [out] --- Pointer to a CANDIDATEFORM structure in which this function retrieves information about the candidates window.', 'Returns a nonzero value if successful, or 0 otherwise.', '', 'ImmSetCandidateWindow|CANDIDATEFORM', '2016-08-25 03:43:29', '2016-08-25 03:43:29', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318549.aspx', '', '', '', '', ''),
('ImmGetCompositionFont', 'function', 'Retrieves information about the logical font currently used to display characters in the composition window.', 'BOOL ImmGetCompositionFont(\r\n  _In_  HIMC      hIMC,\r\n  _Out_ LPLOGFONT lplf\r\n);', 'hIMC [in] --- Handle to the input context.\r\nlplf [out] --- Pointer to a LOGFONT structure in which this function retrieves the font information.', 'Returns a nonzero value if successful, or 0 otherwise.', '', 'ImmSetCompositionFont', '2016-08-25 03:44:19', '2016-08-25 03:44:19', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318551.aspx', '', '', '', '', ''),
('ImmGetCompositionString', 'function', 'Retrieves information about the composition string.', 'LONG ImmGetCompositionString(\r\n  _In_      HIMC   hIMC,\r\n  _In_      DWORD  dwIndex,\r\n  _Out_opt_ LPVOID lpBuf,\r\n  _In_      DWORD  dwBufLen\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\ndwIndex [in] --- Index of the information to retrieve, which is one of the values specified in IME Composition String Values. For each value except GCS_CURSORPOS and GCS_DELTASTART, the function copies the requested information to the output buffer. The function returns the cursor and delta position values in the low 16 bits of the return value.\r\n///\r\nlpBuf [out, optional] --- Pointer to a buffer in which the function retrieves the composition string information.\r\n///\r\ndwBufLen [in] --- Size, in bytes, of the output buffer, even if the output is a Unicode string. The application sets this parameter to 0 if the function is to return the size of the required output buffer.', 'Returns the number of bytes copied to the output buffer. If dwBufLen is set to 0, the function returns the buffer size, in bytes, required to receive all requested information, excluding the terminating null character. The return value is always the size, in bytes, even if the requested data is a Unicode string.\r\n\r\nThis function returns one of the following negative error codes if it does not succeed:\r\n\r\n[table:ImmGetCompositionString_Table1]', 'An application calls this function in response to the WM_IME_COMPOSITION or WM_IME_STARTCOMPOSITION message. The IMM removes the information when the application calls the ImmReleaseContext function.\r\n\r\nNote: You must write code to handle both full-width Hiragana and half-width Katakana if your application is used with the Soft Input Panel (SIP).', 'ImmSetCompositionFont|WM_IME_COMPOSITION|WM_IME_STARTCOMPOSITION', '2016-08-25 03:46:12', '2016-08-25 03:46:12', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318553.aspx', '', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('ImmGetCompositionWindow', 'function', 'Retrieves information about the composition window.', 'BOOL ImmGetCompositionWindow(\r\n  _In_  HIMC              hIMC,\r\n  _Out_ LPCOMPOSITIONFORM lpCompForm\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\nlpCompForm [out] --- Pointer to a COMPOSITIONFORM structure in which the function retrieves information about the composition window.', 'Returns a nonzero value if successful, or 0 otherwise.', '', 'ImmSetCompositionWindow|COMPOSITIONFORM', '2016-08-25 03:47:07', '2016-08-25 03:47:07', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318556.aspx', '', '', '', '', ''),
('ImmGetContext', 'function', 'Returns the input context associated with the specified window.', 'HIMC ImmGetContext(\r\n  _In_ HWND hWnd\r\n);', 'hWnd [in] --- Handle to the window for which to retrieve the input context.', 'Returns the handle to the input context.', 'An application should routinely use this function to retrieve the current input context before attempting to access information in the context.\r\n\r\nThe application must call ImmReleaseContext when it is finished with the input context.', 'ImmReleaseContext', '2016-08-25 03:48:13', '2016-08-25 03:48:13', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318558.aspx', '', '', '', '', ''),
('ImmGetConversionList', 'function', 'Retrieves the conversion result list of characters or words without generating any IME-related messages.', 'DWORD ImmGetConversionList(\r\n  _In_  HKL             hKL,\r\n  _In_  HIMC            hIMC,\r\n  _In_  LPCTSTR         lpSrc,\r\n  _Out_ LPCANDIDATELIST lpDst,\r\n  _In_  DWORD           dwBufLen,\r\n  _In_  UINT            uFlag\r\n);', 'hKL [in] --- Input locale identifier.\r\n///\r\nhIMC [in] --- Handle to the input context.\r\n///\r\nlpSrc [in] --- Pointer to a null-terminated character string specifying the source of the list.\r\n///\r\nlpDst [out] --- Pointer to a CANDIDATELIST structure in which the function retrieves the list.\r\n///\r\ndwBufLen [in] --- Size, in bytes, of the output buffer. The application sets this parameter to 0 if the function is to return the buffer size required for the complete conversion result list.\r\n///\r\nuFlag [in] --- Action flag. This parameter can have one of the following values.\r\n\r\n[table:ImmGetConversionList_Table1]', 'Returns the number of bytes copied to the output buffer. If the application sets the dwBufLen parameter to 0, the function returns the size, in bytes, of the required output buffer.', '', 'CANDIDATELIST', '2016-08-25 03:49:16', '2016-08-25 03:49:16', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318559.aspx', '', '', '', '', ''),
('ImmGetConversionStatus', 'function', 'Retrieves the current conversion status.', 'BOOL ImmGetConversionStatus(\r\n  _In_      HIMC    hIMC,\r\n  _Out_opt_ LPDWORD lpfdwConversion,\r\n  _Out_opt_ LPDWORD lpfdwSentence\r\n);', 'hIMC [in] --- Handle to the input context for which to retrieve status information.\r\n///\r\nlpfdwConversion [out, optional] --- Pointer to a variable in which the function retrieves a combination of conversion mode values. For more information, see IME Conversion Mode Values.\r\n///\r\nlpfdwSentence [out, optional] --- Pointer to a variable in which the function retrieves a sentence mode value. For more information, see IME Sentence Mode Values.', 'Returns a nonzero value if successful, or 0 otherwise.', 'Conversion and sentence mode values are set only if the IME supports those modes.', 'ImmSetConversionStatus|IME Conversion Mode Values|IME Sentence Mode Values', '2016-08-25 03:50:18', '2016-08-25 03:50:18', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318560.aspx', '', '', '', '', ''),
('ImmGetDefaultIMEWnd', 'function', 'Retrieves the default window handle to the IME class.', 'HWND ImmGetDefaultIMEWnd(\r\n  _In_ HWND hWnd\r\n);', 'hWnd [in] --- Handle to the window.', 'Returns the default window handle to the IME class if successful, or NULL otherwise.', 'The operating system creates a default IME window for every thread. The window is created based on the IME class. The application can send the WM_IME_CONTROL message to this window.', 'WM_IME_CONTROL', '2016-08-25 03:51:18', '2016-08-25 03:51:18', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318561.aspx', '', '', '', '', ''),
('ImmGetDescription', 'function', 'Copies the description of the IME to the specified buffer.', 'UINT ImmGetDescription(\r\n  _In_      HKL    hKL,\r\n  _Out_opt_ LPTSTR lpszDescription,\r\n  _In_      UINT   uBufLen\r\n);', 'hKL [in] --- Input locale identifier.\r\n///\r\nlpszDescription [out, optional] --- Pointer to a buffer in which the function retrieves the null-terminated string describing the IME.\r\n///\r\nuBufLen [in] --- Size, in characters, of the output buffer. The application sets this parameter to 0 if the function is to return the buffer size needed for the complete description, excluding the terminating null character.\r\n\r\nWindows NT, Windows 2000, Windows XP: The size of the buffer is in Unicode characters, each consisting of two bytes. If the parameter is set to 0, the function returns the size of the buffer required in Unicode characters, excluding the Unicode terminating null character.', 'Returns the number of characters copied to the output buffer. If the application sets the uBufLen parameter to 0, the function returns the size of the buffer required to receive the description. Neither value includes the terminating null character. For Unicode, the function returns the number of Unicode characters, not including the Unicode terminating null character.', '', '', '2016-08-25 03:52:11', '2016-08-25 03:52:11', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318562.aspx', '', '', '', '', ''),
('ImmGetGuideLine', 'function', 'Retrieves information about errors. Applications use the information for user notifications.', 'DWORD ImmGetGuideLine(\r\n  _In_      HIMC   hIMC,\r\n  _In_      DWORD  dwIndex,\r\n  _Out_opt_ LPTSTR lpBuf,\r\n  _In_      DWORD  dwBufLen\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\ndwIndex [in] --- Type of guideline information to retrieve. This parameter can have one of the following values.\r\n\r\n[table:ImmGetGuideLine_Table1]\r\n///\r\nlpBuf [out, optional] --- Pointer to a buffer in which the function retrieves the error message string. This parameter contains NULL if dwIndex is not GGL_STRING or GGL_PRIVATE or if dwBufLen is set to 0.\r\n///\r\ndwBufLen [in] --- Size, in bytes, of the output buffer. The application sets this parameter to 0 if the function is to return the buffer size needed to receive the error message string, not including the terminating null character.', 'Returns an error level, an error index, or the size of an error message string, depending on the value of the dwIndex parameter. If dwIndex is GGL_LEVEL, the return is one of the following values.\r\n\r\n[table:ImmGetGuideLine_Table2]\r\n\r\nIf dwIndex is GGL_INDEX, the return value is one of the following values.\r\n\r\n[table:ImmGetGuideLine_Table3]\r\n\r\nIf dwIndex is GGL_STRING, the return value is the number of bytes of the string copied to the buffer. However, if dwBufLen is 0, the return value is the buffer size needed to receive the string, not including the terminating null character. For Unicode, if dwBufLen is 0, the return value is the size, in bytes not including the Unicode terminating null character.\r\n\r\nIf dwIndex is GGL_PRIVATE, the return value is the number of bytes of information copied to the buffer. If dwIndex is GGL_PRIVATE and dwBufLen is 0, the return value is the buffer size needed to receive the information.', 'Applications typically call this function after receiving an IMN_GUIDELINE command.', '', '2016-08-25 03:53:39', '2016-08-25 03:53:39', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318563.aspx', '', '', '', '', ''),
('ImmGetHotKey', 'function', 'The ImmGetHotKey function gets the value of the IME hot key.', 'BOOL WINAPI \r\nImmGetHotKey( \r\n    DWORD dwHotKeyID, \r\n    LPUINT lpuModifiers, \r\n    LPUINT lpuVKey, \r\n    LPHKL lphKL)', 'dwHotKeyID --- Hot key identifier. \r\n///\r\nlpuModifiers --- Combination keys with the hot key. It includes ALT (MOD_ALT), CTRL (MOD_CONTROL), SHIFT \r\n(MOD_SHIFT), left-hand side (MOD_LEFT), and right-hand side (MOD_RIGHT). \r\n\r\nThe key up flag (MOD_ON_KEYUP) indicates that the hot key is effective when the key is up. The modifier \r\nignore flag (MOD_IGNORE_ALL_MODIFIER) indicates that the combination of modifiers is ignored in hot key \r\nmatching. \r\n///\r\nlpuVKey  --- Virtual key code of this hot key. \r\n///\r\nlphKL --- HKL of the IME. If the return value of this parameter is not NULL, this hot key can switch to the IME with this HKL.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', 'This function is called by the Control Panel.', 'ImmSetHotKey', '2016-08-29 04:02:08', '2016-08-29 04:02:08', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmGetIMCCLockCount', 'function', 'The ImmGetIMCCLockCount function is used to get the lock count of the IMCC.', 'DWORD WINAPI \r\nImmGetIMCCLockCount( \r\n    HIMCC hIMCC)', 'hIMCC --- Handle of the IMC component.', 'If the function is successful, the return value is the lock count of the IMCC. Otherwise, the return value is zero.', '', 'ImmLockIMCC|ImmUnlockIMCC', '2016-08-29 04:00:50', '2016-08-29 04:00:50', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmGetIMCCSize', 'function', 'The ImmGetIMCCLockCount function is used to get the size of the IMCC.', 'DWORD WINAPI \r\nImmGetIMCCSize( \r\n    HIMCC hIMCC)', 'hIMCC --- Handle of the IMC component.', 'Size of the IMCC.', '', 'ImmCreateIMCC', '2016-08-29 03:59:43', '2016-08-29 03:59:43', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmGetIMCLockCount', 'function', 'The ImmGetIMCLockCount is used to get the lock count of the IMC.', 'HIMCC WINAPI \r\nImmGetIMCLockCount( \r\n    HIMC hIMC)', 'hIMC --- Input context handle', 'If the function is successful, the return value is the lock count of the IMC. Otherwise, the return value is NULL.', '', 'ImmLockIMC|ImmInlockIMC', '2016-08-29 03:53:21', '2016-08-29 03:53:21', '<imm.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmGetIMEFileName', 'function', 'Retrieves the file name of the IME associated with the specified input locale.', 'UINT ImmGetIMEFileName(\r\n  _In_      HKL    hKL,\r\n  _Out_opt_ LPTSTR lpszFileName,\r\n  _In_      UINT   uBufLen\r\n);', 'hKL [in] --- Input locale identifier.\r\n///\r\nlpszFileName [out, optional] --- Pointer to a buffer in which the function retrieves the file name. This parameter contains NULL when uBufLen is set to NULL.\r\n///\r\nuBufLen [in] --- Size, in bytes, of the output buffer. The application specifies 0 if the function is to return the buffer size needed to receive the file name, not including the terminating null character. For Unicode, uBufLen specifies the size in Unicode characters, not including the terminating null character.', 'Returns the number of bytes in the file name copied to the output buffer. If the application sets uBufLen to 0, the function returns the size of the buffer required for the file name. In either case, the terminating null character is not included.\r\n\r\nFor Unicode, the function returns the number of Unicode characters copied into the output buffer, not including the Unicode terminating null character.', 'In the registry, the operating system stores the file name as the \"IME name value\" in the registry key HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Keyboard Layouts\\HKL.', '', '2016-08-25 03:54:52', '2016-08-25 03:54:52', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318564.aspx', '', '', '', '', ''),
('ImmGetImeMenuItems', 'function', 'Retrieves the menu items that are registered in the IME menu of a specified input context.', 'DWORD ImmGetImeMenuItems(\r\n  _In_      HIMC              hIMC,\r\n  _In_      DWORD             dwFlags,\r\n  _In_      DWORD             dwType,\r\n  _Out_opt_ LPIMEMENUITEMINFO lpImeParentMenu,\r\n  _Out_opt_ LPIMEMENUITEMINFO lpImeMenu,\r\n  _In_      DWORD', 'hIMC [in] --- Handle to the input context for the specified menu items.\r\n///\r\ndwFlags [in] --- Flag specifying menu information options. The following value is defined.\r\n\r\n[table:ImmGetImeMenuItems_Table1]\r\n///\r\ndwType [in] --- Type of menu to retrieve. This parameter can have one or more of the following values.\r\n\r\n[table:ImmGetImeMenuItems_Table2]\r\n///\r\nlpImeParentMenu [out, optional] --- Pointer to an IMEMENUITEMINFO structure in which the function retrieves parent menu information. To retrieve information about the submenu items of this parent menu, the application sets the fType member to MFT_SUBMENU. This parameter contains NULL if the function retrieves only top-level menu items.\r\n///\r\nlpImeMenu [out, optional] --- Pointer to an array of IMEMENUITEMINFO structures in which the function retrieves information about the menu items. This parameter contains NULL if the function retrieves the number of registered menu items.\r\n///\r\ndwSize [in] --- Size of the buffer to receive the IMEMENUITEMINFO structure.', 'Returns the number of menu items copied into lpImeMenu. If lpImeMenu specifies NULL, the function returns the number of registered menu items in the specified input context.', '', 'IMEMENUITEMINFO', '2016-08-25 03:56:10', '2016-08-25 03:56:10', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318565.aspx', '', '', '', '', ''),
('ImmGetOpenStatus', 'function', 'Determines whether the IME is open or closed.', 'BOOL ImmGetOpenStatus(\r\n  _In_ HIMC hIMC\r\n);', 'hIMC [in] --- Handle to the input context.', 'Returns a nonzero value if the IME is open, or 0 otherwise.', '', 'ImmSetOpenStatus', '2016-08-25 03:56:56', '2016-08-25 03:56:56', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318566.aspx', '', '', '', '', ''),
('ImmGetProperty', 'function', 'Retrieves the property and capabilities of the IME associated with the specified input locale.', 'DWORD ImmGetProperty(\r\n  _In_ HKL   hKL,\r\n  _In_ DWORD fdwIndex\r\n);', 'hKL [in] --- Input locale identifier.\r\n///\r\nfdwIndex [in] --- Type of property information to retrieve. This parameter can have one of the following values.\r\n\r\n[table:ImmGetProperty_Table1]', 'Returns the property or capability value, depending on the value of the dwIndex parameter. If dwIndex is set to IGP_PROPERTY, the function returns one or more of the following values:\r\n\r\n[table:ImmGetProperty_Table2]\r\n\r\nIf dwIndex is set to IGP_UI, the function returns one or more of the following values:\r\n\r\n[table:ImmGetProperty_Table3]\r\n\r\nIf dwIndex is set to IGP_SETCOMPSTR, the function returns one or more of the following values:\r\n\r\n[table:ImmGetProperty_Table4]\r\n\r\nIf dwIndex is set to IGP_SELECT, the function returns one or more of the following values:\r\n\r\n[table:ImmGetProperty_Table5]\r\n\r\nIf dwIndex is set to IGP_GETIMEVERSION, the function returns one or more of the following values:\r\n\r\n[table:ImmGetProperty_Table6]', '', '', '2016-08-25 03:58:11', '2016-08-25 03:58:11', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318567.aspx', '', '', '', '', ''),
('ImmGetRegisterWordStyle', 'function', 'Retrieves a list of the styles supported by the IME associated with the specified input locale.', 'UINT ImmGetRegisterWordStyle(\r\n  _In_  HKL        hKL,\r\n  _In_  UINT       nItem,\r\n  _Out_ LPSTYLEBUF lpStyleBuf\r\n);', 'hKL [in] --- Input locale identifier.\r\n///\r\nnItem [in] --- Maximum number of styles that the output buffer can hold. The application sets this parameter to 0 if the function is to count the number of styles available in the IME.\r\n///\r\nlpStyleBuf [out] --- Pointer to a STYLEBUF structure in which the function retrieves the style information.', 'Returns the number of styles copied to the buffer. If the application sets the nItem parameter to 0, the return value is the number of styles available in the IME.', '', 'STYLEBUF', '2016-08-25 03:59:14', '2016-08-25 03:59:14', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318568.aspx', '', '', '', '', ''),
('ImmGetStatusWindowPos', 'function', 'Retrieves the position of the status window.', 'BOOL ImmGetStatusWindowPos(\r\n  _In_  HIMC    hIMC,\r\n  _Out_ LPPOINT lpptPos\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\nlpptPos [out] --- Pointer to a POINT structure in which the function retrieves the position coordinates. These are screen coordinates, relative to the upper left corner of the screen.', 'Returns a nonzero value if successful, or 0 otherwise.', '', 'ImmSetStatusWindowPos', '2016-08-25 04:00:00', '2016-08-25 04:00:00', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318569.aspx', '', '', '', '', ''),
('ImmGetVirtualKey', 'function', 'Retrieves the original virtual key value associated with a key input message that the IME has already processed.', 'UINT ImmGetVirtualKey(\r\n  _In_ HWND hWnd\r\n);', 'hWnd [in] --- Handle to the window that receives the key message.', 'If TranslateMessage has been called by the application, ImmGetVirtualKey returns VK_PROCESSKEY; otherwise, it returns the virtua', 'Although the IME sets the virtual key value to VK_PROCESSKEY after processing a key input message, an application can recover the original virtual key value with the ImmGetVirtualKey function. This function is used only for key input messages containing the VK_PROCESSKEY value. Applications can only get the original virtual key by using this function after receiving the WM_KEYDOWN (VK_PROCESSKEY) message, and before TranslateMessage is called in its own message loop.', 'WM_KEYDOWN', '2016-08-25 04:01:15', '2016-08-25 04:01:15', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318570.aspx', '', '', '', '', ''),
('ImmInstallIME', 'function', 'Installs an IME.', 'HKL ImmInstallIME(\r\n  _In_ LPCTSTR lpszIMEFileName,\r\n  _In_ LPCTSTR lpszLayoutText\r\n);', 'lpszIMEFileName [in] --- Pointer to a null-terminated string that specifies the full path of the IME.\r\n///\r\nlpszLayoutText [in] --- Pointer to a null-terminated string that specifies the name of the IME and the associated layout text.', 'Returns the input locale identifier for the IME.', 'This function is intended to be used by IME setup applications only.', 'ImeInquire', '2016-08-25 04:03:05', '2016-08-25 04:03:05', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318571.aspx', '', '', '', '', ''),
('ImmIsIME', 'function', 'Determines if the specified input locale has an IME.', 'BOOL ImmIsIME(\r\n  _In_ HKL hKL\r\n);', 'hKL [in] --- Input locale identifier.', 'Returns a nonzero value if the specified locale has an IME, or 0 otherwise.', '', '', '2016-08-25 04:03:56', '2016-08-25 04:03:56', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318572.aspx', '', '', '', '', ''),
('ImmIsUIMessage', 'function', 'Checks for messages intended for the IME window and sends those messages to the window.', 'BOOL ImmIsUIMessage(\r\n  _In_ HWND   hWndIME,\r\n  _In_ UINT   msg,\r\n  _In_ WPARAM wParam,\r\n  _In_ LPARAM lParam\r\n);', 'hWndIME [in] --- Handle to a window belonging to the IME window class.\r\n///\r\nmsg [in] --- Message to check.\r\n///\r\nwParam [in] --- Message-specific parameter.\r\n///\r\nlParam [in] --- Message-specific parameter.', 'Returns a nonzero value if the message is processed by the IME window, or 0 otherwise.', 'An application typically uses this function to display a composition string or candidate list specified by the IME. If hWndIME is NULL, the function determines if the message is a user interface message.\r\n\r\nWindows Me/98: This function has only an ANSI version. To receive Unicode characters from a Unicode-based IME, the application should use ImmGetCompositionString.', '', '2016-08-25 04:04:57', '2016-08-25 04:04:57', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318573.aspx', '', '', '', '', ''),
('ImmLockIMC', 'function', 'The ImmLockIMC function increases the lock count for the IMC. When the IME needs to see the \r\nINPUTCONTEXT structure, it calls this function to get the pointer of the INPUTCONTEXT structure.', 'LPINPUTCONTEXT WINAPI \r\nImmLockIMC( \r\n    HIMC hIMC)', 'hIMC --- Input context handle.', 'If the function is successful, it returns a pointer to the INPUTCONTEXT structure. Otherwise, it returns NULL.', '', 'ImmUnlockIMC|INPUTCONTEXT', '2016-08-29 03:51:09', '2016-08-29 03:51:09', '', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmLockIMCC', 'function', 'The ImmLockIMCC function is used by the IME to get the pointer for the IMC component that was created as a \r\nmember of the IMC. The ImmLockIMC function increases the lock count for the IMCC.', 'LPVOID WINAPI \r\nImmLockIMCC( \r\n    HIMCC hIMCC)', 'hIMCC --- Handle of the IMC component.', 'If the function is successful, the return value is the pointer for the IMC component. Otherwise, the return value is \r\nNULL.', '', 'ImmUnlockIMCC', '2016-08-29 03:56:27', '2016-08-29 03:56:27', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmNotifyIME', 'function', 'Notifies the IME about changes to the status of the input context.', 'BOOL ImmNotifyIME(\r\n  _In_ HIMC  hIMC,\r\n  _In_ DWORD dwAction,\r\n  _In_ DWORD dwIndex,\r\n  _In_ DWORD dwValue\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\ndwAction [in] --- Notification code. This parameter can have one of the following values.\r\n\r\n[table:ImmNotifyIME_Table1]\r\n///\r\ndwIndex [in] --- Index of a candidate list. Alternatively, if dwAction is NI_COMPOSITIONSTR, this parameter can have one of the following values.\r\n\r\n[table:ImmNotifyIME_Table2]\r\n///\r\ndwValue [in] --- Index of a candidate string. The application can set this parameter or ignore it, depending on the value of the dwAction parameter.', 'Returns nonzero if successful, or 0 otherwise.', '', 'NotifyIME|NI_CHANGECANDIDATELIST|NI_CLOSECANDIDATE|NI_COMPOSITIONSTR|NI_CONTEXTUPDATED|NI_OPENCANDIDATE|NI_SELECTCANDIDATESTR|NI_SETCANDIDATE_PAGESIZE|NI_SETCANDIDATE_PAGESTART', '2016-08-25 04:06:34', '2016-08-25 04:06:34', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318574.aspx', '', '', '', '', ''),
('ImmRegisterWord', 'function', 'Registers a string with the dictionary of the IME associated with the specified input locale.', 'BOOL ImmRegisterWord(\r\n  _In_ HKL     hKL,\r\n  _In_ LPCTSTR lpszReading,\r\n  _In_ DWORD   dwStyle,\r\n  _In_ LPCTSTR lpszRegister\r\n);', 'hKL [in] --- Input locale identifier.\r\n///\r\nlpszReading [in] --- Pointer to a null-terminated reading string associated with the string to register.\r\n///\r\ndwStyle [in] --- Style of the string to register. This parameter can have any of the following values.\r\n\r\n[table:ImmRegisterWord_Table1]\r\n///\r\nlpszRegister [in] --- Pointer to the null-terminated string to register.', 'Returns a nonzero value if successful, or 0 otherwise.', 'Returns a nonzero value if successful, or 0 otherwise.\r\n\r\n<pre>\r\n#define MSIME_NOUN (IME_REGWORD_STYLE_USER_FIRST)\r\n#define MSIME_VERB (IME_REGWORD_STYLE_USER_FIRST + 1)\r\n</pre>', 'ImmUnregisterWord', '2016-08-25 04:07:48', '2016-08-25 04:07:48', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318575.aspx', '', '', '', '', ''),
('ImmReleaseContext', 'function', 'Releases the input context and unlocks the memory associated in the input context. An application must call this function for each call to the ImmGetContext function.', 'BOOL ImmReleaseContext(\r\n  _In_ HWND hWnd,\r\n  _In_ HIMC hIMC\r\n);', 'hWnd [in] --- Handle to the window for which the input context was previously retrieved.\r\n///\r\nhIMC [in] --- Handle to the input context.', 'Returns a nonzero value if successful, or 0 otherwise.', '', 'ImmGetContext', '2016-08-25 04:08:48', '2016-08-25 04:08:48', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318576.aspx', '', '', '', '', ''),
('ImmRequestMessage', 'function', 'Generates a WM_IME_REQUEST message.', 'LRESULT ImmRequestMessage(\r\n  _In_ HIMC   hIMC,\r\n  _In_ WPARAM wParam,\r\n  _In_ LPARAM lParam\r\n);', 'hIMC [in] --- Handle to the target input context.\r\n///\r\nwParam [in] --- Value of the wParam parameter for the WM_IME_REQUEST message.\r\n///\r\nlParam [in] --- Value of the lParam parameter for the WM_IME_REQUEST message.', 'Returns an operation-specific value if successful, or 0 otherwise.', 'IME must use this function instead of sending the WM_IME_REQUEST message to the application in a call to SendMessage.', 'WM_IME_REQUEST', '2016-08-25 04:09:50', '2016-08-25 04:09:50', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318577.aspx', '', '', '', '', ''),
('ImmReSizeIMCC', 'function', 'The ImmReSizeIMCC function changes the size of the component.', 'HIMCC WINAPI \r\nImmReSizeIMCC( \r\n    HIMCC hIMCC, \r\n    DWORD dwSize)', 'hIMCC --- Handle of the IMC component.\r\n///\r\ndwSize --- New size of the IMC component.', 'If the function is successful, the return value is the new HIMCC. Otherwise, the return value is NULL.', '', 'ImmCreateIMCC', '2016-08-29 03:58:25', '2016-08-29 03:58:25', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmSetCandidateWindow', 'function', 'Sets information about the candidates window.', 'BOOL ImmSetCandidateWindow(\r\n  _In_ HIMC            hIMC,\r\n  _In_ LPCANDIDATEFORM lpCandidate\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\nlpCandidate [in] --- Pointer to a CANDIDATEFORM structure that contains information about the candidates window.', 'Returns a nonzero value if successful, or 0 otherwise.', 'This function causes an IMN_SETCANDIDATEPOS command to be sent. Both the IME and the application call this function.', 'ImmGetCandidateWindow|CANDIDATEFORM|IMN_SETCANDIDATEPOS', '2016-08-25 04:10:47', '2016-08-25 04:10:47', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318578.aspx', '', '', '', '', ''),
('ImmSetCompositionFont', 'function', 'Sets the logical font to use to display characters in the composition window.', 'BOOL ImmSetCompositionFont(\r\n  _In_ HIMC      hIMC,\r\n  _In_ LPLOGFONT lplf\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\nlplf [in] --- Pointer to a LOGFONT structure containing the font information to set.', 'Returns a nonzero value if successful, or 0 otherwise.', 'This function causes a IMN_SETCOMPOSITIONFONT command to be sent to an application. Even if the application never uses the composition window, it must set the appropriate font to ensure that characters are displayed properly. This is especially true for vertical writing.', 'ImmGetCompositionFont|IMN_SETCOMPOSITIONFONT', '2016-08-25 04:11:38', '2016-08-25 04:11:38', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318579.aspx', '', '', '', '', ''),
('ImmSetCompositionString', 'function', 'Sets the characters, attributes, and clauses of the composition and reading strings.', 'BOOL ImmSetCompositionString(\r\n  _In_     HIMC   hIMC,\r\n  _In_     DWORD  dwIndex,\r\n  _In_opt_ LPVOID lpComp,\r\n  _In_     DWORD  dwCompLen,\r\n  _In_opt_ LPVOID lpRead,\r\n  _In_     DWORD  dwReadLen\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\ndwIndex [in] --- Type of information to set. This parameter can have one of the following values.\r\n\r\n[table:ImmSetCompositionString_Table1]\r\n///\r\nlpComp [in, optional] --- Pointer to a buffer containing the information to set for the composition string, as specified by the value of dwIndex.\r\n///\r\ndwCompLen [in] --- Size, in bytes, of the information buffer for the composition string, even if SCS_SETSTR is specified and the buffer contains a Unicode string.\r\n///\r\nlpRead [in, optional] --- Pointer to a buffer containing the information to set for the reading string, as specified by the value of dwIndex. The application can set this parameter to NULL.\r\n///\r\ndwReadLen [in] --- Size, in bytes, of the information buffer for the reading string, even if SCS_SETSTR is specified and the buffer contains a Unicode string.', 'Returns a nonzero value if successful, or 0 otherwise.', 'The application can set lpComp, lpRead, or both. If the application does not specify a value for lpComp, it must set this parameter to NULL and set dwCompLen to 0.\r\n\r\nWhen the application is changing attributes, all characters in a clause must have the same attribute. Converted characters must have the attribute ATTR_CONVERTED or ATTR_TARGET_CONVERTED. Unconverted characters must have the attribute ATTR_INPUT or ATTR_TARGET_NOTCONVERTED.\r\n\r\nWhen the application is changing clause information, it can change only the target clause, just affecting one boundary at a time. The target clause has the attribute ATTR_TARGET_CONVERTED or ATTR_TARGET_NOTCONVERTED.\r\n\r\nFor additional information about attributes (ATTR_* values), see Composition String.\r\n\r\nWhen the IME completes the changes, it sends a WM_IME_COMPOSITION message to the application to notify it of the changes.\r\n\r\nWindows Me/98, Windows 2000, Windows XP: The SCS_*CONVERTSTRING values are used for reconversion. They can only be used for an IME that has the SCS_CAP_SETRECONVERTSTRING property. The application uses these values as follows:\r\n\r\n1. Call ImmSetCompositionString with SCS_QUERYRECONVERTSTRING, so that IME adjusts the RECONVERTSTRING structure for the reconversion.\r\n2. Call ImmSetCompositionString with SCS_SETRECONVERTSTRING, so that IME generates a new composition string. After this, lpComp and lpRead indicate a RECONVERTSTRING structure that contains the updated composition and reading string. Use the value of lpRead only when the selected IME has SCS_CAP_MAKEREAD set.', 'ImmGetCompositionString|WM_IME_COMPOSITION|RECONVERTSTRING', '2016-08-25 04:13:21', '2016-08-25 04:13:21', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318580.aspx', '', '', '', '', ''),
('ImmSetCompositionWindow', 'function', 'Sets the position of the composition window.', 'BOOL ImmSetCompositionWindow(\r\n  _In_ HIMC              hIMC,\r\n  _In_ LPCOMPOSITIONFORM lpCompForm\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\nlpCompForm [in] --- Pointer to a COMPOSITIONFORM structure that contains the new position and other related information about the composition window.', 'Returns a nonzero value if successful, or 0 otherwise.', 'This function causes an IMN_SETCOMPOSITIONWINDOW command to be sent to the application.', 'ImmGetCompositionWindow|COMPOSITIONFORM|IMN_SETCOMPOSITIONWINDOW', '2016-08-25 04:14:32', '2016-08-25 04:14:32', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318581.aspx', '', '', '', '', ''),
('ImmSetConversionStatus', 'function', 'Sets the current conversion status.', 'BOOL ImmSetConversionStatus(\r\n  _In_ HIMC  hIMC,\r\n  _In_ DWORD fdwConversion,\r\n  _In_ DWORD fdwSentence\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\nfdwConversion [in] --- Conversion mode values. For more information, see IME Conversion Mode Values.\r\n///\r\nfdwSentence [in] --- Sentence mode values. For more information, see IME Sentence Mode Values.', 'Returns a nonzero value if successful, or 0 otherwise.', 'This function sends the IMN_SETCONVERSIONMODE and IMN_SETSENTENCEMODE commands to the application.\r\n\r\nNote  Beginning with Windows 8: By default, the input switch is set per user instead of per thread. The Microsoft IME (Japanese) respects the mode globally, and therefore ImmSetConversionStatus fails when getting focus.', 'ImmGetConversionStatus|IME Conversion Mode Values|IME Sentence Mode Values|IMN_SETCONVERSIONMODE|IMN_SETSENTENCEMODE', '2016-08-25 04:15:38', '2016-08-25 04:15:38', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318584.aspx', '', '', '', '', ''),
('ImmSetHotKey', 'function', 'The ImmSetHotKey function sets the value of the IME hot key.', 'BOOL WINAPI \r\nImmSetHotKey( \r\n    DWORD dwHotKeyID, \r\n    UINT uModifiers, \r\n    UINT uVKey, \r\n    hKL hKL)', 'dwHotKeyID --- Hot key identifier. \r\n///\r\nuModifiers --- Combination keys with the hot key. It includes ALT (MOD_ALT), CTRL (MOD_CONTROL), SHIFT \r\n(MOD_SHIFT), left-hand side (MOD_LEFT), and right-hand side (MOD_RIGHT). \r\n\r\nThe key up flag (MOD_ON_KEYUP) indicates that the hot key is effective when the key is up. The modifier \r\nignore flag (MOD_IGNORE_ALL_MODIFIER) indicates that the combination of modifiers is ignored in hot key matching. \r\n///\r\nuVKey --- Virtual key code of this hot key. \r\n///\r\nhKL --- HKL of the IME. If this parameter is specified, this hot key can switch to the IME with this HKL.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', 'This function is called by the Control Panel. For a key that does not indicate a specific keyboard hand side, the \r\nuModifiers should specify both sides (MOD_LEFT|MODE_RIGHT).', 'ImmGetHotKey', '2016-08-29 04:03:30', '2016-08-29 04:03:30', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmSetOpenStatus', 'function', 'Opens or closes the IME.', 'BOOL ImmSetOpenStatus(\r\n  _In_ HIMC hIMC,\r\n  _In_ BOOL fOpen\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\nfOpen [in] --- TRUE if the IME is open, or FALSE if it is closed.', 'Returns a nonzero value if successful, or 0 otherwise.', 'This function causes an IMN_SETOPENSTATUS command to be sent to the application.', 'ImmGetOpenStatus|IMN_SETOPENSTATUS', '2016-08-25 04:16:32', '2016-08-25 04:16:32', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318586.aspx', '', '', '', '', ''),
('ImmSetStatusWindowPos', 'function', 'Sets the position of the status window.', 'BOOL ImmSetStatusWindowPos(\r\n  _In_ HIMC    hIMC,\r\n  _In_ LPPOINT lpptPos\r\n);', 'hIMC [in] --- Handle to the input context.\r\n///\r\nlpptPos [in] --- Pointer to a POINT structure containing the new position of the status window, in screen coordinates relative to the upper left corner of the display screen.', 'Returns a nonzero value if successful, or 0 otherwise.', 'This function causes an IMN_SETSTATUSWINDOWPOS command to be sent to the application.', 'ImmGetStatusWindowPos|IMN_SETSTATUSWINDOWPOS', '2016-08-25 04:17:32', '2016-08-25 04:17:32', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318587.aspx', '', '', '', '', ''),
('ImmShowSoftKeyboard', 'function', 'The ImmShowSoftKeyboard function shows or hides the given soft keyboard.', 'BOOL WINAPI ImmShowSoftKeyboard( \r\n    HWND hSoftKbdWnd, \r\n    int nCmdShow)', 'hSoftKbdWnd --- Window handle of the soft keyboard. \r\n///\r\nnCmdShow --- Shows the state of the window. The following values are provided.\r\n\r\n[table:ImmShowSoftKeyboard_Table1]', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'ImmCreateSoftKeyboard', '2016-08-29 04:07:56', '2016-08-29 04:07:56', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmSimulateHotKey', 'function', 'Simulates the specified IME hot key, causing the same response as if the user presses the hot key in the specified window.', 'BOOL ImmSimulateHotKey(\r\n  _In_ HWND  hWnd,\r\n  _In_ DWORD dwHotKeyID\r\n);', 'hWnd [in] --- Handle to the window.\r\n///\r\ndwHotKeyID [in] --- Identifier of the IME hot key. For more information, see IME Hot Key Identifiers.', 'Returns a nonzero value if successful, or 0 otherwise.', '', 'IME Hot Key Identifiers', '2016-08-25 04:18:13', '2016-08-25 04:18:13', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318589.aspx', '', '', '', '', ''),
('ImmUnlockIMC', 'function', 'The ImmUnlockIMC function decrements the lock count for the IMC.', 'BOOL WINAPI \r\nImmUnlockIMC( \r\n    HIMC hIMC)', 'hIMC --- Input context handle.', 'If the lock count of the IMC is decremeted to zero, the return value is FALSE. Otherwise, the return value is TRUE.', '', 'ImmLockIMC', '2016-08-29 03:52:13', '2016-08-29 03:52:13', '<imm.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmUnlockIMCC', 'function', 'The ImmUnlockIMC function decrements the lock count for the IMCC.', 'BOOL WINAPI \r\nImmUnlockIMCC( \r\n    HIMCC hIMCC)', 'hIMCC --- Handle of the IMC component.', 'If the lock count of the IMCC is decremeted to zero, the return value is FALSE. Otherwise, the return value is \r\nTRUE.', '', 'ImmLockIMCC', '2016-08-29 03:57:25', '2016-08-29 03:57:25', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('ImmUnregisterWord', 'function', 'Removes a register string from the dictionary of the IME associated with the specified input locale.', 'BOOL ImmUnregisterWord(\r\n  _In_ HKL     hKL,\r\n  _In_ LPCTSTR lpszReading,\r\n  _In_ DWORD   dwStyle,\r\n  _In_ LPCTSTR lpszUnregister\r\n);', 'hKL [in] --- Input locale identifier.\r\n///\r\nlpszReading [in] --- Pointer to a null-terminated reading string associated with the string to remove.\r\n///\r\ndwStyle [in] --- Style of the register string. This parameter can have any of the following values.\r\n\r\n[table:ImmUnregisterWord_Table1]\r\n///\r\nlpszUnregister [in] --- Pointer to a null-terminated string specifying the register string to remove.', 'Returns a nonzero value if successful, or 0 otherwise.', '', 'ImmRegisterWord', '2016-08-25 04:19:13', '2016-08-25 04:19:13', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318591.aspx', '', '', '', '', ''),
('IMN_CHANGECANDIDATE', 'notification code', 'Notifies the application when an IME is about to change the content of the candidate window. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_CHANGECANDIDATE', 'wParam --- Set to IMN_CHANGECANDIDATE.\r\n///\r\nlParam --- Candidate list flag. Each bit corresponds to a candidate list: bit 0 to the first list, bit 1 to the second list, and so on. If a specified bit is 1, the corresponding candidate window is about to be changed.', 'This command has no return value.', 'An application should process this command if it displays candidates itself.\r\n\r\nThe IME window changes the appearance of the candidate window when it processes this command. An application can get information about the system window with the ImmGetCandidateListCount and ImmGetCandidateList.', 'WM_IME_NOTIFY|ImmGetCandidateListCount|ImmGetCandidateList', '2016-08-25 04:33:41', '2016-08-25 04:33:41', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318593.aspx', '', '', '', '', ''),
('IMN_CLOSECANDIDATE', 'notification code', 'Notifies an application when an IME is about to close the candidates window. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_CLOSECANDIDATE', 'wParam --- Set to IMN_CLOSECANDIDATE.\r\n///\r\nlParam --- Candidate list flag. Each bit corresponds to a candidate list: bit 0 to the first list, bit 1 to the second, and so on. If a specified bit is 1, the corresponding candidates window is about to be closed.', 'This command has no return value.', 'An application should process this command if it displays candidates itself.\r\n\r\nBy default, the IME window destroys a candidate window when it processes this command.', 'WM_IME_NOTIFY', '2016-08-25 04:34:32', '2016-08-25 04:34:32', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318595.aspx', '', '', '', '', ''),
('IMN_CLOSESTATUSWINDOW', 'notification code', 'Notifies an application when an IME is about to close the status window. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_CLOSESTATUSWINDOW', 'wParam --- Set to IMN_CLOSESTATUSWINDOW.\r\n///\r\nlParam --- Not used.', 'This command has no return value.', 'An application should process this command if it displays the status window for the IME. \r\n\r\nThe IME window closes the status window when it processes this command.', 'WM_IME_NOTIFY', '2016-08-25 04:35:17', '2016-08-25 04:35:17', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318597.aspx', '', '', '', '', ''),
('IMN_GUIDELINE', 'notification code', 'Notifies an application when an IME is about to show an error message or other information. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_GUIDELINE', 'wParam --- Set to IMN_GUIDELINE.\r\n///\r\nlParam --- Not used.', 'This command has no return value.', 'An application processes this command by calling the ImmGetGuideLine function to retrieve the error message or information from the IME.\r\n\r\nThe IME window displays the error message or information string in an information window.', 'WM_IME_NOTIFY|ImmGetGuideLine', '2016-08-25 04:36:12', '2016-08-25 04:36:12', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318599.aspx', '', '', '', '', ''),
('IMN_OPENCANDIDATE', 'notification code', 'Notifies an application when an IME is about to open the candidate window. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_OPENCANDIDATE', 'wParam --- Set to IMN_OPENCANDIDATE.\r\n///\r\nlParam --- Candidate list flag. Each bit corresponds to a candidate list: bit 0 to the first list, bit 1 to the second, and so on. If a specified bit is 1, the corresponding candidate window is about to be opened.', 'This command has no return value.', 'An application should process this command if it displays candidates itself. The application can retrieve a list of candidates to display by using the ImmGetCandidateList function.\r\n\r\nBy default, the IME window creates a candidate window when it processes this command.', 'WM_IME_NOTIFY|ImmGetCandidateList', '2016-08-25 04:37:07', '2016-08-25 04:37:07', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318600.aspx', '', '', '', '', ''),
('IMN_OPENSTATUSWINDOW', 'notification code', 'Notifies an application when an IME is about to create the status window. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_OPENSTATUSWINDOW', 'wParam --- Set to IMN_OPENSTATUSWINDOW.\r\n///\r\nlParam --- Not used.', 'This command has no return value.', 'An application processes this command to display the status window for the IME by itself.\r\n\r\nThe IME window creates a status window when it processes this command and sets the strings to display in the window into the input context. Applications can get information about the status window by using the ImmGetConversionStatus function.', 'WM_IME_NOTIFY|ImmGetConversionStatus', '2016-08-25 04:38:04', '2016-08-25 04:38:04', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318603.aspx', '', '', '', '', ''),
('IMN_SETCANDIDATEPOS', 'notification code', 'Notifies an application when candidate processing has finished and the IME is about to move the candidate window. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_SETCANDIDATEPOS', 'wParam --- Set to IMN_SETCANDIDATEPOS.\r\n///\r\nlParam --- Candidate list flag. Each bit corresponds to a candidate list: bit 0 to the first list, bit 1 to the second, and so on. If a specified bit is 1, the corresponding candidate window is about to be moved.', 'This command has no return value.', 'An application should process this command if it displays the candidate window itself.\r\n\r\nThe IME window moves the candidate window when it processes this command.', 'WM_IME_NOTIFY', '2016-08-25 04:39:03', '2016-08-25 04:39:03', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318605.aspx', '', '', '', '', ''),
('IMN_SETCOMPOSITIONFONT', 'notification code', 'Notifies an application when the font of the input context is updated. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_SETCOMPOSITIONFONT', 'wParam --- Set to IMN_SETCOMPOSITIONFONT.\r\n///\r\nlParam --- Not used.', 'This command has no return value.', 'The application can get information about the font by using the ImmGetCompositionFont function. The IME window subsequently uses the font to draw the composition string.', 'WM_IME_NOTIFY', '2016-08-25 04:39:59', '2016-08-25 04:39:59', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318608.aspx', '', '', '', '', ''),
('IMN_SETCOMPOSITIONWINDOW', 'notification code', 'Notifies an application when the style or position of the composition window is updated. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_SETCOMPOSITIONWINDOW', 'wParam --- Set to IMN_SETCOMPOSITIONWINDOW.\r\n///\r\nlParam --- Not used.', 'This command has no return value.', 'The application can get information about the composition form by using the IMC_GETCOMPOSITIONWINDOW command.', 'WM_IME_NOTIFY', '2016-08-25 04:40:50', '2016-08-25 04:40:50', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318610.aspx', '', '', '', '', ''),
('IMN_SETCONVERSIONMODE', 'notification code', 'Notifies an application when the conversion mode of the input context is updated. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_SETCONVERSIONMODE', 'wParam --- Set to IMN_SETCONVERSIONMODE.\r\n///\r\nlParam --- Not used.', 'This command has no return value.', 'The application can get information about the conversion mode by using the ImmGetConversionStatus function.', 'WM_IME_NOTIFY', '2016-08-25 04:41:38', '2016-08-25 04:41:38', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318613.aspx', '', '', '', '', ''),
('IMN_SETOPENSTATUS', 'notification code', 'Notifies an application when the open status of the input context is updated. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_SETOPENSTATUS', 'wParam --- Set to IMN_SETOPENSTATUS.\r\n///\r\nlParam --- Not used.', 'This command has no return value.', 'The application can get information about the open status by using the ImmGetOpenStatus function.', 'WM_IME_NOTIFY', '2016-08-25 04:42:28', '2016-08-25 04:42:28', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318614.aspx', '', '', '', '', ''),
('IMN_SETSENTENCEMODE', 'notification code', 'Notifies an application when the sentence mode of the input context is updated. The application receives this command through the WM_IME_NOTIFY message with parameter settings as shown below.', 'IMN_SETSENTENCEMODE', 'wParam --- Set to IMN_SETSENTENCEMODE.\r\n///\r\nlParam --- Not used.', 'This command has no return value.', 'The application can get information about the sentence mode by using the ImmGetConversionStatus function.', 'WM_IME_NOTIFY|ImmGetConversionStatus', '2016-08-25 04:43:17', '2016-08-25 04:43:17', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318617.aspx', '', '', '', '', ''),
('IMN_SETSTATUSWINDOWPOS', 'notification code', 'Notifies an application when the status window position in the input context is updated. The application receives this command through the WM_IME_NOTIFY message with parameter settings as follows.', 'IMN_SETSTATUSWINDOWPOS', 'wParam --- Set to IMN_SETSTATUSWINDOWPOS.\r\n///\r\nlParam --- Not used.', 'This command has no return value.', 'The application can get information about the status window position by using the IMC_GETSTATUSWINDOWPOS command.', 'WM_IME_NOTIFY', '2016-08-25 04:44:04', '2016-08-25 04:44:04', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318618.aspx', '', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('IMR_CANDIDATEWINDOW', 'notification code', 'Notifies an application when a selected IME needs information about the candidate window. The application receives this command through the WM_IME_REQUEST message with parameter settings as shown below.', 'LRESULT IMR_CANDIDATEWINDOW', 'wParam --- Set to IMR_CANDIDATEWINDOW.\r\n///\r\nlParam --- Pointer to a buffer containing a CANDIDATEFORM structure. Its dwIndex member contains the index to the candidate window referenced.', 'Returns a nonzero value if the application fills in the CANDIDATEFORM structure. Otherwise, the command returns 0.', 'This command can be sent by the IME to a window that has cleared the ISC_SHOWUICANDIDATEWINDOW flag in the WM_IME_SETCONTEXT message handler.', 'WM_IME_REQUEST|CANDIDATEFORM|WM_IME_SETCONTEXT', '2016-08-25 04:44:59', '2016-08-25 04:44:59', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318621.aspx', '', '', '', '', ''),
('IMR_COMPOSITIONFONT', 'notification code', 'Notifies an application when a selected IME needs information about the font used by the composition window. The application receives this command through the WM_IME_REQUEST message with parameters as shown below.', 'LRESULT IMR_COMPOSITIONFONT', 'wParam --- Set to IMR_COMPOSITIONFONT.\r\n///\r\nlParam --- Pointer to a buffer containing a LOGFONT structure. The application fills in the values for the current composition window.', 'Returns a nonzero value if the application fills in the LOGFONT structure. Otherwise, the command returns 0.', 'This command can be sent by the IME to a window that cleared the ISC_SHOWUICOMPOSITIONWINDOW flag in the WM_IME_SETCONTEXT message handler.', 'WM_IME_REQUEST|WM_IME_SETCONTEXT', '2016-08-25 04:45:55', '2016-08-25 04:45:55', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318623.aspx', '', '', '', '', ''),
('IMR_COMPOSITIONWINDOW', 'notification code', 'Notifies an application when a selected IME needs information about the composition window. The application receives this command through the WM_IME_REQUEST message with parameters set as shown below.', 'LRESULT IMR_COMPOSITIONWINDOW', 'wParam --- Set to IMR_COMPOSITIONWINDOW.\r\n///\r\nlParam --- Pointer to a buffer containing a COMPOSITIONFORM structure.', 'Returns a nonzero value if the application fills in the COMPOSITIONFORM structure. Otherwise, the command returns 0.', 'This command can be sent by the IME to a window that has cleared the ISC_SHOWUICOMPOSITIONWINDOW flag in the WM_IME_SETCONTEXT message handler.', 'WM_IME_REQUEST|COMPOSITIONFORM|WM_IME_SETCONTEXT', '2016-08-25 04:46:50', '2016-08-25 04:46:50', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318626.aspx', '', '', '', '', ''),
('IMR_CONFIRMRECONVERTSTRING', 'notification code', 'Notifies an application when the IME needs to change the RECONVERTSTRING structure. The application receives this command through the WM_IME_REQUEST message with parameter settings as shown below.', 'LRESULT IMR_CONFIRMRECONVERTSTRING', 'wParam --- Set to IMR_CONFIRMRECONVERTSTRING.\r\n///\r\nlParam --- Pointer to a RECONVERTSTRING structure from the IME. For more information, see the Remarks section.', 'Returns a nonzero value if the application accepts the changed RECONVERTSTRING structure. Otherwise, the command returns 0 and the IME uses the original RECONVERTSTRING structure.', 'The application fills in the RECONVERTSTRING structure upon receiving the IMR_RECONVERTSTRING command.\r\n\r\nAfter the application has handled IMR_RECONVERTSTRING, the IME might or might not adjust the RECONVERTSTRING structure. The IME sends WM_IME_REQUEST with IMR_CONFIRMRECONVERTSTRING to confirm the changes to the RECONVERTSTRING structure. If the application returns TRUE for IMR_CONFIRMRECONVERTSTRING, the IME generates a new composition string based on the RECONVERTSTRING structure for the IMR_CONFIRMRECONVERTSTRING command. If the application returns FALSE for IMR_CONFIRMRECONVERTSTRING, the IME generates a new composition string based on the original RECONVERTSTRING structure specified by the application in the IMR_RECONVERTSTRING command.', 'WM_IME_REQUEST|RECONVERTSTRING', '2016-08-25 04:47:48', '2016-08-25 04:47:48', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318629.aspx', '', '', '', '', ''),
('IMR_DOCUMENTFEED', 'notification code', 'Notifies an application when the selected IME needs the converted string from the application. The application receives this command through the WM_IME_REQUEST message with parameters set as shown below.', 'LRESULT IMR_DOCUMENTFEED', 'wParam --- Set to IMR_DOCUMENTFEED.\r\n///\r\nlParam --- Pointer to a buffer to contain the RECONVERTSTRING structure.', 'Returns the current reconversion string structure. If lParam is set to NULL, the application returns the required size for the buffer to hold the structure. The command returns 0 if it does not succeed.', 'The IME caches converted strings for higher conversion accuracy. One caching limitation of the IME is that it loses the converted string under the following circumstances:\r\n\r\n * The caret position for the application is moved by a key, for example, a cursor key.\r\n * The caret position for the application is moved by the mouse.\r\n * A new document is opened.\r\n\r\nWith the IMR_DOCUMENTFEED command, the IME can refresh its cached strings any time. Use of this command improves conversion accuracy.', 'WM_IME_REQUEST|RECONVERTSTRING', '2016-08-25 04:48:52', '2016-08-25 04:48:52', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318632.aspx', '', '', '', '', ''),
('IMR_QUERYCHARPOSITION', 'notification code', 'Notifies an application when the selected IME needs information about the coordinates of a character in the composition string. The application receives this command through the WM_IME_REQUEST message with parameter settings as shown below.', 'LRESULT IMR_QUERYCHARPOSITION', 'wParam --- Set to IMR_QUERYCHARPOSITION.\r\n///\r\nlParam --- Pointer to an IMECHARPOSITION structure that contains the position of the character in the composition window.', 'Returns a nonzero value if the application fills the IMECHARPOSITION structure. Otherwise, the command returns 0.', 'An application that draws the composition string itself, instead of relying on the IME, is responsible for filling in all the members of the IMECHARPOSITION structure. Otherwise, the application should pass the command to DefWindowProc or ImmIsUIMessage if it has its own IME user interface window.', 'WM_IME_REQUEST|IMECHARPOSITION|DefWindowProc|ImmIsUIMessage', '2016-08-25 04:49:50', '2016-08-25 04:49:50', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318634.aspx', '', '', '', '', ''),
('IMR_RECONVERTSTRING', 'notification code', 'Notifies an application when a selected IME needs a string for reconversion. The application receives this command through the WM_IME_REQUEST message with parameter settings as shown below.', 'LRESULT IMR_RECONVERTSTRING', 'wParam --- Set to IMR_RECONVERTSTRING.\r\n///\r\nlParam --- Pointer to a buffer containing the RECONVERTSTRING structure and strings.', 'Returns the current reconversion string structure. If lParam is set to NULL, the application returns the size for the buffer required to hold the structure. The command returns 0 if it does not succeed.', '', 'WM_IME_REQUEST|RECONVERTSTRING', '2016-08-25 04:50:39', '2016-08-25 04:50:39', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318637.aspx', '', '', '', '', ''),
('Indicator Manager for IME', '', 'By using a set of messages defined in Windows 98 and Windows 2000, an IME can change the icon and ToolTip \r\nstring for the System Pen icon on the system task bar. \r\n\r\n * Indicator Window\r\n * Indicator Messages', '', '', '', '', 'Indicator Window|Indicator Messages', '2016-09-10 09:17:07', '2016-09-10 09:17:07', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Indicator Messages', '', 'IMEs can send the following messages to the Indicator window to perform different tasks:\r\n\r\n * INDICM_SETIMEICON \r\n * INDICM_SETIMETOOLTIPS \r\n * INDICM_REMOVEDEFAULTMENUITEMS', '', '', '', '', 'Indicator Window|INDICM_SETIMEICON|INDICM_SETIMETOOLTIPS|INDICM_REMOVEDEFAULTMENUITEMS', '2016-09-10 09:19:17', '2016-09-10 09:19:17', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Indicator Window', '', 'An IME can get the window handle of the indicator by using FindWindow with INDICATOR_CLASS.', '', '', '', 'Due to the internal design requirement in the task bar manager, the IME must use PostMessage for \r\nINDICM_xxx messages.', 'PostMessage', '2016-09-10 09:18:11', '2016-09-10 09:18:11', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('INDICM_REMOVEDEFAULTMENUITEMS', 'message', 'This message is sent to the Indicator window when the IME wants to remove the default menu items of the System \r\nPen icon.', 'INDICM_REMOVEDEFAULTMENUITEMS \r\nwValue = wParam; \r\nhKL = lParam;', 'wValue --- wValue is a combination of the following bits.\r\n\r\n[table:INDICM_REMOVEDEFAULTMENUITEMS_Table1]\r\n\r\nIf wValue is zero, all default menu items are restored.\r\n///\r\nhKL --- that is the sender IME.', 'A nonzero indicates failure. Otherwise, zero is returned.', 'Due to the internal design requirement in the task bar manager, the IME must use PostMessage for INDICM_xxx \r\nmessages.', 'PostMessage', '2016-08-29 05:48:04', '2016-08-29 05:48:04', '', '', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('INDICM_SETIMEICON', 'message', 'This message is sent to the Indicator window when the IME wants to change the icon for System Pen icon. This \r\nmessage can be accepted when the selected hKL of the focused window is the same as the sender IME.', 'INDICM_SETIMEICON \r\nnIconIndex = wParam; \r\nhKL = lParam;', 'nIconIdex --- Index for the icon resource of the IME file. If this value is (-1), the Indicator restores the original icon provided by the system.\r\n///\r\nhKL --- that is the sender IME.', 'A nonzero value indicates failure. Otherwise, zero is returned.', 'Due to the internal design requirement in the task bar manager, the IME must use PostMessage for INDICM_xxx \r\nmessages.', 'PostMessage', '2016-08-29 05:45:48', '2016-08-29 05:45:48', '', '', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('INDICM_SETIMETOOLTIPS', 'message', 'This message is sent to the Indicator window when the IME wants to change the Tooltip string for the System Pen \r\nicon. This message can be accepted when the selected hKL of the focused window is the same as the sender \r\nIME.', 'INDICM_SETIMETOOLTIPS \r\nhAtom = wParam; \r\nhKL = lParam;', 'hAtom --- Global ATOM value for the Tooltip string. If this value is (-1), the Indicator restores the original tips provided by the system. \r\n///\r\nhKL --- that is the sender IME.', 'A nonzero indicates failure. Otherwise, zero is returned.', 'Due to the internal design requirement in the task bar manager, the IME must use PostMessage for INDICM_xxx \r\nmessages. The global ATOM must be retrieved by GlobalAddAtom or GlobalFindAtom.', 'PostMessage', '2016-08-29 05:46:46', '2016-08-29 05:46:46', '', '', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('Input Method Editor Constants', '', 'The following constants are used by the Input Method Editor (IME) functions and messages.\r\n\r\nIME Conversion Mode Values provides a reference for the values that are used with the  ImmGetConversionStatus and  ImmSetConversionStatus functions.\r\n\r\n IME Composition String Values provides a reference for the values that are used with the  ImmGetCompositionString function and the  WM_IME_COMPOSITION message.\r\n\r\nIME Hot Key Identifiers provides a reference for the identifiers that are used with the  ImmSimulateHotKey function\r\n\r\nIME Sentence Mode Values provides a reference for the values that are used with the  ImmGetConversionStatus and  ImmSetConversionStatus functions.\r\n\r\nIME Escapes provides a reference for the values that are used with the  ImmEscape function.', '', '', '', '', 'IME Conversion Mode Values|IME Composition String Values|IME Hot Key Identifiers|IME Sentence Mode Values|IME Escapes', '2016-09-03 04:07:00', '2016-09-03 04:07:00', '', '', 'https://msdn.microsoft.com/ja-jp/vstudio/ee490952', '', '', '', '', ''),
('INPUTCONTEXT', 'structure', 'Contains the input context information.', 'typedef struct {\r\n  HWND            hWnd;\r\n  BOOL            fOpen;\r\n  POINT           ptStatusWndPos;\r\n  POINT           ptSoftKbdPos;\r\n  DWORD           fdwConversion;\r\n  DWORD           fdwSentence;\r\n  union {\r\n    LOGFONTA A;\r\n    LOGFONTW W;\r\n  } lfFont;\r\n  COMPOSITIONFORM cfCompForm;\r\n  CANDIDATEFORM   cfCandForm[4];\r\n  HIMCC           hCompStr;\r\n  HIMCC           hCandInfo;\r\n  HIMCC           hGuideLine;\r\n  HIMCC           hPrivate;\r\n  DWORD           dwNumMsgBuf;\r\n  HIMCC           hMsgBuf;\r\n  DWORD           fdwInit;\r\n  DWORD           dwReserve[3];\r\n} INPUTCONTEXT;', 'hWnd --- Handle to the window that uses the input context. \r\n///\r\nfOpen --- BOOL value that indicates the status of the Active IME. If TRUE, the Active IME is opened. Otherwise the Active IME is closed. \r\n///\r\nptStatusWndPos --- POINT structure that contains the position of the status window. \r\n///\r\nptSoftKbdPos --- POINT structure that contains the position of the soft keyboard. \r\n///\r\nfdwConversion --- Unsigned long integer value that contains the conversion mode used by the Active IME composition engine. \r\n///\r\nfdwSentence --- Unsigned long integer value that contains the sentence mode used by the Active IME composition engine. \r\n///\r\nlfFont --- LOGFONT structure used by the Active IME composition engine. \r\n\r\n[table:INPUTCONTEXT_Table1]\r\n///\r\ncfCompForm --- COMPOSITIONFORM structure used by the Active IME user interface to create the composition window.\r\n///\r\ncfCandForm --- CANDIDATEFORM structures used by the Active IME user interface to create the candidate windows. This input method context supports four candidate forms. \r\n///\r\nhCompStr --- Handle that points to the COMPOSITIONSTRING structure. \r\n///\r\nhCandInfo --- Handle to a buffer that contains the CANDIDATEINFO and CANDIDATELIST structures. \r\n///\r\nhGuideLine --- Handle to a buffer that contains the GUIDELINE structure. \r\n///\r\nhPrivate --- Handle to a buffer used by the Active IME for its private data area. \r\n///\r\ndwNumMsgBuf --- Unsigned long integer value that contains the number of messages stored in hMsgBuf. \r\n///\r\nhMsgBuf --- Handle to the buffer that stores the messages. \r\n///\r\nfdwInit --- Unsigned long integer value that contains the initialize flag. \r\n///\r\ndwReserve --- Reserved. Must be zero.', '', '', 'COMPOSITIONFORM|CANDIDATEFORM|COMPOSITIONSTRING|CANDIDATEINFO|CANDIDATELIST|GUIDELINE', '2016-08-28 05:56:28', '2016-08-28 05:56:28', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741229.aspx', '', '', '', '', ''),
('InSendMessage', 'function', 'Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different process) by a call to the SendMessage function.\r\n\r\nTo obtain additional information about how the message was sent, use the InSendMessageEx function.', 'BOOL WINAPI InSendMessage(void);', 'This function has no parameters.', 'If the window procedure is processing a message sent to it from another thread using the SendMessage function, the return value is nonzero.\r\n\r\nIf the window procedure is not processing a message sent to it from another thread using the SendMessage function, the return value is zero.', '', 'InSendMessageEx|SendMessage', '2016-08-25 05:13:20', '2016-08-25 05:13:20', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644941.aspx', '', '', '', '', ''),
('Key Status', '', 'While processing a keyboard message, an application may need to determine the status of another key besides the one that generated the current message. For example, a word-processing application that allows the user to press SHIFT+END to select a block of text must check the status of the SHIFT key whenever it receives a keystroke message from the END key. The application can use the GetKeyState function to determine the status of a virtual key at the time the current message was generated; it can use the GetAsyncKeyState function to retrieve the current status of a virtual key.\r\n\r\nThe keyboard layout maintains a list of names. The name of a key that produces a single character is the same as the character produced by the key. The name of a noncharacter key such as TAB and ENTER is stored as a character string. An application can retrieve the name of any key from the device driver by calling the GetKeyNameText function.', '', '', '', '', '', '2016-09-11 13:06:06', '2016-09-11 13:06:06', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Keyboard Focus and Activation', '', 'The system posts keyboard messages to the message queue of the foreground thread that created the window with the keyboard focus. The keyboard focus is a temporary property of a window. The system shares the keyboard among all windows on the display by shifting the keyboard focus, at the user\'s direction, from one window to another. The window that has the keyboard focus receives (from the message queue of the thread that created it) all keyboard messages until the focus changes to a different window. \r\n\r\nA thread can call the GetFocus function to determine which of its windows (if any) currently has the keyboard focus. A thread can give the keyboard focus to one of its windows by calling the SetFocus function. When the keyboard focus changes from one window to another, the system sends a WM_KILLFOCUS message to the window that has lost the focus, and then sends a WM_SETFOCUS message to the window that has gained the focus. \r\n\r\nThe concept of keyboard focus is related to that of the active window. The active window is the top-level window the user is currently working with. The window with the keyboard focus is either the active window, or a child window of the active window. To help the user identify the active window, the system places it at the top of the Z order and highlights its title bar (if it has one) and border. \r\n\r\nThe user can activate a top-level window by clicking it, selecting it using the ALT+TAB or ALT+ESC key combination, or selecting it from the Task List. A thread can activate a top-level window by using the SetActiveWindow function. It can determine whether a top-level window it created is active by using the GetActiveWindow function.\r\n\r\nWhen one window is deactivated and another activated, the system sends the WM_ACTIVATE message. The low-order word of the wParam parameter is zero if the window is being deactivated and nonzero if it is being activated. When the default window procedure receives the WM_ACTIVATE message, it sets the keyboard focus to the active window.\r\n\r\nTo block keyboard and mouse input events from reaching applications, use BlockInput. Note, the BlockInput function will not interfere with the asynchronous keyboard input-state table. This means that calling the SendInput function while input is blocked will change the asynchronous keyboard input-state table.', '', '', '', '', '', '2016-09-11 12:54:52', '2016-09-11 12:54:52', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Keyboard Input Model', '', 'The system provides device-independent keyboard support for applications by installing a keyboard device driver appropriate for the current keyboard. The system provides language-independent keyboard support by using the language-specific keyboard layout currently selected by the user or the application. The keyboard device driver receives scan codes from the keyboard, which are sent to the keyboard layout where they are translated into messages and posted to the appropriate windows in your application. \r\n\r\nAssigned to each key on a keyboard is a unique value called a scan code, a device-dependent identifier for the key on the keyboard. A keyboard generates two scan codes when the user types a key—one when the user presses the key and another when the user releases the key. \r\n\r\nThe keyboard device driver interprets a scan code and translates (maps) it to a virtual-key code, a device-independent value defined by the system that identifies the purpose of a key. After translating a scan code, the keyboard layout creates a message that includes the scan code, the virtual-key code, and other information about the keystroke, and then places the message in the system message queue. The system removes the message from the system message queue and posts it to the message queue of the appropriate thread. Eventually, the thread\'s message loop removes the message and passes it to the appropriate window procedure for processing. The following figure illustrates the keyboard input model.', '', '', '', '', '', '2016-09-11 12:53:41', '2016-09-11 12:53:41', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Keyboard Keys for Browsing and Other Functions', '', 'Windows provides support for keyboards with special keys for browser functions, media functions, application launching, and power management. The WM_APPCOMMAND supports the extra keyboard keys. In addition, the ShellProc function is modified to support the extra keyboard keys.\r\n\r\nIt is unlikely that a child window in a component application will be able to directly implement commands for these extra keyboard keys. So when one of these keys is pressed, DefWindowProc will send a WM_APPCOMMAND message to a window. DefWindowProc will also bubble the WM_APPCOMMAND message to its parent window. This is similar to the way context menus are invoked with the right mouse button, which is that DefWindowProc sends a WM_CONTEXTMENU message on a right button click, and bubbles it to its parent. Additionally, if DefWindowProc receives a WM_APPCOMMAND message for a top-level window, it will call a shell hook with code HSHELL_APPCOMMAND.\r\n\r\nWindows also supports the Microsoft IntelliMouse Explorer, which is a mouse with five buttons. The two extra buttons support forward and backward browser navigation. For more information, see XBUTTONs.', '', '', '', '', '', '2016-09-11 13:08:10', '2016-09-11 13:08:10', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Keystroke and Character Translations', '', 'The system includes several special purpose functions that translate scan codes, character codes, and virtual-key codes provided by various keystroke messages. These functions include MapVirtualKey, ToAscii, ToUnicode, and VkKeyScan.\r\n\r\nIn addition, Microsoft Rich Edit 3.0 supports the HexToUnicode IME, which allows a user to convert between hexadecimal and Unicode characters by using hot keys. This means that when Microsoft Rich Edit 3.0 is incorporated into an application, the application will inherit the features of the HexToUnicode IME.', '', '', '', '', '', '2016-09-11 13:06:44', '2016-09-11 13:06:44', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Keystroke Message Flags', '', 'The lParam parameter of a keystroke message contains additional information about the keystroke that generated the message. This information includes the repeat count, the scan code, the extended-key flag, the context code, the previous key-state flag, and the transition-state flag. The following illustration shows the locations of these flags and values in the lParam parameter.\r\n\r\nAn application can use the following values to manipulate the keystroke flags.\r\n\r\n[table:Keystroke Message Flags_Table1]', '', '', '', '', '', '2016-09-11 12:58:53', '2016-09-11 12:58:53', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Keystroke Messages', '', 'Pressing a key causes a WM_KEYDOWN or WM_SYSKEYDOWN message to be placed in the thread message queue attached to the window that has the keyboard focus. Releasing a key causes a WM_KEYUP or WM_SYSKEYUP message to be placed in the queue.\r\n\r\nKey-up and key-down messages typically occur in pairs, but if the user holds down a key long enough to start the keyboard\'s automatic repeat feature, the system generates a number of WM_KEYDOWN or WM_SYSKEYDOWN messages in a row. It then generates a single WM_KEYUP or WM_SYSKEYUP message when the user releases the key.\r\n\r\nThis section covers the following topics:\r\n\r\n * System and Nonsystem Keystrokes\r\n * Virtual-Key Codes Described\r\n * Keystroke Message Flags', '', '', '', '', '', '2016-09-11 12:55:59', '2016-09-11 12:55:59', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('LANGIDFROMLCID', 'macro', 'Retrieves a language identifier from a locale identifier.', 'WORD LANGIDFROMLCID(\r\n   LCID lcid\r\n);', 'lcid --- Locale identifier. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.\r\n\r\n * LOCALE_INVARIANT \r\n * LOCALE_SYSTEM_DEFAULT \r\n * LOCALE_USER_DEFAULT \r\n\r\nWindows Vista: The following custom locale identifiers are also supported.\r\n\r\n * LOCALE_CUSTOM_DEFAULT \r\n * LOCALE_CUSTOM_UI_DEFAULT \r\n * LOCALE_CUSTOM_UNSPECIFIED', 'Returns the language identifier.', '', 'MAKELANGID|MAKELCID|PRIMARYLANGID|SUBLANGID', '2016-09-18 05:14:00', '2016-09-18 05:14:00', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318689.aspx', '', '', '', '', ''),
('Languages, Locales, and Keyboard Layouts', '', 'A language is a natural language, such as English, French, and Japanese. A sublanguage is a variant of a natural language that is spoken in a specific geographical region, such as the English sublanguages spoken in the United Kingdom and the United States. Applications use values, called language identifiers, to uniquely identify languages and sublanguages.\r\n\r\nApplications typically use locales to set the language in which input and output is processed. Setting the locale for the keyboard, for example, affects the character values generated by the keyboard. Setting the locale for the display or printer affects the glyphs displayed or printed. Applications set the locale for a keyboard by loading and using keyboard layouts. They set the locale for a display or printer by selecting a font that supports the specified locale.\r\n\r\nA keyboard layout not only specifies the physical position of the keys on the keyboard but also determines the character values generated by pressing those keys. Each layout identifies the current input language and determines which character values are generated by which keys and key combinations.\r\n\r\nEvery keyboard layout has a corresponding handle that identifies the layout and language. The low word of the handle is a language identifier. The high word is a device handle, specifying the physical layout, or is zero, indicating a default physical layout. The user can associate any input language with a physical layout. For example, an English-speaking user who very occasionally works in French can set the input language of the keyboard to French without changing the physical layout of the keyboard. This means the user can enter text in French using the familiar English layout.\r\n\r\nApplications are generally not expected to manipulate input languages directly. Instead, the user sets up language and layout combinations, then switches among them. When the user clicks into text marked with a different language, the application calls the ActivateKeyboardLayout function to activate the user\'s default layout for that language. If the user edits text in a language which is not in the active list, the application can call the LoadKeyboardLayout function with the language to get a layout based on that language.\r\n\r\nThe ActivateKeyboardLayout function sets the input language for the current task. The hkl parameter can be either the handle to the keyboard layout or a zero-extended language identifier. Keyboard layout handles can be obtained from the LoadKeyboardLayout or GetKeyboardLayoutList function. The HKL_NEXT and HKL_PREV values can also be used to select the next or previous keyboard.\r\n\r\nThe GetKeyboardLayoutName function retrieves the name of the active keyboard layout for the calling thread. If an application creates the active layout using the LoadKeyboardLayout function, GetKeyboardLayoutName retrieves the same string used to create the layout. Otherwise, the string is the primary language identifier corresponding to the locale of the active layout. This means the function may not necessarily differentiate among different layouts with the same primary language, so cannot return specific information about the input language. The GetKeyboardLayout function, however, can be used to determine the input language.\r\n\r\nThe LoadKeyboardLayout function loads a keyboard layout and makes the layout available to the user. Applications can make the layout immediately active for the current thread by using the KLF_ACTIVATE value. An application can use the KLF_REORDER value to reorder the layouts without also specifying the KLF_ACTIVATE value. Applications should always use the KLF_SUBSTITUTE_OK value when loading keyboard layouts to ensure that the user\'s preference, if any, is selected.\r\n\r\nFor multilingual support, the LoadKeyboardLayout function provides the KLF_REPLACELANG and KLF_NOTELLSHELL flags. The KLF_REPLACELANG flag directs the function to replace an existing keyboard layout without changing the language. Attempting to replace an existing layout using the same language identifier but without specifying KLF_REPLACELANG is an error. The KLF_NOTELLSHELL flag prevents the function from notifying the shell when a keyboard layout is added or replaced. This is useful for applications that add multiple layouts in a consecutive series of calls. This flag should be used in all but the last call.\r\n\r\nThe UnloadKeyboardLayout function is restricted in that it cannot unload the system default input language. This ensures that the user always has one layout available for enter text using the same character set as used by the shell and file system.', '', '', '', '', '', '2016-09-11 13:10:24', '2016-09-11 13:10:24', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('list_add_after', 'function', 'Adds an element after the specified one.', 'inline void list_add_after( struct list *elem, struct list *to_add );', 'elem --- Another element will be added after this element.\r\n///\r\nto_add --- An element to add.', '', '<pre>__WINE_SERVER_LIST_INLINE void list_add_after( struct list *elem, struct list *to_add )\r\n{\r\n    to_add->next = elem->next;\r\n    to_add->prev = elem;\r\n    elem->next->prev = to_add;\r\n    elem->next = to_add;\r\n}</pre>', 'struct list|list_add_before', '2016-09-08 13:11:03', '2016-09-08 13:11:03', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_add_before', 'function', 'Adds an element before the specified one.', 'inline void list_add_before( struct list *elem, struct list *to_add );', 'elem --- Another element will be added before this element.\r\n///\r\nto_add --- An element to add.', '', '<pre>__WINE_SERVER_LIST_INLINE void list_add_before( struct list *elem, struct list *to_add )\r\n{\r\n    to_add->next = elem;\r\n    to_add->prev = elem->prev;\r\n    elem->prev->next = to_add;\r\n    elem->prev = to_add;\r\n}</pre>', 'struct list|list_add_after', '2016-09-08 13:12:42', '2016-09-08 13:12:42', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_add_head', 'function', 'Adds an element at the head of the doubly-linked list.', 'inline void list_add_head( struct list *list, struct list *elem );', 'list --- A pointer to a list.\r\n///\r\nelem --- A pointer to the element to add.', '', '<pre>__WINE_SERVER_LIST_INLINE void list_add_head( struct list *list, struct list *elem )\r\n{\r\n    list_add_after( list, elem );\r\n}</pre>', 'struct list|list_add_tail', '2016-09-08 13:06:04', '2016-09-08 13:06:04', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_add_tail', 'function', 'Adds an element at the tail of the doubly-linked list.', 'inline void list_add_tail( struct list *list, struct list *elem );', 'list --- A pointer to the list.\r\n///\r\nelem --- A pointer to the element to add.', '', '<pre>__WINE_SERVER_LIST_INLINE void list_add_tail( struct list *list, struct list *elem )\r\n{\r\n    list_add_before( list, elem );\r\n}</pre>', 'struct list|list_add_head', '2016-09-08 13:08:41', '2016-09-08 13:08:41', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_count', 'function', 'Counts the elements of a list.', 'inline unsigned int list_count( const struct list *list );', 'list --- A pointer to the list.', 'Returns the number of the elements of the specified list.', '<pre>__WINE_SERVER_LIST_INLINE unsigned int list_count( const struct list *list )\r\n{\r\n    unsigned count = 0;\r\n    const struct list *ptr;\r\n    for (ptr = list->next; ptr != list; ptr = ptr->next) count++;\r\n    return count;\r\n}</pre>', 'struct list|list_empty', '2016-09-08 13:23:58', '2016-09-08 13:23:58', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_empty', 'function', 'Checks if a list is empty.', 'inline int list_empty( const struct list *list );', 'list --- A pointer to the list.', 'Returns a non-zero value if the list is empty. Otherwise returns zero.', '<pre>__WINE_SERVER_LIST_INLINE int list_empty( const struct list *list )\r\n{\r\n    return list->next == list;\r\n}</pre>', 'struct list|list_count', '2016-09-08 13:22:31', '2016-09-08 13:22:31', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LIST_ENTRY', 'macro', 'Gets the pointer to the object containing the specified list element.', 'LIST_ENTRY(elem, type, field)', 'elem --- A pointer to the element of struct list type.\r\n///\r\ntype --- The type of the object.\r\n///\r\nfield --- The member name of struct list type in the object structure.', 'Returns the pointer to the object.', '<pre>#ifdef _WIN64\r\n#define LIST_ENTRY(elem, type, field) \\\r\n    ((type *)((char *)(elem) - (unsigned long long)(&((type *)0)->field)))\r\n#else\r\n#define LIST_ENTRY(elem, type, field) \\\r\n    ((type *)((char *)(elem) - (unsigned long)(&((type *)0)->field)))\r\n#endif</pre>', 'struct list', '2016-09-08 13:52:33', '2016-09-08 13:52:33', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LIST_FOR_EACH', 'macro', 'Iterates through the linked list.', 'struct list *cursor;\r\nLIST_FOR_EACH(cursor, &my_list)\r\n{\r\n    ...\r\n}', 'cursor --- A pointer to a struct list, as a loop variable.\r\n///\r\nlist --- A pointer to the list of struct list type.', '', '<pre>#define LIST_FOR_EACH(cursor,list) \\\r\n    for ((cursor) = (list)->next; (cursor) != (list); (cursor) = (cursor)->next)</pre>', 'struct list|LIST_FOR_EACH_ENTRY|LIST_FOR_EACH_SAFE', '2016-09-08 13:59:45', '2016-09-08 13:59:45', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LIST_FOR_EACH_ENTRY', 'macro', 'Iterates through the linked list using a list entry.', 'type *elem;\r\nLIST_FOR_EACH_ENTRY(elem, list, type, field)\r\n{\r\n    ...\r\n}', 'elem --- A pointer to the object, as a loop variable.\r\n///\r\nlist --- A pointer to the linked list of struct list type.\r\n///\r\ntype --- The type of the object.\r\n///\r\nfield --- The member name of struct list type, in the object structure.', '', '<pre>#define LIST_FOR_EACH_ENTRY(elem, list, type, field) \\\r\n    for ((elem) = LIST_ENTRY((list)->next, type, field); \\\r\n         &(elem)->field != (list); \\\r\n         (elem) = LIST_ENTRY((elem)->field.next, type, field))</pre>', 'struct list|LIST_FOR_EACH|LIST_FOR_EACH_ENTRY_SAFE', '2016-09-08 14:09:54', '2016-09-08 14:09:54', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LIST_FOR_EACH_ENTRY_REV', 'macro', 'Iterates through the linked list in reverse order using a list entry.', 'type *elem;\r\nLIST_FOR_EACH_ENTRY_REV(elem, list, type, field)\r\n{\r\n    ...\r\n}', 'elem --- A pointer to the object, as a loop variable.\r\n///\r\nlist --- A pointer to the list of struct list type.\r\n///\r\ntype --- The type of the object.\r\n///\r\nfield --- The member name of struct list type, in the object structure.', '', '<pre>#define LIST_FOR_EACH_ENTRY_REV(elem, list, type, field) \\\r\n    for ((elem) = LIST_ENTRY((list)->prev, type, field); \\\r\n         &(elem)->field != (list); \\\r\n         (elem) = LIST_ENTRY((elem)->field.prev, type, field))</pre>', 'struct list|LIST_FOR_EACH_ENTRY_SAFE_REV', '2016-09-10 01:50:01', '2016-09-10 01:50:01', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LIST_FOR_EACH_ENTRY_SAFE', 'macro', 'Iterate through the linked list using a list entry, with safety against removal.', 'type *cursor, *cursor2;\r\nLIST_FOR_EACH_ENTRY_SAFE(cursor, cursor2, list, type, field)\r\n{\r\n    ...\r\n}', 'cursor --- A pointer to the object, as a loop variable. You can remove this in the loop.\r\n///\r\ncursor2 --- Another pointer to the object, as a loop variable. This is the next element of cursor.\r\n///\r\nlist --- A pointer to the list of struct list type.\r\n///\r\ntype --- The type of the object.\r\n///\r\nfield --- The member name of struct list type, in the object structure.', '', '<pre>#define LIST_FOR_EACH_ENTRY_SAFE(cursor, cursor2, list, type, field) \\\r\n    for ((cursor) = LIST_ENTRY((list)->next, type, field), \\\r\n         (cursor2) = LIST_ENTRY((cursor)->field.next, type, field); \\\r\n         &(cursor)->field != (list); \\\r\n         (cursor) = (cursor2), \\\r\n         (cursor2) = LIST_ENTRY((cursor)->field.next, type, field))</pre>', 'struct list|LIST_FOR_EACH_ENTRY', '2016-09-10 01:45:27', '2016-09-10 01:45:27', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LIST_FOR_EACH_ENTRY_SAFE_REV', 'macro', 'Iterates through the linked list in reverse order using a list entry, with safety against removal.', 'type *cursor, *cursor2;\r\nLIST_FOR_EACH_ENTRY_SAFE_REV(cursor, cursor2, list, type, field)\r\n{\r\n    ...\r\n}', 'cursor --- A pointer to the object, as a loop variable. You can remove this in the loop.\r\n///\r\ncursor2 --- Another pointer to the object, as a loop variable.\r\n///\r\nlist --- A pointer to the list of struct list type.\r\n///\r\ntype --- The type of the object.\r\n///\r\nfield --- The member name of struct list type, in the object structure.', '', '<pre>#define LIST_FOR_EACH_ENTRY_SAFE_REV(cursor, cursor2, list, type, field) \\\r\n    for ((cursor) = LIST_ENTRY((list)->prev, type, field), \\\r\n         (cursor2) = LIST_ENTRY((cursor)->field.prev, type, field); \\\r\n         &(cursor)->field != (list); \\\r\n         (cursor) = (cursor2), \\\r\n         (cursor2) = LIST_ENTRY((cursor)->field.prev, type, field))</pre>', 'struct list|LIST_FOR_EACH_ENTRY_REV', '2016-09-10 01:52:24', '2016-09-10 01:52:24', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LIST_FOR_EACH_REV', 'macro', 'Iterates through the linked list in reverse order.', 'struct list *cursor;\r\nLIST_FOR_EACH_REV(cursor, list)\r\n{\r\n    ...\r\n}', 'cursor --- A pointer to an element, as a loop variable.\r\n///\r\nlist --- A pointer to the list of struct list type.', '', '<pre>#define LIST_FOR_EACH_REV(cursor,list) \\\r\n    for ((cursor) = (list)->prev; (cursor) != (list); (cursor) = (cursor)->prev)</pre>', 'struct list|LIST_FOR_EACH|LIST_FOR_EACH_ENTRY_REV|LIST_FOR_EACH_SAFE_REV', '2016-09-10 01:47:31', '2016-09-10 01:47:31', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LIST_FOR_EACH_SAFE', 'macro', 'Iterates through the linked list, with safety against removal.', 'struct list *cursor, *cursor2;\r\nLIST_FOR_EACH_SAFE(cursor, cursor2, list)\r\n{\r\n    ...\r\n}', 'cursor --- A loop variable that is a pointer to a struct list. You can remove it in the loop.\r\n///\r\ncursor2 --- Another loop variable that is a pointer to a struct list. It will be the next element of cursor in the loop.\r\n///\r\nlist --- A pointer to the list of struct list type.', '', '<pre>#define LIST_FOR_EACH_SAFE(cursor, cursor2, list) \\\r\n    for ((cursor) = (list)->next, (cursor2) = (cursor)->next; \\\r\n         (cursor) != (list); \\\r\n         (cursor) = (cursor2), (cursor2) = (cursor)->next)</pre>', 'struct list|LIST_FOR_EACH_SAFE_REV|LIST_FOR_EACH_ENTRY_SAFE', '2016-09-08 14:04:20', '2016-09-08 14:04:20', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LIST_FOR_EACH_SAFE_REV', 'macro', 'Iterates through the linked list in reverse order, with safety against removal.', 'struct list *cursor, *cursor2;\r\nLIST_FOR_EACH_SAFE_REV(cursor, cursor2, list)\r\n{\r\n    ...\r\n}', 'cursor --- A pointer to the list element, as a loop variable. You can remove this in the loop.\r\n///\r\ncursor2 --- Another pointer to the list element.\r\n///\r\nlist --- A pointer to the list of struct list type.', '', '<pre>#define LIST_FOR_EACH_SAFE_REV(cursor, cursor2, list) \\\r\n    for ((cursor) = (list)->prev, (cursor2) = (cursor)->prev; \\\r\n         (cursor) != (list); \\\r\n         (cursor) = (cursor2), (cursor2) = (cursor)->prev)</pre>', 'struct list|LIST_FOR_EACH_SAFE|LIST_FOR_EACH_REV', '2016-09-10 02:28:18', '2016-09-10 02:28:18', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_head', 'function', 'Gets the first element of a linked list.', 'inline struct list *list_head( const struct list *list );', 'list --- A pointer to the list of struct list type.', 'Returns the first element or NULL.', '<pre>__WINE_SERVER_LIST_INLINE struct list *list_head( const struct list *list )\r\n{\r\n    return list_next( list, list );\r\n}</pre>', 'struct list|list_tail', '2016-09-08 13:19:45', '2016-09-08 13:19:45', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_init', 'function', 'Initializes a linked list.', 'inline void list_init( struct list *list );\r\nstatic struct list list = LIST_INIT(list);', 'list --- A linked list.', '', '<pre>__WINE_SERVER_LIST_INLINE void list_init( struct list *list )\r\n{\r\n    list->next = list->prev = list;\r\n}</pre>\r\n\r\n<pre>#define LIST_INIT(list)  { &(list), &(list) }</pre>', 'struct list', '2016-09-08 13:04:15', '2016-09-08 13:04:15', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_next', 'function', 'Gets the next element.', 'inline struct list *list_next( const struct list *list, const struct list *elem );', 'list --- A pointer to the list.\r\n///\r\nelem --- The element.', 'Returns the next element of elem, or NULL.', '<pre>__WINE_SERVER_LIST_INLINE struct list *list_next( const struct list *list, const struct list *elem )\r\n{\r\n    struct list *ret = elem->next;\r\n    if (elem->next == list) ret = NULL;\r\n    return ret;\r\n}</pre>', 'struct list|list_prev', '2016-09-08 13:16:26', '2016-09-08 13:16:26', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_prev', 'function', 'Gets the previous element.', 'inline struct list *list_prev( const struct list *list, const struct list *elem );', 'list --- A pointer to the list.\r\n///\r\nelem --- The element.', 'Returns the previous element of elem, or NULL.', '<pre>__WINE_SERVER_LIST_INLINE struct list *list_prev( const struct list *list, const struct list *elem )\r\n{\r\n    struct list *ret = elem->prev;\r\n    if (elem->prev == list) ret = NULL;\r\n    return ret;\r\n}</pre>', 'struct list|list_next', '2016-09-08 13:18:06', '2016-09-08 13:18:06', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_remove', 'function', 'Removes an element from its list.', 'inline void list_remove( struct list *elem );', 'elem --- The element to remove.', '', '<pre>__WINE_SERVER_LIST_INLINE void list_remove( struct list *elem )\r\n{\r\n    elem->next->prev = elem->prev;\r\n    elem->prev->next = elem->next;\r\n}</pre>', 'struct list|list_add_head|list_add_tail|list_add_before|list_add_after', '2016-09-08 13:14:18', '2016-09-08 13:14:18', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('list_tail', 'function', 'Gets the last element of a doubly-linked list.', 'inline struct list *list_tail( const struct list *list );', 'list --- A pointer to the list of struct list type.', 'Returns the last element or NULL.', '<pre>__WINE_SERVER_LIST_INLINE struct list *list_tail( const struct list *list )\r\n{\r\n    return list_prev( list, list );\r\n}</pre>', 'struct list|list_head', '2016-09-08 13:20:52', '2016-09-08 13:20:52', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('LoadKeyboardLayout', 'function', 'Loads a new input locale identifier (formerly called the keyboard layout) into the system.\r\n\r\nPrior to Windows 8: Several input locale identifiers can be loaded at a time, but only one per process is active at a time. Loading multiple input locale identifiers makes it possible to rapidly switch between them.\r\n\r\nBeginning in Windows 8: The input locale identifier is loaded for the entire system. This function has no effect if the current process does not own the window with keyboard focus.', 'HKL WINAPI LoadKeyboardLayout(\r\n  _In_ LPCTSTR pwszKLID,\r\n  _In_ UINT    Flags\r\n);', 'pwszKLID [in] Type: LPCTSTR --- The name of the input locale identifier to load. This name is a string composed of the hexadecimal value of the Language Identifier (low word) and a device identifier (high word). For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named \"00000409\". Variants of U.S. English layout (such as the Dvorak layout) are named \"00010409\", \"00020409\", and so on.\r\n///\r\nFlags [in] Type: UINT --- Specifies how the input locale identifier is to be loaded. This parameter can be one of the following values. \r\n\r\n[table:LoadKeyboardLayout_Table1]', 'If the function succeeds, the return value is the input locale identifier corresponding to the name specified in pwszKLID. If no matching locale is available, the return value is the default language of the system. To get extended error information, call GetLastError.', 'The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input. \r\n\r\nAn application can and will typically load the default input locale identifier or IME for a language and can do so by specifying only a string version of the language identifier. If an application wants to load a specific locale or IME, it should read the registry to determine the specific input locale identifier to pass to LoadKeyboardLayout. In this case, a request to activate the default input locale identifier for a locale will activate the first matching one. A specific IME should be activated using an explicit input locale identifier returned from GetKeyboardLayout or LoadKeyboardLayout.\r\n\r\nPrior to Windows 8: This function only affects the layout for the current process or thread.\r\n\r\nBeginning in Windows 8: This function affects the layout for the entire system.', 'ActivateKeyboardLayout|GetKeyboardLayoutName|UnloadKeyboardLayout|GetKeyboardLayout', '2016-09-11 03:35:11', '2016-09-11 03:35:11', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646305.aspx', '', '', '', '', ''),
('MAKELANGID', 'macro', 'Creates a language identifier from a primary language identifier and a sublanguage identifier.', 'WORD MAKELANGID(\r\n   USHORT usPrimaryLanguage,\r\n   USHORT usSubLanguage\r\n);', 'usPrimaryLanguage --- Primary language identifier. This identifier can be a predefined value or a value for a user-defined primary language. For a user-defined language, the identifier is a value in the range 0x0200 to 0x03FF. All other values are reserved for operating system use. For more information, see Language Identifier Constants and Strings.\r\n///\r\nusSubLanguage --- Sublanguage identifier. This parameter can be a predefined sublanguage identifier or a user-defined sublanguage. For a user-defined sublanguage, the identifier is a value in the range 0x20 to 0x3F. All other values are reserved for operating system use. For more information, see Language Identifier Constants and Strings.', 'Returns the language identifier.', 'The following table shows combinations of usPrimaryLanguage and usSubLanguage that have special meaning.\r\n\r\n[table:MAKELANGID_Table1]', 'PRIMARYLANGID|SUBLANGID', '2016-09-18 05:11:04', '2016-09-18 05:11:04', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd373908.aspx', '', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('MAKELCID', 'macro', 'Creates a locale identifier from a language identifier and a sort order identifier.', 'DWORD MAKELCID(\r\n   WORD wLanguageID,\r\n   WORD wSortID\r\n);', 'wLanguageID --- Language identifier. This identifier is a combination of a primary language identifier and a sublanguage identifier and is usually created by using the MAKELANGID macro.\r\n///\r\nwSortID --- Sort order identifier.', 'Returns the locale identifier.', '', 'LANGIDFROMLCID|MAKELANGID|SORTIDFROMLCID', '2016-09-18 05:16:52', '2016-09-18 05:16:52', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd319052.aspx', '', '', '', '', ''),
('Message Deadlocks', '', 'A thread that calls the SendMessage function to send a message to another thread cannot continue executing until the window procedure that receives the message returns. If the receiving thread yields control while processing the message, the sending thread cannot continue executing, because it is waiting for SendMessage to return. If the receiving thread is attached to the same queue as the sender, it can cause an application deadlock to occur. (Note that journal hooks attach threads to the same queue.)\r\n\r\nNote that the receiving thread need not yield control explicitly; calling any of the following functions can cause a thread to yield control implicitly. \r\n\r\n * DialogBox\r\n * DialogBoxIndirect\r\n * DialogBoxIndirectParam\r\n * DialogBoxParam\r\n * GetMessage\r\n * MessageBox\r\n * PeekMessage\r\n * SendMessage\r\n\r\nTo avoid potential deadlocks in your application, consider using the SendNotifyMessage or SendMessageTimeout functions. Otherwise, a window procedure can determine whether a message it has received was sent by another thread by calling the InSendMessage or InSendMessageEx function. Before calling any of the functions in the preceding list while processing a message, the window procedure should first call InSendMessage or InSendMessageEx. If this function returns TRUE, the window procedure must call the ReplyMessage function before any function that causes the thread to yield control.', '', '', '', '', 'GetMessage|MessageBox|PeekMessage|SendMessage|InSendMessage|InSendMessageEx|ReplyMessage|SendNotifyMessage|SendMessageTimeout', '2016-09-03 06:58:02', '2016-09-03 06:58:02', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Sending Messages', 'Broadcasting Messages'),
('Message Filtering', '', 'An application can choose specific messages to retrieve from the message queue (while ignoring other messages) by using the GetMessage or PeekMessage function to specify a message filter. The filter is a range of message identifiers (specified by a first and last identifier), a window handle, or both. GetMessage and PeekMessage use a message filter to select which messages to retrieve from the queue. Message filtering is useful if an application must search the message queue for messages that have arrived later in the queue. It is also useful if an application must process input (hardware) messages before processing posted messages. \r\n\r\nThe WM_KEYFIRST and WM_KEYLAST constants can be used as filter values to retrieve all keyboard messages; the WM_MOUSEFIRST and WM_MOUSELAST constants can be used to retrieve all mouse messages. \r\n\r\nAny application that filters messages must ensure that a message satisfying the message filter can be posted. For example, if an application filters for a WM_CHAR message in a window that does not receive keyboard input, the GetMessage function does not return. This effectively \"hangs\" the application.', '', '', '', '', 'GetMessage|PeekMessage|WM_CHAR', '2016-09-03 06:55:02', '2016-09-03 06:55:02', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Window Procedure', 'Posting and Sending Messages'),
('Message Handling', '', 'An application must remove and process messages posted to the message queues of its threads. A single-threaded application usually uses a message loop in its WinMain function to remove and send messages to the appropriate window procedures for processing. Applications with multiple threads can include a message loop in each thread that creates a window. The following sections describe how a message loop works and explain the role of a window procedure: \r\n\r\n * Message Loop\r\n * Window Procedure', '', '', '', '', 'Message Loop|Window Procedure', '2016-09-03 06:52:15', '2016-09-03 06:52:15', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Nonqueued Messages', 'Message Loop'),
('Message Loop', '', 'A simple message loop consists of one function call to each of these three functions: GetMessage, TranslateMessage, and DispatchMessage. Note that if there is an error, GetMessage returns –1, thus the need for the special testing.\r\n\r\n<pre>MSG msg;\r\nBOOL bRet;\r\nwhile( (bRet = GetMessage( &msg, NULL, 0, 0 )) != 0)\r\n{ \r\n    if (bRet == -1)\r\n    {\r\n        // handle the error and possibly exit\r\n    }\r\n    else\r\n    {\r\n        TranslateMessage(&msg); \r\n        DispatchMessage(&msg); \r\n    }\r\n}</pre>\r\n\r\nThe GetMessage function retrieves a message from the queue and copies it to a structure of type MSG. It returns a nonzero value, unless it encounters the WM_QUIT message, in which case it returns FALSE and ends the loop. In a single-threaded application, ending the message loop is often the first step in closing the application. An application can end its own loop by using the PostQuitMessage function, typically in response to the WM_DESTROY message in the window procedure of the application\'s main window. \r\n\r\nIf you specify a window handle as the second parameter of GetMessage, only messages for the specified window are retrieved from the queue. GetMessage can also filter messages in the queue, retrieving only those messages that fall within a specified range. For more information about filtering messages, see Message Filtering. \r\n\r\nA thread\'s message loop must include TranslateMessage if the thread is to receive character input from the keyboard. The system generates virtual-key messages (WM_KEYDOWN and WM_KEYUP) each time the user presses a key. A virtual-key message contains a virtual-key code that identifies which key was pressed, but not its character value. To retrieve this value, the message loop must contain TranslateMessage, which translates the virtual-key message into a character message (WM_CHAR) and places it back into the application message queue. The character message can then be removed upon a subsequent iteration of the message loop and dispatched to a window procedure. \r\n\r\nThe DispatchMessage function sends a message to the window procedure associated with the window handle specified in the MSG structure. If the window handle is HWND_TOPMOST, DispatchMessage sends the message to the window procedures of all top-level windows in the system. If the window handle is NULL, DispatchMessage does nothing with the message. \r\n\r\nAn application\'s main thread starts its message loop after initializing the application and creating at least one window. After it is started, the message loop continues to retrieve messages from the thread\'s message queue and to dispatch them to the appropriate windows. The message loop ends when the GetMessage function removes the WM_QUIT message from the message queue. \r\n\r\nOnly one message loop is needed for a message queue, even if an application contains many windows. DispatchMessage always dispatches the message to the proper window; this is because each message in the queue is an MSG structure that contains the handle of the window to which the message belongs. \r\n\r\nYou can modify a message loop in a variety of ways. For example, you can retrieve messages from the queue without dispatching them to a window. This is useful for applications that post messages not specifying a window. You can also direct GetMessage to search for specific messages, leaving other messages in the queue. This is useful if you must temporarily bypass the usual FIFO order of the message queue. \r\n\r\nAn application that uses accelerator keys must be able to translate keyboard messages into command messages. To do this, the application\'s message loop must include a call to the TranslateAccelerator function. For more information about accelerator keys, see Keyboard Accelerators. \r\n\r\nIf a thread uses a modeless dialog box, the message loop must include the IsDialogMessage function so that the dialog box can receive keyboard input.', '', '', '', '', 'GetMessage|TranslateMessage|DispatchMessage|MSG|WM_KEYDOWN|WM_KEYUP|IsDialogMessage|TranslateAccelerator', '2016-09-03 06:53:25', '2016-09-03 06:53:25', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Message Handling', 'Window Procedure'),
('Message Routing', '', 'The system uses two methods to route messages to a window procedure: posting messages to a first-in, first-out queue called a message queue, a system-defined memory object that temporarily stores messages, and sending messages directly to a window procedure.\r\n\r\nA messages that is posted to a message queue is called a queued message. These are primarily the result of user input entered through the mouse or keyboard, such as WM_MOUSEMOVE, WM_LBUTTONDOWN, WM_KEYDOWN, and WM_CHAR messages. Other queued messages include the timer, paint, and quit messages: WM_TIMER, WM_PAINT, and WM_QUIT. Most other messages, which are sent directly to a window procedure, are called nonqueued messages. \r\n\r\n * Queued Messages\r\n * Nonqueued Messages', '', '', '', '', 'Queued Messages|Nonqueued Messages|WM_KEYDOWN|WM_CHAR', '2016-09-03 06:49:50', '2016-09-03 06:49:50', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Application-Defined Messages', 'Queued Messages'),
('Message Types', '', 'This section describes the two types of messages:\r\n\r\n * System-Defined Messages\r\n * Application-Defined Messages', '', '', '', '', 'System-Defined Messages|Application-Defined Messages', '2016-09-03 06:41:56', '2016-09-03 06:41:56', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Windows Messages', 'System-Defined Messages'),
('Named Objects', '', 'An IME may want to create various named objects that should be accessed from multiple processes on the local system. Such objects may include file, mutex, or event. Since a process might belong to a different user who is interactively logging onto the system, the default security attribute (created by the system when an IME creates an object with the NULL parameter as the pointer to the security attribute) may not be appropriate for all processes on the local system.\r\n\r\nOn Windows NT, the first client process of the IME may be the Winlogon process that lets a user log onto the system. Since the Winlogon process belongs to the system account during the log-on session and is alive until the system shuts down, named objects created by the IME with the default security attribute during the log-on session cannot be accessed through other processes belonging to a logged-on user.\r\n\r\nA sample IME source code that creates the security attribute appropriated for named objects is provided in the Microsoft Platform DDK. By using the sample code, IME writers can create various named objects that can be accessed from all client processes of the IME on the local system. The security attribute allocated by the sample code is per process. An IME that frequently creates named objects may want to initialize the security attribute attach time and free the security attribute at the process detach time. An IME that does not create named objects often may want to initialize the security attribute just before the creation of the named object and then free the security attribute just after the object is created.', '', '', '', '', '', '2016-09-10 09:26:50', '2016-09-10 09:26:50', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('NI_CHANGECANDIDATELIST', 'action', 'Application changes the currently \r\nselected candidate.', '', 'dwIndex --- Index of the candidate list to be selected.\r\n///\r\ndwValue --- Not used.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'NotifyIME', '2016-08-29 05:54:55', '2016-08-29 05:54:55', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('NI_CLOSECANDIDATE', 'action', 'Application has the IME close the \r\ncandidate list. If the IME closes the \r\ncandidate list, the IME sends a \r\nWM_IME_NOTIFY (subfunction is \r\nIMN_CLOSECANDIDATE) message.', '', 'dwIndex --- Index of the candidate list to be closed.\r\n///\r\ndwValue --- Not used.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'NotifyIME', '2016-08-29 05:53:18', '2016-08-29 05:53:18', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('NI_COMPOSITIONSTR', 'action', 'Application changes the composition \r\nstring. This action takes effect only when \r\nthere is a composition string in the Input \r\nContext.', '', 'dwIndex --- The following values are provided for dwIndex: \r\n\r\n[table:NI_COMPOSITIONSTR_Table1]\r\n///\r\ndwValue --- Not used.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'NotifyIME', '2016-08-29 05:59:25', '2016-08-29 05:59:25', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('NI_CONTEXTUPDATED', 'action', 'Application or system updates the Input \r\nContext.', '', 'dwIndex --- When the value of dwValue is IMC_SETCONVERSIONMODE, dwIndex is the previous conversion mode. When the value of dwValue is IMC_SETSENTENCEMODE, dwIndex is the previous sentence mode. For any other dwValue, dwIndex is not used.\r\n///\r\ndwValue --- One of following values used by the WM_IME_CONTROL message:\r\n\r\n * IMC_SETCANDIDATEPOS \r\n * IMC_SETCOMPOSITIONFONT \r\n * IMC_SETCOMPOSITIONWINDOW \r\n * IMC_SETCONVERSIONMODE \r\n * IMC_SETSENTENCEMODE \r\n * IMC_SETOPENSTATUS', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'NotifyIME', '2016-08-29 05:58:00', '2016-08-29 05:58:00', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('NI_OPENCANDIDATE', 'action', 'Application has the IME open the \r\ncandidate list. If the IME opens the \r\ncandidate list, the IME sends a \r\nWM_IME_NOTIFY (subfunction is \r\nIMN_OPENCANDIDATE) message.', '', 'dwIndex --- Index of the candidate list to be opened.\r\n///\r\ndwValue --- Not used.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'NotifyIME', '2016-08-29 05:52:23', '2016-08-29 05:52:23', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('NI_SELECTCANDIDATESTR', 'action', 'Application selects one of the candidates.', '', 'dwIndex --- Index of the candidate list to be selected.\r\n///\r\ndwValue --- Index of the candidate string in the \r\nselected candidate list.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'NotifyIME', '2016-08-29 05:54:04', '2016-08-29 05:54:04', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('NI_SETCANDIDATE_PAGESIZE', 'action', 'Application changes the page size of the \r\ncandidate list.', '', 'dwIndex --- Index of the candidate list to be changed.\r\n///\r\ndwValue --- New page size.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'NotifyIME', '2016-08-29 05:56:43', '2016-08-29 05:56:43', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('NI_SETCANDIDATE_PAGESTART', 'action', 'Application changes the page starting \r\nindex of the candidate list.', '', 'dwIndex --- Index of the candidate list to be changed.\r\n///\r\ndwValue --- New page start index.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'NotifyIME', '2016-08-29 05:55:56', '2016-08-29 05:55:56', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('Nonqueued Messages', '', 'Nonqueued messages are sent immediately to the destination window procedure, bypassing the system message queue and thread message queue. The system typically sends nonqueued messages to notify a window of events that affect it. For example, when the user activates a new application window, the system sends the window a series of messages, including WM_ACTIVATE, WM_SETFOCUS, and WM_SETCURSOR. These messages notify the window that it has been activated, that keyboard input is being directed to the window, and that the mouse cursor has been moved within the borders of the window. Nonqueued messages can also result when an application calls certain system functions. For example, the system sends the WM_WINDOWPOSCHANGED message after an application uses the SetWindowPos function to move a window. \r\n\r\nSome functions that send nonqueued messages are BroadcastSystemMessage, BroadcastSystemMessageEx, SendMessage, SendMessageTimeout, and SendNotifyMessage.', '', '', '', '', 'BroadcastSystemMessage|BroadcastSystemMessageEx|SendMessage|SendMessageTimeout|SendNotifyMessage', '2016-09-03 06:51:26', '2016-09-03 06:51:26', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Queued Messages', 'Message Handling'),
('Nonsystem Character Messages', '', 'A window procedure can receive the following character messages: WM_CHAR, WM_DEADCHAR, WM_SYSCHAR, WM_SYSDEADCHAR, and WM_UNICHAR. The TranslateMessage function generates a WM_CHAR or WM_DEADCHAR message when it processes a WM_KEYDOWN message. Similarly, it generates a WM_SYSCHAR or WM_SYSDEADCHAR message when it processes a WM_SYSKEYDOWN message.\r\n\r\nAn application that processes keyboard input typically ignores all but the WM_CHAR and WM_UNICHAR messages, passing any other messages to the DefWindowProc function. Note that WM_CHAR uses 16-bit Unicode Transformation Format (UTF) while WM_UNICHAR uses UTF-32. The system uses the WM_SYSCHAR and WM_SYSDEADCHAR messages to implement menu mnemonics.\r\n\r\nThe wParam parameter of all character messages contains the character code of the character key that was pressed. The value of the character code depends on the window class of the window receiving the message. If the Unicode version of the RegisterClass function was used to register the window class, the system provides Unicode characters to all windows of that class. Otherwise, the system provides ASCII character codes. For more information, see Unicode and Character Sets.\r\n\r\nThe contents of the lParam parameter of a character message are identical to the contents of the lParam parameter of the key-down message that was translated to produce the character message. For information, see Keystroke Message Flags.', '', '', '', '', '', '2016-09-11 13:04:14', '2016-09-11 13:04:14', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Normal Reconversion', '', 'For an efficient conversion result, the application should provide the RECONVERTSTRING structure with the \r\ninformation string. In this case, the composition string is not the entire string, but is identical to the target string. An \r\nIME can convert the composition string by referencing the entire string and then setting the target clause by its \r\nconversion result.', '', '', '', '', 'RECONVERTSTRING', '2016-09-10 09:03:37', '2016-09-10 09:03:37', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('NotifyIME', 'function', 'The NotifyIME function changes the status of the IME according to the given parameters.', 'BOOL WINAPI NotifyIME( \r\n    HIMC hIMC, \r\n    DWORD dwAction, \r\n    DWORD dwIndex, \r\n    DWORD dwValue)', 'hIMC --- Input context handle. \r\n///\r\ndwAction --- Following are the context items that an application can specify in the dwAction parameter.\r\n\r\n * NI_OPENCANDIDATE\r\n * NI_CLOSECANDIDATE\r\n * NI_SELECTCANDIDATESTR\r\n * NI_CHANGECANDIDATELIST\r\n * NI_SETCANDIDATE_PAGESTART\r\n * NI_SETCANDIDATE_PAGESIZE\r\n * NI_CONTEXTUPDATED\r\n * NI_COMPOSITIONSTR\r\n///\r\ndwIndex --- Dependent on uAction. \r\n///\r\ndwValue --- Dependent on uAction.', 'If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.', '', 'ImmNotifyIME|NI_OPENCANDIDATE|NI_CLOSECANDIDATE|NI_SELECTCANDIDATESTR|NI_CHANGECANDIDATELIST|NI_SETCANDIDATE_PAGESTART|NI_SETCANDIDATE_PAGESIZE|NI_CONTEXTUPDATED|NI_COMPOSITIONSTR', '2016-08-29 05:22:51', '2016-08-29 05:22:51', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', '', '', '', '', ''),
('OemKeyScan', 'function', 'Maps OEMASCII codes 0 through 0x0FF into the OEM scan codes and shift states. The function provides information that allows a program to send OEM text to another program by simulating keyboard input.', 'DWORD WINAPI OemKeyScan(\r\n  _In_ WORD wOemChar\r\n);', 'wOemChar [in] Type: WORD --- The ASCII value of the OEM character.', 'The low-order word of the return value contains the scan code of the OEM character, and the high-order word contains the shift state, which can be a combination of the following bits.\r\n\r\n[table:OemKeyScan_Table1]\r\n\r\nIf the character cannot be produced by a single keystroke using the current keyboard layout, the return value is –1.', 'This function does not provide translations for characters that require CTRL+ALT or dead keys. Characters not translated by this function must be copied by simulating input using the ALT+ keypad mechanism. The NUMLOCK key must be off.\r\n\r\nThis function does not provide translations for characters that cannot be typed with one keystroke using the current keyboard layout, such as characters with diacritics requiring dead keys. Characters not translated by this function may be simulated using the ALT+ keypad mechanism. The NUMLOCK key must be on. \r\n\r\nThis function is implemented using the VkKeyScan function.', 'VkKeyScan', '2016-09-11 03:41:29', '2016-09-11 03:41:29', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646308.aspx', '', '', '', '', ''),
('Overview of IMM/IME', '', 'Beginning with Windows 95 and Windows NT ®  4.0, Input Method Editors (IMEs) are provided as a dynamic-link\r\nlibrary (DLL), in contrast to the IMEs for the Windows 3.1 Far East Edition. Each IME runs as one of the\r\nmultilingual keyboard layouts. In comparison to the Windows 3.1 IME, the new Win32 Multilingual Input Method\r\nManager (IMM) and Input Method Editor (IME) architecture provide the following advantages:\r\n\r\n * Run as a component of the multilingual environment\r\n * Offer multiple Input Contexts for each application task\r\n * Keep one active IME per each application thread\r\n * Give information to the application through message looping (no message order broken)\r\n * Offer strong support for both IME-aware and IME-unaware applications\r\n\r\nTo fully utilize these advantages, an application needs to support the new Win32 IMM/IME application interface.\r\nIn order to maintain maximum compatibility with existing Windows 95 and Windows NT 4.0 IMEs, Windows 98 and\r\nWindows 2000 have not changed significantly in design. However, new features have been added in order to\r\nprovide better system integration and to support more intelligent IMEs.', '', '', '', 'IME developers must use the immdev.h in DDK, which is a superset of the imm.h in the SDK or other \r\ndevelopment tools.', '', '2016-09-10 08:27:11', '2016-09-10 08:27:11', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('PeekMessage', 'function', 'Dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).', 'BOOL WINAPI PeekMessage(\r\n  _Out_    LPMSG lpMsg,\r\n  _In_opt_ HWND  hWnd,\r\n  _In_     UINT  wMsgFilterMin,\r\n  _In_     UINT  wMsgFilterMax,\r\n  _In_     UINT  wRemoveMsg\r\n);', 'lpMsg [out] Type: LPMSG --- A pointer to an MSG structure that receives message information.\r\n///\r\nhWnd [in, optional] Type: HWND --- A handle to the window whose messages are to be retrieved. The window must belong to the current thread. \r\n\r\nIf hWnd is NULL, PeekMessage retrieves messages for any window that belongs to the current thread, and any messages on the current thread\'s message queue whose hwnd value is NULL (see the MSG structure). Therefore if hWnd is NULL, both window messages and thread messages are processed.\r\n\r\nIf hWnd is -1, PeekMessage retrieves only messages on the current thread\'s message queue whose hwnd value is NULL, that is, thread messages as posted by PostMessage (when the hWnd parameter is NULL) or PostThreadMessage.\r\n///\r\nwMsgFilterMin [in] Type: UINT --- The value of the first message in the range of messages to be examined. Use WM_KEYFIRST (0x0100) to specify the first keyboard message or WM_MOUSEFIRST (0x0200) to specify the first mouse message.\r\n\r\nIf wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).\r\n///\r\nwMsgFilterMax [in] Type: UINT --- The value of the last message in the range of messages to be examined. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message.\r\n\r\nIf wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).\r\n///\r\nwRemoveMsg [in] Type: UINT --- Specifies how messages are to be handled. This parameter can be one or more of the following values.\r\n\r\n[table:PeekMessage_Table1]\r\n\r\n\r\n\r\nBy default, all message types are processed. To specify that only certain message should be processed, specify one or more of the following values.\r\n\r\n[table:PeekMessage_Table2]', 'If a message is available, the return value is nonzero.\r\n\r\nIf no messages are available, the return value is zero.', 'PeekMessage retrieves messages associated with the window identified by the hWnd parameter or any of its children as specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word is reserved for the system.\r\n\r\nNote that PeekMessage always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax.\r\n\r\nDuring this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:\r\n\r\n * Sent messages \r\n * Posted messages \r\n * Input (hardware) messages and system internal events \r\n * Sent messages (again) \r\n * WM_PAINT messages \r\n * WM_TIMER messages \r\n\r\nTo retrieve input messages before posted messages, use the wMsgFilterMin and wMsgFilterMax parameters. \r\n\r\nThe PeekMessage function normally does not remove WM_PAINT messages from the queue. WM_PAINT messages remain in the queue until they are processed. However, if a WM_PAINT message has a NULL update region, PeekMessage does remove it from the queue.\r\n\r\nIf a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When an application is being debugged, the system does not generate a ghost window.', 'GetMessage|IsChild|MSG|WaitMessage|PeekMessage', '2016-08-25 05:16:11', '2016-08-25 05:16:11', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644943.aspx', '', '', '', '', ''),
('Posting and Sending Messages', '', 'Any application can post and send messages. Like the system, an application posts a message by copying it to a message queue and sends a message by passing the message data as arguments to a window procedure. To post messages, an application uses the PostMessage function. An application can send a message by calling the SendMessage, BroadcastSystemMessage, SendMessageCallback, SendMessageTimeout, SendNotifyMessage, or SendDlgItemMessage function. \r\n\r\n * Posting Messages\r\n * Sending Messages', '', '', '', '', 'Posting Messages|Sending Messages|PostMessage|SendMessage|BroadcastSystemMessage|SendMessageCallback|SendMessageTimeout|SendNotifyMessage', '2016-09-03 06:55:57', '2016-09-03 06:55:57', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Message Filtering', 'Posting Messages'),
('Posting Messages', '', 'An application typically posts a message to notify a specific window to perform a task. PostMessage creates an MSG structure for the message and copies the message to the message queue. The application\'s message loop eventually retrieves the message and dispatches it to the appropriate window procedure. \r\n\r\nAn application can post a message without specifying a window. If the application supplies a NULL window handle when calling PostMessage, the message is posted to the queue associated with the current thread. Because no window handle is specified, the application must process the message in the message loop. This is one way to create a message that applies to the entire application, instead of to a specific window. \r\n\r\nOccasionally, you may want to post a message to all top-level windows in the system. An application can post a message to all top-level windows by calling PostMessage and specifying HWND_TOPMOST in the hwnd parameter. \r\n\r\nA common programming error is to assume that the PostMessage function always posts a message. This is not true when the message queue is full. An application should check the return value of the PostMessage function to determine whether the message has been posted and, if it has not been, repost it.', '', '', '', '', 'MSG', '2016-09-03 06:56:25', '2016-09-03 06:56:25', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Posting and Sending Messages', 'Sending Messages'),
('PostMessage', 'function', 'Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.\r\n\r\nTo post a message in the message queue associated with a thread, use the PostThreadMessage function.', 'BOOL WINAPI PostMessage(\r\n  _In_opt_ HWND   hWnd,\r\n  _In_     UINT   Msg,\r\n  _In_     WPARAM wParam,\r\n  _In_     LPARAM lParam\r\n);', 'hWnd [in, optional] Type: HWND --- A handle to the window whose window procedure is to receive the message. The following values have special meanings.\r\n\r\n[table:PostMessage_Table1]\r\n\r\nStarting with Windows Vista, message posting is subject to UIPI. The thread of a process can post messages only to message queues of threads in processes of lesser or equal integrity level.\r\n///\r\nMsg [in] Type: UINT --- The message to be posted.\r\n\r\nFor lists of the system-provided messages, see System-Defined Messages.\r\n///\r\nwParam [in] Type: WPARAM --- Additional message-specific information.\r\n///\r\nlParam [in] Type: LPARAM --- Additional message-specific information.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.', 'When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).\r\n\r\nMessages in a message queue are retrieved by calls to the GetMessage or PeekMessage function.\r\n\r\nApplications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.\r\n\r\nThe system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.\r\n\r\nIf you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.\r\n\r\nDo not post the WM_QUIT message using PostMessage; use the PostQuitMessage function.\r\n\r\nAn accessibility application can use PostMessage to post WM_APPCOMMAND messages to the shell to launch applications. This functionality is not guaranteed to work for other types of applications.', 'GetMessage|PeekMessage|PostQuitMessage|PostThreadMessage|RegisterWindowMessage|SendMessageCallback|SendNotifyMessage', '2016-08-25 05:18:28', '2016-08-25 05:18:28', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644944.aspx', '', '', '', '', ''),
('PostThreadMessage', 'function', 'Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.', 'BOOL WINAPI PostThreadMessage(\r\n  _In_ DWORD  idThread,\r\n  _In_ UINT   Msg,\r\n  _In_ WPARAM wParam,\r\n  _In_ LPARAM lParam\r\n);', 'idThread [in] Type: DWORD --- The identifier of the thread to which the message is to be posted.\r\n\r\nThe function fails if the specified thread does not have a message queue. The system creates a thread\'s message queue when the thread makes its first call to one of the User or GDI functions. For more information, see the Remarks section.\r\n\r\nMessage posting is subject to UIPI. The thread of a process can post messages only to posted-message queues of threads in processes of lesser or equal integrity level.\r\n\r\nThis thread must have the SE_TCB_NAME privilege to post a message to a thread that belongs to a process with the same locally unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and returns ERROR_INVALID_THREAD_ID.\r\n\r\nThis thread must either belong to the same desktop as the calling thread or to a process with the same LUID. Otherwise, the function fails and returns ERROR_INVALID_THREAD_ID.\r\n///\r\nMsg [in] Type: UINT --- The type of message to be posted.\r\n///\r\nwParam [in] Type: WPARAM --- Additional message-specific information.\r\n///\r\nlParam [in] Type: LPARAM --- Additional message-specific information.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns ERROR_INVALID_THREAD_ID if idThread is not a valid thread identifier, or if the thread specified by idThread does not have a message queue. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the message limit is hit.', 'When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).\r\n\r\nThe thread to which the message is posted must have created a message queue, or else the call to PostThreadMessage fails. Use the following method to handle this situation. \r\n\r\n * Create an event object, then create the thread.\r\n * Use the WaitForSingleObject function to wait for the event to be set to the signaled state before calling PostThreadMessage.\r\n * In the thread to which the message will be posted, call PeekMessage as shown here to force the system to create the message queue: PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE)\r\n * Set the event, to indicate that the thread is ready to receive posted messages.\r\n\r\nThe thread to which the message is posted retrieves the message by calling the GetMessage or PeekMessage function. The hwnd member of the returned MSG structure is NULL.\r\n\r\nMessages sent by PostThreadMessage are not associated with a window. As a general rule, messages that are not associated with a window cannot be dispatched by the DispatchMessage function. Therefore, if the recipient thread is in a modal loop (as used by MessageBox or DialogBox), the messages will be lost. To intercept thread messages while in a modal loop, use a thread-specific hook.\r\n\r\nThe system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.\r\n\r\nThere is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.\r\n\r\n<pre>HKEY_LOCAL_MACHINE\r\n   SOFTWARE\r\n      Microsoft\r\n         Windows NT\r\n            CurrentVersion\r\n               Windows\r\n                  USERPostMessageLimit\r\n</pre>\r\n\r\nThe minimum acceptable value is 4000.', 'GetMessage|GetWindowThreadProcessId|MSG|PeekMessage|PostMessage', '2016-08-25 05:20:17', '2016-08-25 05:20:17', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644946.aspx', '', '', '', '', ''),
('Previous Key-State Flag', '', 'The previous key-state flag indicates whether the key that generated the keystroke message was previously up or down. It is 1 if the key was previously down and 0 if the key was previously up. You can use this flag to identify keystroke messages generated by the keyboard\'s automatic repeat feature. This flag is set to 1 for WM_KEYDOWN and WM_SYSKEYDOWN keystroke messages generated by the automatic repeat feature. It is always set to 0 for WM_KEYUP and WM_SYSKEYUP messages.', '', '', '', '', '', '2016-09-11 13:01:49', '2016-09-11 13:01:49', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('PRIMARYLANGID', 'macro', 'Extracts a primary language identifier from a language identifier.', 'WORD PRIMARYLANGID(\r\n   WORD lgid\r\n);', 'lgid --- Language identifier. This value is a combination of a primary language identifier and a sublanguage identifier and is usually created by using the MAKELANGID macro.', 'Returns the primary language identifier. It can be one of the predefined primary language identifiers or a user-defined primary language identifier. For more information, see MAKELANGID.', '', 'LANGIDFROMLCID|MAKELANGID|SUBLANGID', '2016-09-18 05:19:21', '2016-09-18 05:19:21', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd319102.aspx', '', '', '', '', ''),
('Query Messages', '', 'You can create your own custom messages and use them to coordinate activities between your applications and other components in the system. This is especially useful if you have created your own installable drivers or system-level device drivers. Your custom messages can carry information to and from your driver and the applications that use the driver. \r\n\r\nTo poll recipients for permission to carry out a given action, use a query message. You can generate your own query messages by setting the BSF_QUERY value in the dwFlags parameter when calling BroadcastSystemMessage. Each recipient of the query message must return TRUE for the function to send the message to the next recipient. If any recipient returns BROADCAST_QUERY_DENY, the broadcast ends immediately and the function returns a zero.', '', '', '', '', 'BroadcastSystemMessage', '2016-09-03 06:58:54', '2016-09-03 06:58:54', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Broadcasting Messages', ''),
('Queued Messages', '', 'The system can display any number of windows at a time. To route mouse and keyboard input to the appropriate window, the system uses message queues. \r\n\r\nThe system maintains a single system message queue and one thread-specific message queue for each GUI thread. To avoid the overhead of creating a message queue for non–GUI threads, all threads are created initially without a message queue. The system creates a thread-specific message queue only when the thread makes its first call to one of the specific user functions; no GUI function calls result in the creation of a message queue.\r\n\r\nWhenever the user moves the mouse, clicks the mouse buttons, or types on the keyboard, the device driver for the mouse or keyboard converts the input into messages and places them in the system message queue. The system removes the messages, one at a time, from the system message queue, examines them to determine the destination window, and then posts them to the message queue of the thread that created the destination window. A thread\'s message queue receives all mouse and keyboard messages for the windows created by the thread. The thread removes messages from its queue and directs the system to send them to the appropriate window procedure for processing. \r\n\r\nWith the exception of the WM_PAINT message, the WM_TIMER message, and the WM_QUIT message, the system always posts messages at the end of a message queue. This ensures that a window receives its input messages in the proper first in, first out (FIFO) sequence. The WM_PAINT message, the WM_TIMER message, and the WM_QUIT message, however, are kept in the queue and are forwarded to the window procedure only when the queue contains no other messages. In addition, multiple WM_PAINT messages for the same window are combined into a single WM_PAINT message, consolidating all invalid parts of the client area into a single area. Combining WM_PAINT messages reduces the number of times a window must redraw the contents of its client area. \r\n\r\nThe system posts a message to a thread\'s message queue by filling an MSG structure and then copying it to the message queue. Information in MSG includes: the handle of the window for which the message is intended, the message identifier, the two message parameters, the time the message was posted, and the mouse cursor position. A thread can post a message to its own message queue or to the queue of another thread by using the PostMessage or PostThreadMessage function. \r\n\r\nAn application can remove a message from its queue by using the GetMessage function. To examine a message without removing it from its queue, an application can use the PeekMessage function. This function fills MSG with information about the message. \r\n\r\nAfter removing a message from its queue, an application can use the DispatchMessage function to direct the system to send the message to a window procedure for processing. DispatchMessage takes a pointer to MSG that was filled by a previous call to the GetMessage or PeekMessage function. DispatchMessage passes the window handle, the message identifier, and the two message parameters to the window procedure, but it does not pass the time the message was posted or mouse cursor position. An application can retrieve this information by calling the GetMessageTime and GetMessagePos functions while processing a message. \r\n\r\nA thread can use the WaitMessage function to yield control to other threads when it has no messages in its message queue. The function suspends the thread and does not return until a new message is placed in the thread\'s message queue. \r\n\r\nYou can call the SetMessageExtraInfo function to associate a value with the current thread\'s message queue. Then call the GetMessageExtraInfo function to get the value associated with the last message retrieved by the GetMessage or PeekMessage function.', '', '', '', '', 'MSG|PostMessage|PostThreadMessage|GetMessage|PeekMessage|DispatchMessage|GetMessageTime|GetMessagePos|GetMessageExtraInfo|SetMessageExtraInfo', '2016-09-03 06:50:54', '2016-09-03 06:50:54', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Message Routing', 'Nonqueued Messages'),
('Reconversion', '', 'Reconversion is a new IME function for Windows 98 and Windows 2000. It provides the capability to reconvert a string that is already inserted in an application’s document. Specifically, whatever the string is, an IME is instructed to recognize the string, convert it to the reading or typing information, and then display the candidate list.\r\n\r\nNew and advanced intelligent IMEs are capable of recognizing and interpreting a complete sentence. When an IME is supplied with better information about a string, such as full sentence and string segmentation, it can accomplish better conversion performance and accuracy. For example, by supplying an entire sentence as opposed to just the reconverted strings, the IME can reconvert the string without having to first convert to reading or typing information. \r\n\r\nEditing after the determination is harder than before today. This is because determination will discard most of the information undetermined string had, like reading, phrases, and part of speech. Reconversion will get these information back, making editing after the determination as easier as before the determination. Users will be able to choose different homonym words from candidates, change phrase break and let IME analyze again, and so forth. \r\n\r\nThe RECONVERTSTRING structure can store the entire sentence and point to the string that will be reconverted by dwStartOffset and dwLen. If dwStartOffset is zero and dwLen is the length of the string, the entire string is reconverted by the IME.\r\n\r\n * Simple Reconversion\r\n * Normal Reconversion\r\n * Enhanced Reconversion', '', '', '', '', 'Simple Reconversion|Normal Reconversion|Enhanced Reconversion|RECONVERTSTRING', '2016-09-10 09:01:23', '2016-09-10 09:01:23', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('RECONVERTSTRING', 'structure', 'Defines the strings for IME reconversion. It is the first item in a memory block \r\nthat contains the strings for reconversion.', 'typedef struct {\r\n    DWOPD dwSize;\r\n    DWORD dwVersion;\r\n    DWORD dwStrLen;\r\n    DWORD dwStrOffset;\r\n    DWORD dwCompStrLen;\r\n    DWORD dwCompStrOffset;\r\n    DWORD dwTargetStrLen;\r\n    DWORD dwTargetStrOffset;\r\n} RECONVERTSTRING;', 'dwSize --- Memory block size of this structure.\r\n///\r\ndwVersion --- Reserved by the system. This must be zero.\r\n///\r\ndwStrlen --- Length of the string that contains the composition string.\r\n///\r\ndwStrOffset --- Offset from the start position of this structure. The string containing the reconverted words is stored at this point.\r\n///\r\ndwCompStrLen --- Length of the string that will be the composition string.\r\n///\r\ndwCompStrOffset --- Offset of the string that will be the composition string.\r\n///\r\ndwTargetStrLen --- Length of the string that is related to the target clause in the composition string.\r\n///\r\ndwTargetStrOffset --- Offset of the string that is related to the target clause in the composition string.', 'The RECONVERTSTRING structure is a new structure for Windows 98 and Windows 2000. The \r\ndwCompStrOffset and dwTargetOffset members are the relative position of dwStrOffset. For Windows NT Unicode, \r\ndwStrLen, dwCompStrLen, and dwTargetStrLen are the TCHAR count, and dwStrOffset, dwCompStrOffset, \r\nand dwTargetStrOffset are the byte offset. \r\n\r\nIf an application starts the reconversion process by calling ImmSetCompositionString with \r\nSCS_SETRECONVERTSTRING and SCS_QUERYRECONVERTSTRING, the application is then responsible for \r\nallocating the necessary memory for this structure as well as the composition string buffer. The IME should not use \r\nthe memory later. If the IME starts the process, it should allocate the necessary memory for the structure and the \r\ncomposition string buffer.', '', 'ImmSetCompositionString', '2016-09-10 03:57:31', '2016-09-10 03:57:31', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('RegisterHotKey', 'function', 'Defines a system-wide hot key.', 'BOOL WINAPI RegisterHotKey(\r\n  _In_opt_ HWND hWnd,\r\n  _In_     int  id,\r\n  _In_     UINT fsModifiers,\r\n  _In_     UINT vk\r\n);', 'hWnd [in, optional] Type: HWND --- A handle to the window that will receive WM_HOTKEY messages generated by the hot key. If this parameter is NULL, WM_HOTKEY messages are posted to the message queue of the calling thread and must be processed in the message loop.\r\n///\r\nid [in] Type: int --- The identifier of the hot key. If the hWnd parameter is NULL, then the hot key is associated with the current thread rather than with a particular window. If a hot key already exists with the same hWnd and id parameters, see Remarks for the action taken.\r\n///\r\nfsModifiers [in] Type: UINT --- The keys that must be pressed in combination with the key specified by the uVirtKey parameter in order to generate the WM_HOTKEY message. The fsModifiers parameter can be a combination of the following values.\r\n\r\n[table:RegisterHotKey_Table1]\r\n///\r\nvk [in] Type: UINT --- The virtual-key code of the hot key. See Virtual-Key Codes.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError.', 'When a key is pressed, the system looks for a match against all hot keys. Upon finding a match, the system posts the WM_HOTKEY message to the message queue of the window with which the hot key is associated. If the hot key is not associated with a window, then the WM_HOTKEY message is posted to the thread associated with the hot key.\r\n\r\nThis function cannot associate a hot key with a window created by another thread.\r\n\r\nRegisterHotKey fails if the keystrokes specified for the hot key have already been registered by another hot key.\r\n\r\nIf a hot key already exists with the same hWnd and id parameters, it is maintained along with the new hot key. The application must explicitly call UnregisterHotKey to unregister the old hot key.\r\n\r\nWindows Server 2003:  If a hot key already exists with the same hWnd and id parameters, it is replaced by the new hot key.\r\n\r\nThe F12 key is reserved for use by the debugger at all times, so it should not be registered as a hot key. Even when you are not debugging an application, F12 is reserved in case a kernel-mode debugger or a just-in-time debugger is resident.\r\n\r\nAn application must specify an id value in the range 0x0000 through 0xBFFF. A shared DLL must specify a value in the range 0xC000 through 0xFFFF (the range returned by the GlobalAddAtom function). To avoid conflicts with hot-key identifiers defined by other shared DLLs, a DLL should use the GlobalAddAtom function to obtain the hot-key identifier.', 'Virtual-Key Codes|UnregisterHotKey', '2016-09-11 03:45:17', '2016-09-11 03:45:17', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646309.aspx', '', '', '', '', ''),
('REGISTERWORDA', 'structure', 'Contains the reading information or a word to register.', 'typedef struct {\r\n  LPSTR lpReading;\r\n  LPSTR lpWord;\r\n} REGISTERWORDA;', 'lpReading --- Pointer to a string value that contains the reading information for the word to register. If the reading information is not needed, it can be set to NULL.\r\n/// \r\nlpWord --- Pointer to a string value that contains the word to register. If a word is not needed, it can be set to NULL.', '', 'This structure maps to the REGISTERWORD structure documented in the Windows Software Development Kit (SDK).', 'REGISTERWORD|REGISTERWORDW', '2016-08-28 05:58:26', '2016-08-28 05:58:26', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741232.aspx', '', '', '', '', ''),
('REGISTERWORDW', 'structure', 'Contains the reading information or a word to register.', 'typedef struct {\r\n  LPWSTR lpReading;\r\n  LPWSTR lpWord;\r\n} REGISTERWORDW;', 'lpReading --- Pointer to a string value that contains the reading information for the word to register. If the reading information is not needed, it can be set to NULL. \r\n///\r\nlpWord --- Pointer to a string value that contains the word to register. If a word is not needed, it can be set to NULL.', '', 'This structure maps to the REGISTERWORD structure documented in the Windows Software Development Kit (SDK).', 'REGISTERWORD|REGISTERWORDA', '2016-08-28 05:59:19', '2016-08-28 05:59:19', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741233.aspx', '', '', '', '', ''),
('Repeat Count', '', 'You can check the repeat count to determine whether a keystroke message represents more than one keystroke. The system increments the count when the keyboard generates WM_KEYDOWN or WM_SYSKEYDOWN messages faster than an application can process them. This often occurs when the user holds down a key long enough to start the keyboard\'s automatic repeat feature. Instead of filling the system message queue with the resulting key-down messages, the system combines the messages into a single key down message and increments the repeat count. Releasing a key cannot start the automatic repeat feature, so the repeat count for WM_KEYUP and WM_SYSKEYUP messages is always set to 1.', '', '', '', '', '', '2016-09-11 13:00:09', '2016-09-11 13:00:09', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('ReplyMessage', 'function', 'Replies to a message sent through the SendMessage function without returning control to the function that called SendMessage.', 'BOOL WINAPI ReplyMessage(\r\n  _In_ LRESULT lResult\r\n);', 'lResult [in] Type: LRESULT --- The result of the message processing. The possible values are based on the message sent.', 'If the calling thread was processing a message sent from another thread or process, the return value is nonzero.\r\n\r\nIf the calling thread was not processing a message sent from another thread or process, the return value is zero.', 'By calling this function, the window procedure that receives the message allows the thread that called SendMessage to continue to run as though the thread receiving the message had returned control. The thread that calls the ReplyMessage function also continues to run. \r\n\r\nIf the message was not sent through SendMessage or if the message was sent by the same thread, ReplyMessage has no effect.', 'InSendMessage|SendMessage', '2016-08-25 05:21:26', '2016-08-25 05:21:26', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644948.aspx', '', '', '', '', ''),
('Scan Code', '', 'The scan code is the value that the keyboard hardware generates when the user presses a key. It is a device-dependent value that identifies the key pressed, as opposed to the character represented by the key. An application typically ignores scan codes. Instead, it uses the device-independent virtual-key codes to interpret keystroke messages.', '', '', '', '', '', '2016-09-11 13:00:34', '2016-09-11 13:00:34', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Security Concerns', '', 'There are two primary security concerns for Windows NT. One involves named objects and the other involves \r\nWinlogon.\r\n\r\n * Named Objects\r\n * Winlogon', '', '', '', '', 'Named Objects|Winlogon', '2016-09-10 09:27:54', '2016-09-10 09:27:54', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('SendAsyncProc', 'callback function', 'An application-defined callback function used with the SendMessageCallback function. The system passes the message to the callback function after passing the message to the destination window procedure. The SENDASYNCPROC type defines a pointer to this callback function. SendAsyncProc is a placeholder for the application-defined function name.', 'VOID CALLBACK SendAsyncProc(\r\n  _In_ HWND      hwnd,\r\n  _In_ UINT      uMsg,\r\n  _In_ ULONG_PTR dwData,\r\n  _In_ LRESULT   lResult\r\n);', 'hwnd [in] Type: HWND --- A handle to the window whose window procedure received the message. \r\n\r\nIf the SendMessageCallback function was called with its hwnd parameter set to HWND_BROADCAST, the system calls the SendAsyncProc function once for each top-level window.\r\n///\r\nuMsg [in] Type: UINT --- The message.\r\n///\r\ndwData [in] Type: ULONG_PTR --- An application-defined value sent from the SendMessageCallback function.\r\n///\r\nlResult [in] Type: LRESULT --- The result of the message processing. This value depends on the message.', 'This callback function does not return a value.', 'You install a SendAsyncProc application-defined callback function by passing a SENDASYNCPROC pointer to the SendMessageCallback function. \r\n\r\nThe callback function is only called when the thread that called SendMessageCallback calls GetMessage, PeekMessage, or WaitMessage.', 'GetMessage|PeekMessage|SendMessageCallback|WaitMessage', '2016-08-25 05:22:52', '2016-08-25 05:22:52', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644949.aspx', '', '', '', '', ''),
('Sending Messages', '', 'An application typically sends a message to notify a window procedure to perform a task immediately. The SendMessage function sends the message to the window procedure corresponding to the given window. The function waits until the window procedure completes processing and then returns the message result. Parent and child windows often communicate by sending messages to each other. For example, a parent window that has an edit control as its child window can set the text of the control by sending a message to it. The control can notify the parent window of changes to the text that are carried out by the user by sending messages back to the parent. \r\n\r\nThe SendMessageCallback function also sends a message to the window procedure corresponding to the given window. However, this function returns immediately. After the window procedure processes the message, the system calls the specified callback function. For more information about the callback function, see the SendAsyncProc function. \r\n\r\nOccasionally, you may want to send a message to all top-level windows in the system. For example, if the application changes the system time, it must notify all top-level windows about the change by sending a WM_TIMECHANGE message. An application can send a message to all top-level windows by calling SendMessage and specifying HWND_TOPMOST in the hwnd parameter. You can also broadcast a message to all applications by calling the BroadcastSystemMessage function and specifying BSM_APPLICATIONS in the lpdwRecipients parameter. \r\n\r\nBy using the InSendMessage or InSendMessageEx function, a window procedure can determine whether it is processing a message sent by another thread. This capability is useful when message processing depends on the origin of the message.', '', '', '', '', 'SendMessage|SendMessageCallback|SendAsyncProc|BroadcastSystemMessage|InSendMessage|InSendMessageEx', '2016-09-03 06:57:02', '2016-09-03 06:57:02', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Posting Messages', 'Message Deadlocks'),
('SendMessage', 'function', 'Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.\r\n\r\nTo send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a thread\'s message queue and return immediately, use the PostMessage or PostThreadMessage function.', 'LRESULT WINAPI SendMessage(\r\n  _In_ HWND   hWnd,\r\n  _In_ UINT   Msg,\r\n  _In_ WPARAM wParam,\r\n  _In_ LPARAM lParam\r\n);', 'hWnd [in] Type: HWND --- A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.\r\n\r\nMessage sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.\r\n///\r\nMsg [in] Type: UINT --- The message to be sent. For lists of the system-provided messages, see System-Defined Messages.\r\n///\r\nwParam [in] Type: WPARAM --- Additional message-specific information.\r\n///\r\nlParam [in] Type: LPARAM --- Additional message-specific information.', 'The return value specifies the result of the message processing; it depends on the message sent.', 'When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).\r\n\r\nApplications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.\r\n\r\nThe system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.\r\n\r\nIf the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to be pr', 'InSendMessage|PostMessage|PostThreadMessage|RegisterWindowMessage|SendDlgItemMessage|SendMessageCallback|SendMessageTimeout|SendNotifyMessage', '2016-08-25 05:12:21', '2016-08-25 05:12:21', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644950.aspx', '', '', '', '', ''),
('SendMessageCallback', 'function', 'Sends the specified message to a window or windows. It calls the window procedure for the specified window and returns immediately if the window belongs to another thread. After the window procedure processes the message, the system calls the specified callback function, passing the result of the message processing and an application-defined value to the callback function.', 'BOOL WINAPI SendMessageCallback(\r\n  _In_ HWND          hWnd,\r\n  _In_ UINT          Msg,\r\n  _In_ WPARAM        wParam,\r\n  _In_ LPARAM        lParam,\r\n  _In_ SENDASYNCPROC lpCallBack,\r\n  _In_ ULONG_PTR     dwData\r\n);', 'hWnd [in] Type: HWND --- A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.\r\n///\r\nMsg [in] Type: UINT --- The message to be sent.\r\n\r\nFor lists of the system-provided messages, see System-Defined Messages.\r\n///\r\nwParam [in] Type: WPARAM --- Additional message-specific information.\r\n///\r\nlParam [in] Type: LPARAM --- Additional message-specific information.\r\n///\r\nlpCallBack [in] Type: SENDASYNCPROC --- A pointer to a callback function that the system calls after the window procedure processes the message. For more information, see SendAsyncProc. \r\n\r\nIf hWnd is HWND_BROADCAST ((HWND)0xffff), the system calls the SendAsyncProc callback function once for each top-level window.\r\n///\r\ndwData [in] Type: ULONG_PTR --- An application-defined value to be sent to the callback function pointed to by the lpCallBack parameter.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError.', 'If the target window belongs to the same thread as the caller, then the window procedure is called synchronously, and the callback function is called immediately after the window procedure returns. If the target window belongs to a different thread from the caller, then the callback function is called only when the thread that called SendMessageCallback also calls GetMessage, PeekMessage, or WaitMessage.\r\n\r\nIf you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used. \r\n\r\nApplications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.\r\n\r\nThe system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.', 'PostMessage|RegisterWindowMessage|SendAsyncProc|SendMessageCallback|SendNotifyMessage', '2016-08-25 05:24:45', '2016-08-25 05:24:45', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644951.aspx', '', '', '', '', ''),
('SendMessageTimeout', 'function', 'Sends the specified message to one or more windows.', 'LRESULT WINAPI SendMessageTimeout(\r\n  _In_      HWND       hWnd,\r\n  _In_      UINT       Msg,\r\n  _In_      WPARAM     wParam,\r\n  _In_      LPARAM     lParam,\r\n  _In_      UINT       fuFlags,\r\n  _In_      UINT       uTimeout,\r\n  _Out_opt_ PDWORD_PTR lpdwRes', 'hWnd [in] Type: HWND --- A handle to the window whose window procedure will receive the message.\r\n\r\nIf this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows. The function does not return until each window has timed out. Therefore, the total wait time can be up to the value of uTimeout multiplied by the number of top-level windows.\r\n///\r\nMsg [in] Type: UINT --- The message to be sent.\r\n\r\nFor lists of the system-provided messages, see System-Defined Messages.\r\n///\r\nwParam [in] Type: WPARAM --- Any additional message-specific information.\r\n///\r\nlParam [in] Type: LPARAM --- Any additional message-specific information.\r\n///\r\nfuFlags [in] Type: UINT --- The behavior of this function. This parameter can be one or more of the following values.\r\n\r\n[table:SendMessageTimeout_Table1]\r\n\r\nuTimeout [in] Type: UINT --- The duration of the time-out period, in milliseconds. If the message is a broadcast message, each window can use the full time-out period. For example, if you specify a five second time-out period and there are three top-level windows that fail to process the message, you could have up to a 15 second delay.\r\n///\r\nlpdwResult [out, optional] Type: PDWORD_PTR --- The result of the message processing. The value of this parameter depends on the message that is specified.', 'If the function succeeds, the return value is nonzero. SendMessageTimeout does not provide information about individual windows timing out if HWND_BROADCAST is used.\r\n\r\nIf the function fails or times out, the return value is 0. To get extended error information, call GetLastError. If GetLastError returns ERROR_TIMEOUT, then the function timed out.\r\n\r\nWindows 2000:  If GetLastError returns 0, then the function timed out.', 'The function calls the window procedure for the specified window and, if the specified window belongs to a different thread, does not return until the window procedure has processed the message or the specified time-out period has elapsed. If the window receiving the message belongs to the same queue as the current thread, the window procedure is called directly—the time-out value is ignored.\r\n\r\nThis function considers that a thread is not responding if it has not called GetMessage or a similar function within five seconds.\r\n\r\nThe system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.', 'GetMessage|InSendMessage|PostMessage|SendDlgItemMessage|SendMessage|SendMessageCallback|SendNotifyMessage', '2016-08-25 05:26:29', '2016-08-25 05:26:29', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644952.aspx', '', '', '', '', ''),
('SendNotifyMessage', 'function', 'Sends the specified message to a window or windows. If the window was created by the calling thread, SendNotifyMessage calls the window procedure for the window and does not return until the window procedure has processed the message. If the window was created by a different thread, SendNotifyMessage passes the message to the window procedure and returns immediately; it does not wait for the window procedure to finish processing the message.', 'BOOL WINAPI SendNotifyMessage(\r\n  _In_ HWND   hWnd,\r\n  _In_ UINT   Msg,\r\n  _In_ WPARAM wParam,\r\n  _In_ LPARAM lParam\r\n);', 'hWnd [in] Type: HWND --- A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.\r\n///\r\nMsg [in] Type: UINT --- The message to be sent.\r\n\r\nFor lists of the system-provided messages, see System-Defined Messages.\r\n///\r\nwParam [in] Type: WPARAM --- Additional message-specific information.\r\n///\r\nlParam [in] Type: LPARAM --- Additional message-specific information.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError.', 'If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.\r\n\r\nApplications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.\r\n\r\nThe system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.', 'PostMessage|PostThreadMessage|RegisterWindowMessage|SendMessage|SendMessageCallback|SendNotifyMessage', '2016-08-25 05:28:10', '2016-08-25 05:28:10', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644953.aspx', '', '', '', '', ''),
('SetActiveWindow', 'function', 'Activates a window. The window must be attached to the calling thread\'s message queue.', 'HWND WINAPI SetActiveWindow(\r\n  _In_ HWND hWnd\r\n);', 'hWnd [in] Type: HWND --- A handle to the top-level window to be activated.', 'If the function succeeds, the return value is the handle to the window that was previously active. \r\n\r\nIf the function fails, the return value is NULL. To get extended error information, call GetLastError.', 'The SetActiveWindow function activates a window, but not if the application is in the background. The window will be brought into the foreground (top of Z-Order) if its application is in the foreground when the system activates the window. \r\n\r\nIf the window identified by the hWnd parameter was created by the calling thread, the active window status of the calling thread is set to hWnd. Otherwise, the active window status of the calling thread is set to NULL.', 'GetActiveWindow|SetForegroundWindow|WM_ACTIVATE', '2016-09-11 03:47:56', '2016-09-11 03:47:56', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646311.aspx', '', '', '', '', ''),
('SetFocus', 'function', 'Sets the keyboard focus to the specified window. The window must be attached to the calling thread\'s message queue.', 'HWND WINAPI SetFocus(\r\n  _In_opt_ HWND hWnd\r\n);', 'hWnd [in, optional] Type: HWND --- A handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored.', 'If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the hWnd parameter is invalid or the window is not attached to the calling thread\'s message queue, the return value is NULL. To get extended error information, call GetLastError.', 'The SetFocus function sends a WM_KILLFOCUS message to the window that loses the keyboard focus and a WM_SETFOCUS message to the window that receives the keyboard focus. It also activates either the window that receives the focus or the parent of the window that receives the focus. \r\n\r\nIf a window is active but does not have the focus, any key pressed will produce the WM_SYSCHAR, WM_SYSKEYDOWN, or WM_SYSKEYUP message. If the VK_MENU key is also pressed, the lParam parameter of the message will have bit 30 set. Otherwise, the messages produced do not have this bit set. \r\n\r\nBy using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetFocus to set the keyboard focus to a window attached to another thread\'s message queue.', 'GetFocus|WM_KILLFOCUS|WM_SETFOCUS|WM_SYSCHAR|WM_SYSKEYDOWN|WM_SYSKEYUP', '2016-09-11 03:49:39', '2016-09-11 03:49:39', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646312.aspx', '', '', '', '', ''),
('SetKeyboardState', 'function', 'Copies an array of keyboard key states into the calling thread\'s keyboard input-state table. This is the same table accessed by the GetKeyboardState and GetKeyState functions. Changes made to this table do not affect keyboard input to any other thread.', 'BOOL WINAPI SetKeyboardState(\r\n  _In_ LPBYTE lpKeyState\r\n);', 'lpKeyState [in] Type: LPBYTE --- A pointer to a 256-byte array that contains keyboard key states.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError.', 'Because the SetKeyboardState function alters the input state of the calling thread and not the global input state of the system, an application cannot use SetKeyboardState to set the NUM LOCK, CAPS LOCK, or SCROLL LOCK (or the Japanese KANA) indicator lights on the keyboard. These can be set or cleared using SendInput to simulate keystrokes.', 'GetAsyncKeyState|GetKeyboardState|GetKeyState|keybd_event|MapVirtualKey|SendInput', '2016-09-11 03:51:20', '2016-09-11 03:51:20', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646314.aspx', '', '', '', '', ''),
('SetMessageExtraInfo', 'function', 'Sets the extra message information for the current thread. Extra message information is an application- or driver-defined value associated with the current thread\'s message queue. An application can use the GetMessageExtraInfo function to retrieve a thread', 'LPARAM WINAPI SetMessageExtraInfo(\r\n  _In_ LPARAM lParam\r\n);', 'lParam [in] Type: LPARAM --- The value to be associated with the current thread.', 'The return value is the previous value associated with the current thread.', '', 'GetMessageExtraInfo', '2016-08-25 05:28:57', '2016-08-25 05:28:57', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644954.aspx', '', '', '', '', ''),
('SHAppBarMessage', 'function', 'Sends an appbar message to the system.', 'UINT_PTR SHAppBarMessage(\r\n  _In_    DWORD       dwMessage,\r\n  _Inout_ PAPPBARDATA pData\r\n);', 'dwMessage [in] Type: DWORD --- Appbar message value to send. This parameter can be one of the following values.\r\n\r\n * ABM_NEW\r\n * ABM_REMOVE\r\n * ABM_QUERYPOS\r\n * ABM_SETPOS\r\n * ABM_GETSTATE\r\n * ABM_GETTASKBARPOS\r\n * ABM_ACTIVATE\r\n * ABM_GETAUTOHIDEBAR\r\n * ABM_SETAUTOHIDEBAR\r\n * ABM_WINDOWPOSCHANGED\r\n * ABM_SETSTATE\r\n * ABM_GETAUTOHIDEBAREX\r\n * ABM_SETAUTOHIDEBAREX\r\n///\r\npData [in, out] Type: PAPPBARDATA --- A pointer to an APPBARDATA structure. The content of the structure on entry and on exit depends on the value set in the dwMessage parameter. See the individual message pages for specifics.', 'This function returns a message-dependent value. For more information, see the Windows SDK documentation for the specific appbar message sent. Links to those documents are given in the See Also section.', '', 'APPBARDATA|ABM_NEW|ABM_REMOVE|ABM_QUERYPOS|ABM_SETPOS|ABM_GETSTATE|ABM_GETTASKBARPOS|ABM_ACTIVATE|ABM_GETAUTOHIDEBAR|ABM_SETAUTOHIDEBAR|ABM_WINDOWPOSCHANGED|ABM_SETSTATE|ABM_GETAUTOHIDEBAREX|ABM_SETAUTOHIDEBAREX', '2016-09-22 03:17:36', '2016-09-22 03:17:36', '<shellapi.h>', 'shell32.dll', 'https://msdn.microsoft.com/ja-jp/library/windows/desktop/bb762108.aspx', '', '', '', '', ''),
('Simple Reconversion', '', 'The simplest reconversion is when the target string and the composition string are the same as the entire string. In \r\nthis case, dwCompStrOffset and dwTargetStrOffset are zero, and dwStrLen, dwCompStrLen, and dwTargetStrLen \r\nare the same value. An IME will provide the composition string of the entire string that is supplied in the structure, \r\nand will set the target clause by its conversion result.', '', '', '', '', 'RECONVERTSTRING', '2016-09-10 09:03:11', '2016-09-10 09:03:11', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Simulating Input', '', 'To simulate an uninterrupted series of user input events, use the SendInput function. The function accepts three parameters. The first parameter, cInputs, indicates the number of input events that will be simulated. The second parameter, rgInputs, is an array of INPUT structures, each describing a type of input event and additional information about that event. The last parameter, cbSize, accepts the size of the INPUT structure, in bytes.\r\n\r\nThe SendInput function works by injecting a series of simulated input events into a device\'s input stream. The effect is similar to calling the keybd_event or mouse_event function repeatedly, except that the system ensures that no other input events intermingle with the simulated events. When the call completes, the return value indicates the number of input events successfully played. If this value is zero, then input was blocked.\r\n\r\nThe SendInput function does not reset the keyboard\'s current state. Therefore, if the user has any keys pressed when you call this function, they might interfere with the events that this function generates. If you are concerned about possible interference, check the keyboard\'s state with the GetAsyncKeyState function and correct as necessary.', '', '', '', '', '', '2016-09-11 13:08:55', '2016-09-11 13:08:55', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('Single-byte Character Sets', '', 'A single-byte character set (SBCS) is a mapping of 256 individual characters to their identifying code values, implemented as a code page. An SBCS can correspond either to a Windows code page or an OEM code page. An SBCS code page can also include a non-native code page, for example, an EBCDIC code page. For definitions of these code pages, see Code Pages.\r\n\r\nNote: New Windows applications should use Unicode to avoid the inconsistencies of varied code pages and for ease of localization. However, some legacy protocols require the use of an SBCS. Each SBCS code page supports different characters, but no page supports the full breadth of characters provided by Unicode. Each SBCS code page supports a different subset, differently encoded. Data converted from one SBCS code page to another is subject to corruption, because the same data value on different code pages can encode a different character. Data converted from Unicode to SBCS is subject to data loss because a given code page might not be able to represent every character used in that particular Unicode data. \r\n\r\nYour applications use SBCS Windows code pages with the \"A\" versions of Windows functions. See Conventions for Function Prototypes and Code Pages. To help identify an SBCS code page, an application can use the GetCPInfo or GetCPInfoEx function. In addition, an application can use the MultiByteToWideChar and WideCharToMultiByte functions to map between Unicode and SBCS strings.', '', '', '', '', 'Code Pages|Unicode', '2016-09-17 06:56:28', '2016-09-17 06:56:28', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374056.aspx', '', '', '', '', ''),
('Soft Keyboard', '', 'Soft Keyboard is a special window displayed by the IME. Because some IMEs have special reading characters, an IME can provide a soft keyboard to display these special reading characters. In this way, the user does not have to remember the reading character for each key. For example, an IME can use bo po mo fo for its reading characters, while another IME can use radicals for its reading characters.\r\n\r\nAn IME can change the reading characters of keys and notify the user of these key changes, depending on the conversion state. For example, during candidate selection time, an IME can show just the selection keys to the user.\r\n\r\nAn IME can also create its own user interface for a soft keyboard or use the system predefined soft keyboard. If an IME wants to use the system predefined soft keyboard, it needs to specify UI_CAP_SOFTKBD in the fdwUICaps member of the IMEINFO structure when ImeInquire is called.\r\n\r\nAn IME needs to call ImmCreateSoftKeyboard to create the soft keyboard window . It can also call ImmShowSoftKeyboard to show or hide the soft keyboard. Because the soft keyboard window is one component of the UI window, the owner should be the UI window as well.\r\n\r\nThere are different types of soft keyboards. Each one is designed for a specific country or special purpose. An IME can change the reading characters on the soft keyboard by using one of two methods: IMC_SETSOFTKBDSUBTYPE or IMC_SETSOFTKBDDATA.', '', '', '', '', 'IMEINFO|ImeInquire|ImmCreateSoftKeyboard|ImmShowSoftKeyboard|IMC_SETSOFTKBDSUBTYPE|IMC_SETSOFTKBDDATA', '2016-09-10 09:00:03', '2016-09-10 09:00:03', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('SOFTKBDDATA', 'structure', 'Defines the DBCS codes for each virtual key.', 'typedef struct { \r\n    UINT uCount; \r\n    WORD wCode[1][256] \r\n} SOFTKBDDATA;', 'uCount --- Number of the 256-word virtual key mapping to the internal code array. \r\n///\r\nwCode[1][256] --- 256-word virtual key mapping to the internal code array. There may be more than one 256-word arrays.', '', 'It is possible for one type of soft keyboard to use two 256-word arrays. One is for the nonshift state and the other \r\nis for the shift state. The soft keyboard can use two internal codes for displaying one virtual key.', '', '2016-09-10 03:55:30', '2016-09-10 03:55:30', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('SORTIDFROMLCID', 'macro', 'Retrieves a sort order identifier from a locale identifier.', 'WORD SORTIDFROMLCID(\r\n   LCID lcid\r\n);', 'lcid --- Locale identifier. You can use the MAKELCID macro to create a locale identifier or use one of the following predefined values.\r\n\r\n * LOCALE_INVARIANT\r\n * LOCALE_SYSTEM_DEFAULT\r\n * LOCALE_USER_DEFAULT\r\n\r\nWindows Vista and later: The following custom locale identifiers are also supported.\r\n\r\n * LOCALE_CUSTOM_DEFAULT\r\n * LOCALE_CUSTOM_UI_DEFAULT\r\n * LOCALE_CUSTOM_UNSPECIFIED', 'Returns a sort order identifier.', '', 'MAKELANGID|MAKELCID|PRIMARYLANGID|SUBLANGID', '2016-09-18 05:18:19', '2016-09-18 05:18:19', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374057.aspx', '', '', '', '', ''),
('struct list', 'structure', 'Consists of a doubly-linked list.', 'struct list\r\n{\r\n    struct list *next;\r\n    struct list *prev;\r\n};', 'next --- The next element or the first element.\r\n///\r\nprev --- The previous element or the last element.', '', 'You can manipulate the lists by the following inline functions:\r\n\r\n * Initializing a list: list_init\r\n * Adding a element: list_add_head, list_add_tail, list_add_after, list_add_before\r\n * Removing a element: list_remove\r\n * The next element: list_next\r\n * The previous element: list_prev\r\n * The first element: list_head\r\n * The last element: list_tail\r\n * Is the list empty: list_empty\r\n * The number of elements: list_count\r\n\r\nYou can use the following macros:\r\n\r\n * LIST_ENTRY\r\n * LIST_FOR_EACH\r\n * LIST_FOR_EACH_ENTRY\r\n * LIST_FOR_EACH_ENTRY_REV\r\n * LIST_FOR_EACH_ENTRY_SAFE\r\n * LIST_FOR_EACH_ENTRY_SAFE_REV\r\n * LIST_FOR_EACH_REV\r\n * LIST_FOR_EACH_SAFE\r\n * LIST_FOR_EACH_SAFE_REV', 'list_add_after|list_add_before|list_add_head|list_add_tail|list_count|list_empty|LIST_ENTRY|LIST_FOR_EACH|LIST_FOR_EACH_ENTRY|LIST_FOR_EACH_ENTRY_REV|LIST_FOR_EACH_ENTRY_SAFE|LIST_FOR_EACH_ENTRY_SAFE_REV|LIST_FOR_EACH_REV|LIST_FOR_EACH_SAFE|LIST_FOR_EACH_SAFE_REV|list_head|list_init|list_next|list_prev|list_remove|list_tail', '2016-09-08 13:02:11', '2016-09-08 13:02:11', '<wine/list.h>', 'Wine', 'Wine and ReactOS', '', '', '', '', ''),
('STYLEBUFA', 'structure', 'Contains the identifier and name of the style.', 'typedef struct {\r\n    DWORD       dwStyle;\r\n    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];\r\n} STYLEBUFA;', 'dwStyle --- Unsigned long integer value that contains the style of the register string. This can be IME_REGWORD_STYLE_EUDC to indicate a string in the EUDC range. \r\n///\r\nszDescription --- Array of characters that contains the description of the style.', '', 'This structure maps to the STYLEBUF structure documented in the Windows Software Development Kit (SDK).', 'STYLEBUF|STYLEBUFW', '2016-08-28 06:00:00', '2016-08-28 06:00:00', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741234.aspx', '', '', '', '', ''),
('STYLEBUFW', 'structure', 'Contains the identifier and name of the style.', 'typedef struct {\r\n    DWORD       dwStyle;\r\n    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];\r\n} STYLEBUFW;', 'dwStyle --- Unsigned long integer value that contains the style of the register string. This can be IME_REGWORD_STYLE_EUDC to indicate a string in the EUDC range. \r\n///\r\nszDescription --- Array of characters that contains the description of the style.', '', 'This structure maps to the STYLEBUF structure documented in the Windows Software Development Kit (SDK).', 'STYLEBUF|STYLEBUFA', '2016-08-28 06:00:43', '2016-08-28 06:00:43', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741235.aspx', '', '', '', '', ''),
('SUBLANGID', 'macro', 'Extracts a sublanguage identifier from a language identifier.', 'WORD SUBLANGID(\r\n   WORD lgid\r\n);', 'lgid --- Language identifier. You can supply predefined values for this parameter, or create an identifier using the MAKELANGID macro.', 'Returns a sublanguage identifier. This can be a predefined sublanguage identifier or a user-defined sublanguage identifier.', '', 'LANGIDFROMLCID|MAKELANGID|PRIMARYLANGID', '2016-09-18 05:15:33', '2016-09-18 05:15:33', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374066.aspx', '', '', '', '', ''),
('Surrogates and Supplementary Characters', '', 'Windows applications normally use UTF-16 to represent Unicode character data. The use of 16 bits allows direct representation of 65,536 unique characters, but this Basic Multilingual Plane (BMP) is not nearly enough to cover all the symbols used in human languages. Unicode version 4.1 includes over 97,000 characters, with over 70,000 characters for Chinese alone.\r\n\r\nThe Unicode standard has established 16 additional \"planes\" of characters, each the same size as the BMP. Naturally, most code points beyond the BMP do not yet have characters assigned to them, but definition of the planes gives Unicode the potential to define 1,114,112 characters (that is, 2¹⁶ * 17 characters) within the code point range U+0000 to U+10FFFF. For UTF-16 to represent this larger set of characters, the Unicode Standard defines \"supplementary characters\".\r\n\r\n * About Supplementary Characters\r\n * General Guidelines for Software Development Using Supplementary Characters', '', '', '', '', 'About Supplementary Characters|Using Supplementary Characters|Unicode', '2016-09-17 06:57:43', '2016-09-17 06:57:43', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069.aspx', '', '', '', '', ''),
('System and Nonsystem Keystrokes', '', 'The system makes a distinction between system keystrokes and nonsystem keystrokes. System keystrokes produce system keystroke messages, WM_SYSKEYDOWN and WM_SYSKEYUP. Nonsystem keystrokes produce nonsystem keystroke messages, WM_KEYDOWN and WM_KEYUP.\r\n\r\nIf your window procedure must process a system keystroke message, make sure that after processing the message the procedure passes it to the DefWindowProc function. Otherwise, all system operations involving the ALT key will be disabled whenever the window has the keyboard focus. That is, the user won\'t be able to access the window\'s menus or System menu, or use the ALT+ESC or ALT+TAB key combination to activate a different window.\r\n\r\nSystem keystroke messages are primarily for use by the system rather than by an application. The system uses them to provide its built-in keyboard interface to menus and to allow the user to control which window is active. System keystroke messages are generated when the user types a key in combination with the ALT key, or when the user types and no window has the keyboard focus (for example, when the active application is minimized). In this case, the messages are posted to the message queue attached to the active window.\r\n\r\nNonsystem keystroke messages are for use by application windows; the DefWindowProc function does nothing with them. A window procedure can discard any nonsystem keystroke messages that it does not need.', '', '', '', '', '', '2016-09-11 12:56:51', '2016-09-11 12:56:51', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('System-Defined Messages', '', 'The system sends or posts a system-defined message when it communicates with an application. It uses these messages to control the operations of applications and to provide input and other information for applications to process. An application can also send or post system-defined messages. Applications generally use these messages to control the operation of control windows created by using preregistered window classes. \r\n\r\nEach system-defined message has a unique message identifier and a corresponding symbolic constant (defined in the software development kit (SDK) header files) that states the purpose of the message. For example, the WM_PAINT constant requests that a window paint its contents. \r\n\r\nSymbolic constants specify the category to which system-defined messages belong. The prefix of the constant identifies the type of window that can interpret and process the message. Following are the prefixes and their related message categories. \r\n\r\n[table:System-Defined Messages_Table1]\r\n\r\nGeneral window messages cover a wide range of information and requests, including messages for mouse and keyboard input, menu and dialog box input, window creation and management, and Dynamic Data Exchange (DDE).', '', '', '', '', '', '2016-09-03 06:42:56', '2016-09-03 06:42:56', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Message Types', 'Application-Defined Messages'),
('ToAscii', 'function', 'Translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function translates the code using the input language and physical keyboard layout identified by the keyboard layout handle.\r\n\r\nTo specify a handle to the keyboard layout to use to translate the specified code, use the ToAsciiEx function.', 'int WINAPI ToAscii(\r\n  _In_           UINT   uVirtKey,\r\n  _In_           UINT   uScanCode,\r\n  _In_opt_ const BYTE   *lpKeyState,\r\n  _Out_          LPWORD lpChar,\r\n  _In_           UINT   uFlags\r\n);', 'uVirtKey [in] Type: UINT --- The virtual-key code to be translated. See Virtual-Key Codes.\r\n///\r\nuScanCode [in] Type: UINT --- The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed). \r\n///\r\nlpKeyState [in, optional] Type: const BYTE* --- A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down (pressed).\r\n\r\nThe low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is relevant. The toggle state of the NUM LOCK and SCROLL LOCK keys is ignored.\r\n///\r\nlpChar [out] Type: LPWORD --- The buffer that receives the translated character or characters. \r\n///\r\nuFlags [in] Type: UINT --- This parameter must be 1 if a menu is active, or 0 otherwise.', 'If the specified key is a dead key, the return value is negative. Otherwise, it is one of the following values. \r\n\r\n[table:ToAscii_Table1]', 'The parameters supplied to the ToAscii function might not be sufficient to translate the virtual-key code, because a previous dead key is stored in the keyboard layout.\r\n\r\nally, ToAscii performs the translation based on the virtual-key code. In some cases, however, bit 15 of the uScanCode parameter may be used to distinguish between a key press and a key release. The scan code is used for translating ALT+ number key combinations.\r\n\r\nAlthough NUM LOCK is a toggle key that affects keyboard behavior, ToAscii ignores the toggle setting (the low bit) of lpKeyState (VK_NUMLOCK) because the uVirtKey parameter alone is sufficient to distinguish the cursor movement keys (VK_HOME, VK_INSERT, and so on) from the numeric keys (VK_DECIMAL, VK_NUMPAD0 - VK_NUMPAD9).', 'OemKeyScan|ToAsciiEx|ToUnicode|VkKeyScan', '2016-09-11 04:13:18', '2016-09-11 04:13:18', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646316.aspx', '', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('ToAsciiEx', 'function', 'Translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function translates the code using the input language and physical keyboard layout identified by the input locale identifier.', 'int WINAPI ToAsciiEx(\r\n  _In_           UINT   uVirtKey,\r\n  _In_           UINT   uScanCode,\r\n  _In_opt_ const BYTE   *lpKeyState,\r\n  _Out_          LPWORD lpChar,\r\n  _In_           UINT   uFlags,\r\n  _In_opt_       HKL    dwhkl\r\n);', 'uVirtKey [in] Type: UINT --- The virtual-key code to be translated. See Virtual-Key Codes.\r\n///\r\nuScanCode [in] Type: UINT --- The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed). \r\n///\r\nlpKeyState [in, optional] Type: const BYTE* --- A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down (pressed).\r\n\r\nThe low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is relevant. The toggle state of the NUM LOCK and SCOLL LOCK keys is ignored.\r\n///\r\nlpChar [out] Type: LPWORD --- A pointer to the buffer that receives the translated character or characters. \r\n///\r\nuFlags [in] Type: UINT --- This parameter must be 1 if a menu is active, zero otherwise. \r\n///\r\ndwhkl [in, optional] Type: HKL --- Input locale identifier to use to translate the code. This parameter can be any input locale identifier previously returned by the LoadKeyboardLayout function.', 'If the specified key is a dead key, the return value is negative. Otherwise, it is one of the following values. \r\n\r\n[table:ToAsciiEx_Table1]', 'The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.\r\n\r\nThe parameters supplied to the ToAsciiEx function might not be sufficient to translate the virtual-key code, because a previous dead key is stored in the keyboard layout.\r\n\r\nTypically, ToAsciiEx performs the translation based on the virtual-key code. In some cases, however, bit 15 of the uScanCode parameter may be used to distinguish between a key press and a key release. The scan code is used for translating ALT+number key combinations.\r\n\r\nAlthough NUM LOCK is a toggle key that affects keyboard behavior, ToAsciiEx ignores the toggle setting (the low bit) of lpKeyState (VK_NUMLOCK) because the uVirtKey parameter alone is sufficient to distinguish the cursor movement keys (VK_HOME, VK_INSERT, and so on) from the numeric keys (VK_DECIMAL, VK_NUMPAD0 - VK_NUMPAD9).', 'LoadKeyboardLayout|MapVirtualKeyEx|ToUnicodeEx|VkKeyScan', '2016-09-11 04:17:22', '2016-09-11 04:17:22', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646318.aspx', '', '', '', '', ''),
('ToUnicode', 'function', 'Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.\r\n\r\nTo specify a handle to the keyboard layout to use to translate the specified code, use the ToUnicodeEx function.', 'int WINAPI ToUnicode(\r\n  _In_           UINT   wVirtKey,\r\n  _In_           UINT   wScanCode,\r\n  _In_opt_ const BYTE   *lpKeyState,\r\n  _Out_          LPWSTR pwszBuff,\r\n  _In_           int    cchBuff,\r\n  _In_           UINT   wFlags\r\n);', 'wVirtKey [in] Type: UINT --- The virtual-key code to be translated. See Virtual-Key Codes.\r\n///\r\nwScanCode [in] Type: UINT --- The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.\r\n///\r\nlpKeyState [in, optional] Type: const BYTE* --- A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down.\r\n///\r\npwszBuff [out] Type: LPWSTR --- The buffer that receives the translated Unicode character or characters. However, this buffer may be returned without being null-terminated even though the variable name suggests that it is null-terminated.\r\n///\r\ncchBuff [in] Type: int --- The size, in characters, of the buffer pointed to by the pwszBuff parameter.\r\n///\r\nwFlags [in] Type: UINT --- The behavior of the function. If bit 0 is set, a menu is active. Bits 1 through 31 are reserved.', 'The function returns one of the following values.\r\n\r\n[table:ToUnicode_Table1]', 'The parameters supplied to the ToUnicode function might not be sufficient to translate the virtual-key code because a previous dead key is stored in the keyboard layout.\r\n\r\nTypically, ToUnicode performs the translation based on the virtual-key code. In some cases, however, bit 15 of the wScanCode parameter can be used to distinguish between a key press and a key release.', 'ToAscii|ToUnicodeEx|VkKeyScan', '2016-09-11 04:20:20', '2016-09-11 04:20:20', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646320.aspx', '', '', '', '', ''),
('ToUnicodeEx', 'function', 'Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.', 'int WINAPI ToUnicodeEx(\r\n  _In_           UINT   wVirtKey,\r\n  _In_           UINT   wScanCode,\r\n  _In_     const BYTE   *lpKeyState,\r\n  _Out_          LPWSTR pwszBuff,\r\n  _In_           int    cchBuff,\r\n  _In_           UINT   wFlags,\r\n  _In_opt_       HKL    dwhkl\r\n);', 'wVirtKey [in] Type: UINT --- The virtual-key code to be translated. See Virtual-Key Codes.\r\n///\r\nwScanCode [in] Type: UINT --- The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.\r\n///\r\nlpKeyState [in] Type: const BYTE* --- A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down.\r\n///\r\npwszBuff [out] Type: LPWSTR --- The buffer that receives the translated Unicode character or characters. However, this buffer may be returned without being null-terminated even though the variable name suggests that it is null-terminated.\r\n///\r\ncchBuff [in] Type: int --- The size, in characters, of the buffer pointed to by the pwszBuff parameter.\r\n///\r\nwFlags [in] Type: UINT --- The behavior of the function. If bit 0 is set, a menu is active. Bits 1 through 31 are reserved.\r\n///\r\ndwhkl [in, optional] Type: HKL --- The input locale identifier used to translate the specified code. This parameter can be any input locale identifier previously returned by the LoadKeyboardLayout function.', 'The function returns one of the following values.\r\n\r\n[table:ToUnicodeEx_Table1]', 'The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.\r\n\r\nThe parameters supplied to the ToUnicodeEx function might not be sufficient to translate the virtual-key code because a previous dead key is stored in the keyboard layout.\r\n\r\nTypically, ToUnicodeEx performs the translation based on the virtual-key code. In some cases, however, bit 15 of the wScanCode parameter can be used to distinguish between a key press and a key release.\r\n\r\nAs ToUnicodeEx translates the virtual-key code, it also changes the state of the kernel-mode keyboard buffer. This state-change affects dead keys, ligatures, alt+numpad key entry, and so on. It might also cause undesired side-effects if used in conjunction with TranslateMessage (which also changes the state of the kernel-mode keyboard buffer).', 'LoadKeyboardLayout|ToAsciiEx|VkKeyScan', '2016-09-11 04:23:44', '2016-09-11 04:23:44', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646322.aspx', '', '', '', '', ''),
('Transition-State Flag', '', 'The transition-state flag indicates whether pressing a key or releasing a key generated the keystroke message. This flag is always set to 0 for WM_KEYDOWN and WM_SYSKEYDOWN messages; it is always set to 1 for WM_KEYUP and WM_SYSKEYUP messages.', '', '', '', '', '', '2016-09-11 13:02:09', '2016-09-11 13:02:09', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('TranslateMessage', 'function', 'Translates virtual-key messages into character messages. The character messages are posted to the calling thread\'s message queue, to be read the next time the thread calls the GetMessage or PeekMessage function.', 'BOOL WINAPI TranslateMessage(\r\n  _In_ const MSG *lpMsg\r\n);', 'lpMsg [in] Type: const MSG* --- A pointer to an MSG structure that contains message information retrieved from the calling thread\'s message queue by using the GetMessage or PeekMessage function.', 'If the message is translated (that is, a character message is posted to the thread\'s message queue), the return value is nonzero.\r\n\r\nIf the message is WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, or WM_SYSKEYUP, the return value is nonzero, regardless of the translation. \r\n\r\nIf the message is not translated (that is, a character message is not posted to the thread\'s message queue), the return value is zero.', 'The TranslateMessage function does not modify the message pointed to by the lpMsg parameter. \r\n\r\nWM_KEYDOWN and WM_KEYUP combinations produce a WM_CHAR or WM_DEADCHAR message. WM_SYSKEYDOWN and WM_SYSKEYUP combinations produce a WM_SYSCHAR or WM_SYSDEADCHAR message. \r\n\r\nTranslateMessage produces WM_CHAR messages only for keys that are mapped to ASCII characters by the keyboard driver. \r\n\r\nIf applications process virtual-key messages for some other purpose, they should not call TranslateMessage. For instance, an application should not call TranslateMessage if the TranslateAccelerator function returns a nonzero value. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call IsDialogMessage. For more information, see Dialog Box Keyboard Interface.', 'GetMessage|IsDialogMessage|PeekMessage|TranslateAccelerator|WM_CHAR|WM_DEADCHAR|WM_KEYDOWN|WM_KEYUP|WM_SYSCHAR|WM_SYSDEADCHAR|WM_SYSKEYDOWN|WM_SYSKEYUP', '2016-08-25 05:30:07', '2016-08-25 05:30:07', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644955.aspx', '', '', '', '', ''),
('TRANSMSG', 'structure', 'Contains transferred message, used by ImeToAsciiEx to receive IME generated \r\nmessage.', 'typedef struct {\r\n    UINT message;\r\n    WPARAM wParam;\r\n    LPARAM lParam;\r\n} TRANSMSG;', 'message --- Specify message to identify.\r\n///\r\nwParam --- Specify additional information about the message. The exact meaning depends on the value of the message member.\r\n///\r\nlParam --- Specify additional information about the message. The exact meaning depends on the value of the message member.', '', 'This structure is added for future 64-bit Windows NT platform. This structure will be used together with \r\nTRANSMSGLIST by ImeToAsciiEx to replace the formerly used LPDWORD lpdwTransBuf. Using this \r\nstructure will still keep the data in memory with the same offset and keep backward compatible.', 'ImeToAsciiEx|TRANSMSGLIST', '2016-09-10 03:59:22', '2016-09-10 03:59:22', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('TRANSMSGLIST', 'structure', 'Contains transferred message list returned from ImeToAsciiEx.', 'typedef struct {\r\n    UINT uMsgCount;\r\n    TRANSMSG TransMsg[1];\r\n} TRANSMSGLIST;', 'uMsgCount --- Specify the message number in TransMsg array.\r\n///\r\nTransMsg --- Includes TRANSMSG data array.', '', 'This structure is added for future 64-bit Windows NT platform. This structure will be used by ImeToAsciiEx to \r\nreplace the formerly used LPDWORD lpdwTransBuf. Using this structure will still keep the data in memory with \r\nthe same offset and keep backward compatible.', 'ImeToAsciiEx|TRANSMSG', '2016-09-10 04:00:38', '2016-09-10 04:00:38', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('UI Class from IME', '', 'In this design, every IME is expected to register its own UI class for the system. The UI class provided by each IME should be responsible for IME-specific functionality. The IME may register the classes that are used by the IME itself when the IME is attached to the process. This occurs when DllEntry is called with DLL_PROCESS_ATTACH. The IME then has to set the UI class name in the lpszClassName parameter, which is the second parameter of ImeInquire.\r\n\r\nThe UI class should be registered with CS_IME specified in the style field so every application can use it through the IME class. The UI class name (including the null terminator) can consist of up to 16 characters and may be increased in future versions.\r\n\r\nThe cbWndExtra of the UI class has to be 2 * sizeof(LONG_PTR). The purpose of this WndExtra is defined by the system (for example, IMMGWLP_IMC and IMMGWLP_PRIVATE).\r\n\r\nThe IME can register any class and create any window while working in an application.', '', '', '', '', 'ImeInquire', '2016-09-10 08:37:30', '2016-09-10 08:37:30', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('UI Window', '', 'The IME windows of the IME class are created by the application or by the system. When the IME window is created, the UI window provided by the IME itself is created and owned by the IME window.\r\n\r\nEach UI window contains the current Input Context. This Input Context can be obtained by calling GetWindowLongPtr with IMMGWLP_IMC when the UI window receives a WM_IME_xxx message. The UI window can refer to this Input Context and handles the messages. The Input Context from GetWindowLongPtr with IMMGWLP_IMC is available at any time during the UI window procedure, except when handling a WM_CREATE message.\r\n\r\nThe cbWndExtra of the UI windows cannot be enhanced by the IME. When the IME needs to use the extra byte of the window instance, the UI window uses SetWindowLongPtr and GetWindowLongPtr with IMMGWLP_PRIVATE. This IMMGWLP_PRIVATE provides a LONG_PTR value extra of the window instance. When the UI window needs more than one LONG_PTR value extra for private use, the UI window can place a handle for a memory block into the IMMGWLP_PRIVATE area. The UI window procedure can use DefWindowProc, but the UI window cannot pass a WM_IME_xxx message to DefWindowProc. Even if the message is not handled by the UI window procedure, the UI window does not pass it to DefWindowProc.\r\n\r\nThe UI window must perform all tasks by referring to the Input Context that is currently selected. When a window of an application is activated, the UI window receives a message that contains the current Input Context. The UI window then uses that Input Context. Thus, the Input Context must contain all the information needed by the UI window to display the composition window, the status window, and so forth.\r\n\r\nThe UI window refers to the Input Context, but does not need to update it. However, if the UI window wants to update the Input Context, it should call the IMM functions. Because the Input Context is managed by the IMM, the IMM along with the IME should be notified when the Input Context is changed.\r\n\r\nFor example, the UI window occasionally needs to change the conversion mode of the Input Context when the user clicks the mouse. At this point, the UI window should call ImmSetConversionStatus. The ImmSetConversionStatusfunction creates a notification for NotifyIME and the UI window with WM_IME_NOTIFY. If the UI window wants to change the display of the conversion mode, the UI window should wait for a WM_IME_NOTIFY message.', '', '', '', '', 'DefWindowProc|ImmSetConversionStatus|WM_IME_NOTIFY|GetWindowLongPtr|SetWindowLongPtr', '2016-09-10 08:41:48', '2016-09-10 08:41:48', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Unicode', '', 'Unicode is a worldwide character-encoding standard. The system uses Unicode exclusively for character and string manipulation. For a detailed description of all aspects of Unicode, refer to The Unicode Standard.\r\n\r\nCompared to older mechanisms for handling character and string data, Unicode simplifies software localization and improves multilingual text processing. By using Unicode to represent character and string data in your applications, you can enable universal data exchange capabilities for global marketing, using a single binary file for every possible character code. Unicode does the following:\r\n\r\n * Allows any combination of characters, drawn from any combination of scripts and languages, to co-exist in a single document.\r\n * Defines semantics for each character.\r\n * Standardizes script behavior.\r\n * Provides a standard algorithm for bidirectional text.\r\n * Defines cross-mappings to other standards.\r\n * Defines multiple encodings of its single character set: UTF-7, UTF-8, UTF-16, and UTF-32. Conversion of data among these encodings is lossless.\r\n\r\nUnicode supports numerous scripts used by languages around the world, and also a large number of technical symbols and special characters used in publishing. The supported scripts include, but are not limited to, Latin, Greek, Cyrillic, Hebrew, Arabic, Devanagari, Thai, Han, Hangul, Hiragana, and Katakana. Supported languages include, but are not limited to, German, French, English, Greek, Russian, Hebrew, Arabic, Hindi, Thai, Chinese, Korean, and Japanese. Unicode currently can represent the vast majority of characters in modern computer use around the world, and continues to be updated to make it even more complete.\r\n\r\nUnicode-enabled functions are described in Conventions for Function Prototypes. These functions use UTF-16 (wide character) encoding, which is the most common encoding of Unicode and the one used for native Unicode encoding on Windows operating systems. Each code value is 16 bits wide, in contrast to the older code page approach to character and string data, which uses 8-bit code values. The use of 16 bits allows the direct encoding of 65,536 characters. In fact, the universe of symbols used to transcribe human languages is even larger than that, and UTF-16 code points in the range U+D800 through U+DFFF are used to form surrogate pairs, which constitute 32-bit encodings of supplementary characters. See Surrogates and Supplementary Characters for further discussion.\r\n\r\nThe Unicode character set includes numerous combining characters, such as U+0308 (\"¨\"), a combining dieresis or umlaut. Unicode can often represent the same glyph in either a \'\'composed\'\' or a \'\'decomposed\'\' form: for example, the composed form of \"Ä\" is the single Unicode code point \"Ä\" (U+00C4), while its decomposed form is \"A\" + \"¨\" (U+0041 U+0308). Unicode does not define a composed form for every glyph. For example, the Vietnamese lowercase \"o\" with circumflex and tilde (\"ỗ\") is represented by U+006f U+0302 U+0303 (o + Circumflex + Tilde). For further discussion of combining characters and related issues, see Using Unicode Normalization to Represent Strings.\r\n\r\nFor compatibility with 8-bit and 7-bit environments, Unicode can also be encoded as UTF-8 and UTF-7, respectively. While Unicode-enabled functions in Windows use UTF-16, it is also possible to work with data encoded in UTF-8 or UTF-7, which are supported in Windows as multibyte character set code pages.\r\n\r\nNew Windows applications should use UTF-16 as their internal data representation. Windows also provides extensive support for code pages, and mixed use in the same application is possible. Even new Unicode-based applications sometimes have to work with code pages. Reasons for this are discussed in Code Pages.\r\n\r\nAn application can use the MultiByteToWideChar and WideCharToMultiByte functions to convert between strings based on code pages and Unicode strings. Although their names refer to \"MultiByte\", these functions work equally well with single-byte character set (SBCS), double-byte character set (DBCS), and multibyte character set (MBCS) code pages.\r\n\r\nTypically, a Windows application should use UTF-16 internally, converting only as part of a \"thin layer\" over the interface that must use another format. This technique defends against loss and corruption of data. Each code page supports different characters, but none of them supports the full spectrum of characters provided by Unicode. Most of the code pages support different subsets, differently encoded. The code pages for UTF-8 and UTF-7 are an exception, since they support the complete Unicode character set, and conversion between these encodings and UTF-16 is lossless.\r\n\r\nData converted directly from the encoding used by one code page to the encoding used by another is subject to corruption, because the same data value on different code pages can encode a different character. Even when your application is converting as close to the interface as possible, you should think carefully about the range of data to handle.\r\n\r\nData converted from Unicode to a code page is subject to data loss, because a given code page might not be able to represent every character used in that particular Unicode data. Therefore, note that WideCharToMultiByte might lose some data if the target code page cannot represent all of the characters in the Unicode string.\r\n\r\nWhen modernizing code page-based legacy applications to use Unicode, you can use generic functions and the TEXT macro to maintain a single set of sources from which to compile two versions of your application. One version supports Unicode and the other one works with Windows code pages. Using this mechanism, you can convert even very large applications from Windows code pages to Unicode while maintaining application sources that can be compiled, built, and tested at all phases of the conversion. For more information, see Conventions for Function Prototypes.\r\n\r\nUnicode characters and strings use data types that are distinct from those for code page-based characters and strings. Along with a series of macros and naming conventions, this distinction minimizes the chance of accidentally mixing the two types of character data. It facilitates compiler type checking to ensure that only Unicode parameter values are used with functions expecting Unicode strings.', '', '', '', '', '', '2016-09-17 07:02:40', '2016-09-17 07:02:40', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374081.aspx', '', '', '', '', ''),
('Unicode and Character Sets', '', 'Microsoft Windows provides support for the many different written languages of the international marketplace through Unicode and traditional character sets.\r\n\r\nUnicode is a worldwide character encoding standard that provides a unique number to represent each character used in modern computing, including technical symbols and special characters used in publishing. Unicode is required by modern standards, such as XML and ECMAScript (JavaScript), and is the official mechanism for implementing ISO/IEC 10646. It is supported by many operating systems, all modern browsers, and many other products. New Windows applications should use Unicode to avoid the inconsistencies of varied code pages and to aid in simplifying localization.\r\n\r\nTraditional character sets are the previous character encoding standards — such as Windows code pages that use 8-bit code values or combinations of 8-bit values to represent the characters used in a specific language or geographical region.', '', '', '', '', '', '2016-09-17 06:48:22', '2016-09-17 06:48:22', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374083.aspx', '', '', '', '', ''),
('Unicode in the Windows API', '', 'Windows API functions that manipulate characters are generally implemented in one of three formats:\r\n\r\n * A generic version that can be compiled for either Windows code pages or Unicode\r\n * A Windows code page version with the letter \"A\" used to indicate \"ANSI\"\r\n * A Unicode version with the letter \"W\" used to indicate \"wide\"\r\n\r\nSome newer functions support only Unicode versions. For more information, see Conventions for Function Prototypes.\r\n\r\nThe following topics discuss Unicode data types and how they are used in functions and messages; the use of resources, file names, and command line arguments; and methods of translating between different types of strings.\r\n\r\n * Automatic Message Translation \r\n * Character Sets Used in File Names \r\n * Command Line Arguments \r\n * Conventions for Function Prototypes \r\n * Standard C Functions \r\n * String Function Differences \r\n * Translation Between String Types \r\n * Windows Data Types for Strings', '', '', '', '', '', '2016-09-17 07:05:08', '2016-09-17 07:05:08', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374089.aspx', '', '', '', '', ''),
('Unicode Interface', '', 'Along with the ANSI version of the IMM/IME interface originally supported by Windows 95, Windows NT and \r\nWindows 98 support Unicode interface for the IME. To communicate with the system by Unicode interface, an IME \r\nshould set the IME_PROP_UNICODE bit of the fdwProperty member of the IMEINFO structure, which is the first \r\nparameter of the ImeInquire function. Although ImeInquire is called to initialize the IME for every thread of the \r\napplication process, the IME is expected to return the same IMEINFO structure on a single system. Windows 98 \r\nsupports all the Unicode functions, except for ImmIsUIMessage.', '', '', '', '', 'IMEINFO|ImeInquire|ImmIsUIMessage', '2016-09-10 09:29:00', '2016-09-10 09:29:00', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('UnloadKeyboardLayout', 'function', 'Unloads an input locale identifier (formerly called a keyboard layout).', 'BOOL WINAPI UnloadKeyboardLayout(\r\n  _In_ HKL hkl\r\n);', 'hkl [in] Type: HKL --- The input locale identifier to be unloaded.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. The function can fail for the following reasons: \r\n\r\n * An invalid input locale identifier was passed.\r\n * The input locale identifier was preloaded.\r\n * The input locale identifier is in use.\r\n\r\nTo get extended error information, call GetLastError.', 'The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input. \r\n\r\nUnloadKeyboardLayout cannot unload the system default input locale identifier if it is the only keyboard layout loaded. You must first load another input locale identifier before unloading the default input locale identifier.', 'ActivateKeyboardLayout|GetKeyboardLayoutName|LoadKeyboardLayout', '2016-09-11 04:26:19', '2016-09-11 04:26:19', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646324.aspx', '', '', '', '', ''),
('UnregisterHotKey', 'function', 'Frees a hot key previously registered by the calling thread.', 'BOOL WINAPI UnregisterHotKey(\r\n  _In_opt_ HWND hWnd,\r\n  _In_     int  id\r\n);', 'hWnd [in, optional] Type: HWND --- A handle to the window associated with the hot key to be freed. This parameter should be NULL if the hot key is not associated with a window. \r\n///\r\nid [in] Type: int --- The identifier of the hot key to be freed.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError.', '', 'RegisterHotKey', '2016-09-11 04:27:42', '2016-09-11 04:27:42', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646327.aspx', '', '', '', '', ''),
('Using lpTransMsgList to Generate Messages', '', 'Events initiated by IMEs are realized as generating messages to the window associated with the Input Context. Basically, IMEs use the lpTransMsgList provided by the parameter of ImeToAsciiEx to generate the message. The IMEs put the messages into the lpTransMsgList buffer when ImeToAsciiEx is called.\r\n\r\nThe buffer specified by lpTransMsgList in the ImeToAsciiEx function is provided by the system. This function can place messages in this buffer all at one time. The real number of messages that can be placed is given at the first double word of the buffer. However, if the ImeToAsciiEx function wants to generate more messages than the given number, ImeToAsciiEx can put all the messages into hMsgBuf in the Input Context and then return the number of messages.\r\n\r\nWhen the return value of ImeToAsciiEx is larger than the specified value in lpTransMsgList, the system does not pick up the messages from lpTransMsgList. Instead, the system looks up hMsgBuf in the Input Context, which is passed as a parameter of ImeToAsciiEx.', '', '', '', '', 'ImeToAsciiEx', '2016-09-10 08:55:38', '2016-09-10 08:55:38', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Using Supplementary Characters', '', 'UTF-16 handles supplementary characters as surrogate pairs. The operating system processes a surrogate pair similarly to the way it processes nonspacing marks. At display time, the surrogate pair displays as one glyph by means of Uniscribe, as prescribed by the Unicode Standard.\r\n\r\nWindows Vista introduces three new macros to help identify surrogates and surrogate pairs in UTF-16 strings. These are IS_HIGH_SURROGATE, IS_LOW_SURROGATE, and IS_SURROGATE_PAIR.\r\n\r\nApplications automatically support supplementary characters if they support Unicode and use system controls and standard API functions, such as ExtTextOut and DrawText. Thus, if your application uses standard system controls or uses general ExtTextOut-type calls to display, supplementary characters should work without any special coding.\r\n\r\nApplications that implement their own editing support by working out glyph positions in a customized way can use Uniscribe for all text processing. Uniscribe has separate functions to deal with complex script processing, such as text display, hit testing, and cursor movement. An application must call the Uniscribe functions specifically to get these advanced features. Note that applications using the Uniscribe functions are fully multilingual, but this imposes a performance penalty. Thus some applications should do their own processing of supplementary characters.\r\n\r\nBecause the surrogate mechanism to represent supplementary characters is well-defined, your application can include code to handle UTF-16 surrogate text processing. When the application encounters a separated UTF-16 value from either the lower reserved surrogate range (a low surrogate) or the upper reserved surrogate range (a high surrogate), the value must be one half of a surrogate pair. Thus, the application can detect a surrogate pair by doing simple range checking. If it encounters a UTF-16 value in the lower or upper range, it must track backward or forward one 16-bit width to get the rest of the character. When writing your application, keep in mind that CharNext and CharPrev move by 16-bit code points, not by surrogate pairs.\r\n\r\nNote: Standalone surrogate code points have either a high surrogate without an adjacent low surrogate, or vice versa. These code points are invalid and are not supported. Their behavior is undefined.\r\n\r\nIf you are developing a font or IME provider, note that pre-Windows XP operating systems disable supplementary character support by default. Windows XP and later enable supplementary characters by default. If you provide a font and IME package that requires supplementary characters, your application must set the following registry values:\r\n\r\n<pre>[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\LanguagePack]\r\nSURROGATE=(REG_DWORD)0x00000002\r\n \r\n[HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\International\\Scripts\\42]\r\nIEFixedFontName=[Surrogate Font Face Name]\r\nIEPropFontName=[Surrogate Font Face Name]</pre>', '', '', '', '', '', '2016-09-17 07:00:59', '2016-09-17 07:00:59', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069.aspx', '', '', '', '', ''),
('Using the Input Context', '', 'When an application or system creates a new Input Context, the system prepares the new Input Context with the components of the IMC (IMCC). These include hCompStr, hCandInfo, hGuideLine, hPrivate, and hMsgBuf. Basically, the IME does not need to create the Input Context and the components of the Input Context. The IME can change the size of them and lock them to get the pointer for them.\r\n\r\n * Accessing the HIMC\r\n * Accessing the HIMCC', '', '', '', '', 'Accessing the HIMC|Accessing the HIMCC', '2016-09-10 08:49:29', '2016-09-10 08:49:29', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Using the Message Buffer to Generate Messages', '', 'Even if ImeToAsciiEx is not called, IMEs can still generate the message to the window associated with the Input Context by using the message buffer of the Input Context. This message buffer operates as a handle of a memory block and the IME puts the messages into this memory block. The IME then calls the ImmGenerateMessage function, which sends the messages stored in the message buffer to the proper window.', '', '', '', '', 'ImeToAsciiEx|ImmGenerateMessage', '2016-09-10 08:57:19', '2016-09-10 08:57:19', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Virtual-Key Codes', '', 'The following table shows the symbolic constant names, hexadecimal values, and mouse or keyboard equivalents for the virtual-key codes used by the system. The codes are listed in numeric order.\r\n\r\n[table:Virtual-Key Codes_Table1]', '', '', '', '', '', '2016-09-11 02:19:34', '2016-09-11 02:19:34', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731', '', '', '', '', ''),
('Virtual-Key Codes Described', '', 'The wParam parameter of a keystroke message contains the virtual-key code of the key that was pressed or released. A window procedure processes or ignores a keystroke message, depending on the value of the virtual-key code.\r\n\r\nA typical window procedure processes only a small subset of the keystroke messages that it receives and ignores the rest. For example, a window procedure might process only WM_KEYDOWN keystroke messages, and only those that contain virtual-key codes for the cursor movement keys, shift keys (also called control keys), and function keys. A typical window procedure does not process keystroke messages from character keys. Instead, it uses the TranslateMessage function to convert the message into character messages. For more information about TranslateMessage and character messages, see Character Messages.', '', '', '', '', '', '2016-09-11 12:57:27', '2016-09-11 12:57:27', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', '', '', '', '', ''),
('VkKeyScan', 'function', '[This function has been superseded by the VkKeyScanEx function. You can still use VkKeyScan, however, if you do not need to specify a keyboard layout.]\r\n\r\nTranslates a character to the corresponding virtual-key code and shift state for the current keyboard.', 'SHORT WINAPI VkKeyScan(\r\n  _In_ TCHAR ch\r\n);', 'ch [in] Type: TCHAR --- The character to be translated into a virtual-key code.', 'If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state, which can be a combination of the following flag bits. \r\n\r\n[table:VkKeyScan_Table1]\r\n\r\nIf the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.', 'For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.\r\n\r\nTranslations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate characters into keystrokes from the main keyboard section only. For example, the character \"7\" is translated into VK_7, not VK_NUMPAD7.\r\n\r\nVkKeyScan is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.', 'GetAsyncKeyState|GetKeyboardState|GetKeyNameText|GetKeyState|SetKeyboardState|VkKeyScanEx|WM_KEYDOWN|WM_KEYUP', '2016-09-11 04:29:43', '2016-09-11 04:29:43', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646329.aspx', '', '', '', '', ''),
('VkKeyScanEx', 'function', 'Translates a character to the corresponding virtual-key code and shift state. The function translates the character using the input language and physical keyboard layout identified by the input locale identifier.', 'SHORT WINAPI VkKeyScanEx(\r\n  _In_ TCHAR ch,\r\n  _In_ HKL   dwhkl\r\n);', 'ch [in] Type: TCHAR --- The character to be translated into a virtual-key code. \r\n///\r\ndwhkl [in] Type: HKL --- Input locale identifier used to translate the character. This parameter can be any input locale identifier previously returned by the LoadKeyboardLayout function.', 'If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state, which can be a combination of the following flag bits. \r\n\r\n[table:VkKeyScanEx_Table1]\r\n\r\nIf the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.', 'The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.\r\n\r\nFor keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.\r\n\r\nTranslations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate characters into keystrokes from the main keyboard section only. For example, the character \"7\" is translated into VK_7, not VK_NUMPAD7. \r\n\r\nVkKeyScanEx is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.', 'GetAsyncKeyState|GetKeyboardState|GetKeyNameText|GetKeyState|LoadKeyboardLayout|SetKeyboardState|ToAsciiEx', '2016-09-11 04:32:45', '2016-09-11 04:32:45', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646332.aspx', '', '', '', '', ''),
('WaitMessage', 'function', 'Yields control to other threads when a thread has no other messages in its message queue. The WaitMessage function suspends the thread and does not return until a new message is placed in the thread\'s message queue.', 'BOOL WINAPI WaitMessage(void);', 'This function has no parameters.', 'If the function succeeds, the return value is nonzero.\r\n\r\nIf the function fails, the return value is zero. To get extended error information, call GetLastError.', 'Note that WaitMessage does not return if there is unread input in the message queue after the thread has called a function to check the queue. This is because functions such as PeekMessage, GetMessage, GetQueueStatus, WaitMessage, MsgWaitForMultipleObjects, and MsgWaitForMultipleObjectsEx check the queue and then change the state information for the queue so that the input is no longer considered new. A subsequent call to WaitMessage will not return until new input of the specified type arrives. The existing unread input (received prior to the last time the thread checked the queue) is ignored.', 'GetMessage|PeekMessage|WaitMessage', '2016-08-25 05:31:09', '2016-08-25 05:31:09', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644956.aspx', '', '', '', '', ''),
('Win32 IME Structure', '', 'A new Win32 IME has to provide two components. One is the IME Conversion Interface and the other is the IME \r\nUser Interface. The IME Conversion Interface is provided as a set of functions that are exported from the IME \r\nmodule. These functions are called by the IMM. The IME User Interface is provided in the form of windows. These \r\nwindows receive messages and provide the user interface for the IME.', '', '', '', '', '', '2016-09-10 08:28:27', '2016-09-10 08:28:27', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('Window Procedure', '', 'A window procedure is a function that receives and processes all messages sent to the window. Every window class has a window procedure, and every window created with that class uses that same window procedure to respond to messages. \r\n\r\nThe system sends a message to a window procedure by passing the message data as arguments to the procedure. The window procedure then performs an appropriate action for the message; it checks the message identifier and, while processing the message, uses the information specified by the message parameters. \r\n\r\nA window procedure does not usually ignore a message. If it does not process a message, it must send the message back to the system for default processing. The window procedure does this by calling the DefWindowProc function, which performs a default action and returns a message result. The window procedure must then return this value as its own message result. Most window procedures process just a few messages and pass the others on to the system by calling DefWindowProc. \r\n\r\nBecause a window procedure is shared by all windows belonging to the same class, it can process messages for several different windows. To identify the specific window affected by the message, a window procedure can examine the window handle passed with a message. For more information about window procedures, see Window Procedures.', '', '', '', '', 'DefWindowProc', '2016-09-03 06:54:34', '2016-09-03 06:54:34', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'Message Loop', 'Message Filtering'),
('Windows Messages', '', 'The system passes input to a window procedure in the form of a message. Messages are generated by both the system and applications. The system generates a message at each input event—for example, when the user types, moves the mouse, or clicks a control such as a scroll bar. The system also generates messages in response to changes in the system brought about by an application, such as when an application changes the pool of system font resources or resizes one of its windows. An application can generate messages to direct its own windows to perform tasks or to communicate with windows in other applications. \r\n\r\nThe system sends a message to a window procedure with a set of four parameters: a window handle, a message identifier, and two values called message parameters. The window handle identifies the window for which the message is intended. The system uses it to determine which window procedure should receive the message. \r\n\r\nA message identifier is a named constant that identifies the purpose of a message. When a window procedure receives a message, it uses a message identifier to determine how to process the message. For example, the message identifier WM_PAINT tells the window procedure that the window\'s client area has changed and must be repainted. \r\n\r\nMessage parameters specify data or the location of data used by a window procedure when processing a message. The meaning and value of the message parameters depend on the message. A message parameter can contain an integer, packed bit flags, a pointer to a structure containing additional data, and so on. When a message does not use message parameters, they are typically set to NULL. A window procedure must check the message identifier to determine how to interpret the message parameters.', '', '', '', '', '', '2016-09-03 06:40:29', '2016-09-03 06:40:29', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', '', '', '', 'About Messages and Message Queues', 'Message Types'),
('Winlogon', '', 'Since a user in the log-on session has not been granted the access right to the system yet, information provided by \r\nan IME’s configuration dialog boxes can create security problems. Even though, the system administrator can \r\nconfigure the system so such an IME cannot be activated on the log-on session. A well-behaved IME should not \r\nallow users to open configure dialog boxes if the client process is a Winlogon process. An IME can check if the \r\nclient process executing a log-on session is a Winlogon process by checking the \r\nIME_SYSTEMINFO_WINLOGON bit of the dwSystemInfoFlags parameter of ImeInquire.', '', '', '', '', 'ImeInquire', '2016-09-10 09:25:29', '2016-09-10 09:25:29', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', '', '', '', '', ''),
('WM_CHAR', 'message', 'Posted to the window with the keyboard focus when a WM_KEYDOWN message is translated by the TranslateMessage function. The WM_CHAR message contains the character code of the key that was pressed.', 'WM_CHAR', 'wParam --- The character code of the key. \r\n///\r\nlParam --- The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in the following table.\r\n\r\n[table:WM_CHAR_Table1]', 'An application should return zero if it processes this message.', 'The WM_CHAR message uses Unicode Transformation Format (UTF)-16.  \r\n\r\nBecause there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the information in the high-order word of the lParam parameter is generally not useful to applications. The information in the high-order word applies only to the most recent WM_KEYDOWN message that precedes the posting of the WM_CHAR message. \r\n\r\nFor enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the lParam parameter. \r\n\r\nThe WM_UNICHAR message is the same as WM_CHAR, except it uses UTF-32. It is designed to send or post Unicode characters to ANSI windows, and it can handle Unicode Supplementary Plane characters.', 'WM_KEYDOWN|WM_KEYUP|WM_IME_CHAR', '2016-09-01 09:57:21', '2016-09-01 09:57:21', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646276.aspx', '', '', '', '', ''),
('WM_IME_CHAR', 'message', 'Sent to an application when the IME gets a character of the conversion result. A window receives this message through its WindowProc function.', 'WM_IME_CHAR', 'hwnd --- A handle to window.\r\n///\r\nwParam --- DBCS: A single-byte or double-byte character value. For a double-byte character, (BYTE)(wParam >> 8) contains the lead byte. Note that the parentheses are necessary because the cast operator has higher precedence than the shift operator.\r\n\r\nUnicode: A Unicode character value.\r\n///\r\nlParam --- The repeat count, scan code, extended key flag, context code, previous key state flag, and transition state flag, with values as defined below.\r\n\r\n[table:WM_IME_CHAR_Table1]', '', 'Unlike the WM_CHAR message for a non-Unicode window, this message can include double-byte and single-byte character values. For a Unicode window, this message is the same as WM_CHAR.\r\n\r\nFor a non-Unicode window, if the WM_IME_CHAR message includes a double-byte character and the application passes this message to DefWindowProc, the IME converts this message into two WM_CHAR messages, each containing one byte of the double-byte character.', 'WM_IME_KEYDOWN|WM_IME_KEYUP|WM_CHAR', '2016-08-25 04:52:17', '2016-08-25 04:52:17', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374132.aspx', '', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('WM_IME_COMPOSITION', 'message', 'Sent to an application when the IME changes composition status as a result of a keystroke. A window receives this message through its WindowProc function.', 'WM_IME_COMPOSITION', 'hwnd --- A handle to window.\r\n///\r\nwParam  --- DBCS character representing the latest change to the composition string.\r\n///\r\nlParam --- Value specifying how the composition string or character changed. This parameter can be one or more of the following values. For more information about these values, see IME Composition String Values.\r\n\r\n * GCS_COMPATTR\r\n * GCS_COMPCLAUSE\r\n * GCS_COMPREADSTR\r\n * GCS_COMPREADATTR\r\n * GCS_COMPREADCLAUSE\r\n * GCS_COMPSTR\r\n * GCS_CURSORPOS\r\n * GCS_DELTASTART\r\n * GCS_RESULTCLAUSE\r\n * GCS_RESULTREADCLAUSE\r\n * GCS_RESULTREADSTR\r\n * GCS_RESULTSTR\r\n\r\nThe lParam parameter can also have one or more of the following values.\r\n\r\n[table:WM_IME_COMPOSITION_Table1]', 'This message has no return value.', 'An application should process this message if it displays composition characters itself. Otherwise, it should send the message to the IME window.\r\n\r\nIf the application has created an IME window, it should pass this message to that window. The DefWindowProc function processes this message by passing it to the default IME window. The IME window processes this message by updating its appearance based on the change flag specified. An application can call ImmGetCompositionString to retrieve the new composition status.\r\n\r\nIf none of the GCS_ values are set, the message indicates that the current composition has been canceled and applications that draw the composition string should delete the string.', 'WM_IME_STARTCOMPOSITION|WM_IME_ENDCOMPOSITION|ImmGetCompositionString', '2016-08-25 04:53:39', '2016-08-25 04:53:39', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374133.aspx', '', '', '', '', ''),
('WM_IME_COMPOSITIONFULL', 'message', 'Sent to an application when the IME window finds no space to extend the area for the composition window. A window receives this message through its WindowProc function.', 'WM_IME_COMPOSITIONFULL', 'This message has no parameters.', 'This message has no return value.', 'The application should use the IMC_SETCOMPOSITIONWINDOW command to specify how the window should be displayed.\r\n\r\nThe IME window, instead of the IME, sends this notification message by the SendMessage function.', 'WM_IME_COMPOSITION', '2016-08-25 04:54:50', '2016-08-25 04:54:50', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374134.aspx', '', '', '', '', ''),
('WM_IME_CONTROL', 'message', 'Sent by an application to direct the IME window to carry out the requested command. The application uses this message to control the IME window that it has created. To send this message, the application calls the SendMessage function with the following parameters.', 'WM_IME_CONTROL', 'hwnd --- Handle to the window.\r\n///\r\nwParam --- The command. This parameter can have one of the following values:\r\n\r\n * IMC_CLOSESTATUSWINDOW\r\n * IMC_GETCANDIDATEPOS\r\n * IMC_GETCOMPOSITIONFONT\r\n * IMC_GETCOMPOSITIONWINDOW\r\n * IMC_GETSTATUSWINDOWPOS\r\n * IMC_OPENSTATUSWINDOW\r\n * IMC_SETCANDIDATEPOS\r\n * IMC_SETCOMPOSITIONFONT\r\n * IMC_SETCOMPOSITIONWINDOW\r\n * IMC_SETSTATUSWINDOWPOS\r\n///\r\nlParam  --- Command-specific data, with format dependent on the value of the wParam parameter. For more information, refer to the documentation for each command.', 'The message returns a command-specific value.', '', 'IMC_CLOSESTATUSWINDOW|IMC_GETCANDIDATEPOS|IMC_GETCOMPOSITIONFONT|IMC_GETCOMPOSITIONWINDOW|IMC_GETSTATUSWINDOWPOS|IMC_OPENSTATUSWINDOW|IMC_SETCANDIDATEPOS|IMC_SETCOMPOSITIONFONT|IMC_SETCOMPOSITIONWINDOW|IMC_SETSTATUSWINDOWPOS', '2016-08-25 04:56:11', '2016-08-25 04:56:11', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374135.aspx', '', '', '', '', ''),
('WM_IME_ENDCOMPOSITION', 'message', 'Sent to an application when the IME ends composition. A window receives this message through its WindowProc function.', 'WM_IME_ENDCOMPOSITION', 'This message has no parameters.', 'This message has no return value.', 'An application should process this message if it displays composition characters itself.\r\n\r\nIf the application has created an IME window, it should pass this message to that window. The DefWindowProc function processes this message by passing it to the default IME window.', 'WM_IME_STARTCOMPOSITION|WM_IME_COMPOSITION|DefWindowProc', '2016-08-25 04:56:57', '2016-08-25 04:56:57', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374136.aspx', '', '', '', '', ''),
('WM_IME_KEYDOWN', 'message', 'Sent to an application by the IME to notify the application of a key press and to keep message order. A window receives this message through its WindowProc function.', 'WM_IME_KEYDOWN', 'hwnd --- A handle to window.\r\n///\r\nwParam --- Virtual key code of the key.\r\n///\r\nlParam --- Repeat count, scan code, extended key flag, context code, previous key state flag, and transition state flag, as shown in the following table.\r\n\r\n[table:WM_IME_KEYDOWN_Table1]', 'An application should return 0 if it processes this message.', 'An application can process this message or pass it to the DefWindowProc function to generate a matching WM_KEYDOWN message.', 'WM_IME_KEYUP|WM_KEYDOWN', '2016-08-25 04:57:52', '2016-08-25 04:57:52', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374137.aspx', '', '', '', '', ''),
('WM_IME_KEYUP', 'message', 'Sent to an application by the IME to notify the application of a key release and to keep message order. A window receives this message through its WindowProc function.', 'WM_IME_KEYUP', 'hwnd --- A handle to window.\r\n///\r\nwParam --- Virtual key code of the key.\r\n///\r\nlParam --- Repeat count, scan code, extended key flag, context code, previous key state flag, and transition state flag, as shown below.\r\n\r\n[table:WM_IME_KEYUP_Table1]', 'An application should return 0 if it processes this message.', 'An application can process this message or pass it to the DefWindowProc function to generate a matching WM_KEYUP message.', 'WM_IME_KEYDOWN|WM_KEYUP', '2016-08-25 04:59:21', '2016-08-25 04:59:21', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374138.aspx', '', '', '', '', ''),
('WM_IME_NOTIFY', 'message', 'Sent to an application to notify it of changes to the IME window. A window receives this message through its WindowProc function.', 'WM_IME_NOTIFY', 'hwnd --- A handle to window.\r\n///\r\nwParam  --- The command. This parameter can have one of the following values.\r\n\r\n * IMN_CHANGECANDIDATE\r\n * IMN_CLOSECANDIDATE\r\n * IMN_CLOSESTATUSWINDOW\r\n * IMN_GUIDELINE\r\n * IMN_OPENCANDIDATE\r\n * IMN_OPENSTATUSWINDOW\r\n * IMN_SETCANDIDATEPOS\r\n * IMN_SETCOMPOSITIONFONT\r\n * IMN_SETCOMPOSITIONWINDOW\r\n * IMN_SETCONVERSIONMODE\r\n * IMN_SETOPENSTATUS\r\n * IMN_SETSENTENCEMODE\r\n * IMN_SETSTATUSWINDOWPOS\r\n///\r\nlParam --- Command-specific data, with format dependent on the value of the wParam parameter. For more information, refer to the documentation for each command.', 'The return value depends on the command sent.', 'An application processes this message if it is responsible for managing the IME window.', 'ImmNotifyIME|NotifyIME|IMN_CHANGECANDIDATE|IMN_CLOSECANDIDATE|IMN_CLOSESTATUSWINDOW|IMN_GUIDELINE|IMN_OPENCANDIDATE|IMN_OPENSTATUSWINDOW|IMN_SETCANDIDATEPOS|IMN_SETCOMPOSITIONFONT|IMN_SETCOMPOSITIONWINDOW|IMN_SETCONVERSIONMODE|IMN_SETOPENSTATUS|IMN_SETSENTENCEMODE|IMN_SETSTATUSWINDOWPOS', '2016-08-25 05:00:34', '2016-08-25 05:00:34', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374139.aspx', '', '', '', '', ''),
('WM_IME_REQUEST', 'message', 'Sent to an application to provide commands and request information. A window receives this message through its WindowProc function.', 'WM_IME_REQUEST', 'hwnd --- A handle to window.\r\n///\r\nwParam --- Command. This parameter can have one of the following values:\r\n\r\n * IMR_CANDIDATEWINDOW\r\n * IMR_COMPOSITIONFONT\r\n * IMR_COMPOSITIONWINDOW\r\n * IMR_CONFIRMRECONVERTSTRING\r\n * IMR_DOCUMENTFEED\r\n * IMR_QUERYCHARPOSITION\r\n * IMR_RECONVERTSTRING\r\n///\r\nlParam --- Command-specific data. For more information, see the description for each command.', 'Returns a command-specific value.', '', 'IMR_CANDIDATEWINDOW|IMR_COMPOSITIONFONT|IMR_COMPOSITIONWINDOW|IMR_CONFIRMRECONVERTSTRING|IMR_DOCUMENTFEED|IMR_QUERYCHARPOSITION|IMR_RECONVERTSTRING', '2016-08-25 05:01:32', '2016-08-25 05:01:32', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374140.aspx', '', '', '', '', ''),
('WM_IME_SELECT', 'message', 'Sent to an application when the operating system is about to change the current IME. A window receives this message through its WindowProc function.', 'WM_IME_SELECT', 'hwnd --- A handle to window.\r\n///\r\nwParam --- Selection indicator. This parameter specifies TRUE if the indicated IME is selected. The parameter is set to FALSE if the specified IME is no longer selected.\r\n///\r\nlParam --- Input locale identifier associated with the IME.', 'This message has no return value.', 'An application that has created an IME window should pass this message to that window so that it can retrieve the keyboard layout handle to the newly selected IME.\r\n\r\nThe DefWindowProc function processes this message by passing the information to the default IME window.', 'DefWindowProc', '2016-08-25 05:02:31', '2016-08-25 05:02:31', '<winuser.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374141.aspx', '', '', '', '', ''),
('WM_IME_SETCONTEXT', 'message', 'Sent to an application when a window is activated. A window receives this message through its WindowProc function.', 'WM_IME_SETCONTEXT', 'hwnd --- A handle to window.\r\n///\r\nwParam --- TRUE if the window is active, and FALSE otherwise.\r\n///\r\nlParam --- Display options. This parameter can have one or more of the following values.\r\n\r\n[table:WM_IME_SETCONTEXT_Table1]', 'Returns the value returned by DefWindowProc or ImmIsUIMessage.', 'If the application has created an IME window, it should call ImmIsUIMessage. Otherwise, it should pass this message to DefWindowProc.\r\n\r\nIf the application draws the composition window, the default IME window does not have to show its composition window. In this case, the application must clear the ISC_SHOWUICOMPOSITIONWINDOW value from the lParam parameter before passing the message to DefWindowProc or ImmIsUIMessage. To display a certain user interface window, an application should remove the corresponding value so that the IME will not display it.', 'ImmIsUIMessage|DefWindowProc', '2016-08-25 05:03:34', '2016-08-25 05:03:34', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374142.aspx', '', '', '', '', ''),
('WM_IME_STARTCOMPOSITION', 'message', 'Sent immediately before the IME generates the composition string as a result of a keystroke. A window receives this message through its WindowProc function.', 'WM_IME_STARTCOMPOSITION', 'This message has no parameters.', 'This message has no return value.', 'This message is a notification to an IME window to open its composition window. An application should process this message if it displays composition characters itself.\r\n\r\nIf an application has created an IME window, it should pass this message to that window. The DefWindowProc function processes the message by passing it to the default IME window.', 'WM_IME_COMPOSITION|WM_IME_ENDCOMPOSITION', '2016-08-25 05:04:28', '2016-08-25 05:04:28', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374143.aspx', '', '', '', '', ''),
('WM_INPUTLANGCHANGE', 'message', 'Sent to the topmost affected window after an application\'s input language has been changed. You should make any application-specific settings and pass the message to the DefWindowProc function, which passes the message to all first-level child windows. These child windows can pass the message to DefWindowProc to have it pass the message to their child windows, and so on.\r\n\r\nA window receives this message through its WindowProc function.', '#define WM_INPUTLANGCHANGE              0x0051', 'wParam --- The character set of the new locale. \r\n///\r\nlParam --- The input locale identifier. For more information, see Languages, Locales, and Keyboard Layouts.', 'An application should return nonzero if it processes this message.', '', 'Languages, Locales, and Keyboard Layouts|DefWindowProc|WM_INPUTLANGCHANGEREQUEST', '2016-09-10 06:07:19', '2016-09-10 06:07:19', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms632629.aspx', '', '', '', '', ''),
('WM_INPUTLANGCHANGEREQUEST', 'message', 'Posted to the window with the focus when the user chooses a new input language, either with the hotkey (specified in the Keyboard control panel application) or from the indicator on the system taskbar. An application can accept the change by passing the message to the DefWindowProc function or reject the change (and prevent it from taking place) by returning immediately.\r\n\r\nA window receives this message through its WindowProc function.', '#define WM_INPUTLANGCHANGEREQUEST       0x0050', 'wParam --- The new input locale. This parameter can be a combination of the following flags.\r\n\r\n[table:WM_INPUTLANGCHANGEREQUEST_Table1]\r\n///\r\nlParam --- The input locale identifier. For more information, see Languages, Locales, and Keyboard Layouts.', 'This message is posted, not sent, to the application, so the return value is ignored. To accept the change, the application should pass the message to DefWindowProc. To reject the change, the application should return zero without calling DefWindowProc.', 'When the DefWindowProc function receives the WM_INPUTLANGCHANGEREQUEST message, it activates the new input locale and notifies the application of the change by sending the WM_INPUTLANGCHANGE message.\r\n\r\nThe language indicator is present on the taskbar only if you have installed more than one keyboard layout and if you have enabled the indicator using the Keyboard control panel application.', 'Languages, Locales, and Keyboard Layouts|DefWindowProc|WM_INPUTLANGCHANGE', '2016-09-10 06:10:02', '2016-09-10 06:10:02', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms632630.aspx', '', '', '', '', ''),
('WM_KEYDOWN', 'message', 'Posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed.', 'WM_KEYDOWN', 'wParam --- The virtual-key code of the nonsystem key. See Virtual-Key Codes.\r\n///\r\nlParam --- The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown following.\r\n\r\n[table:WM_KEYDOWN_Table1]', 'An application should return zero if it processes this message.', 'If the F10 key is pressed, the DefWindowProc function sets an internal flag. When DefWindowProc receives the WM_KEYUP message, the function checks whether the internal flag is set and, if so, sends a WM_SYSCOMMAND message to the top-level window. The WM_SYSCOMMAND parameter of the message is set to SC_KEYMENU. \r\n\r\nBecause of the autorepeat feature, more than one WM_KEYDOWN message may be posted before a WM_KEYUP message is posted. The previous key state (bit 30) can be used to determine whether the WM_KEYDOWN message indicates the first down transition or a repeated down transition. \r\n\r\nFor enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter. \r\n\r\nApplications must pass wParam to TranslateMessage without altering it at all.', 'Virtual-Key Codes|DefWindowProc|WM_KEYUP|WM_CHAR', '2016-09-01 10:00:49', '2016-09-01 10:00:49', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646280.aspx', '', '', '', '', ''),
('WM_KEYUP', 'message', 'Posted to the window with the keyboard focus when a nonsystem key is released. A nonsystem key is a key that is pressed when the ALT key is not pressed, or a keyboard key that is pressed when a window has the keyboard focus.', 'WM_KEYUP', 'wParam --- The virtual-key code of the nonsystem key. See Virtual-Key Codes.\r\n///\r\nlParam --- The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in the following table.\r\n\r\n[table:WM_KEYUP_Table1]', 'An application should return zero if it processes this message.', 'The DefWindowProc function sends a WM_SYSCOMMAND message to the top-level window if the F10 key or the ALT key was released. The wParam parameter of the message is set to SC_KEYMENU. \r\n\r\nFor enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter. \r\n\r\nApplications must pass wParam to TranslateMessage without altering it at all.', 'Virtual-Key Codes|TranslateMessage|DefWindowProc|WM_KEYDOWN|WM_CHAR', '2016-09-01 10:03:59', '2016-09-01 10:03:59', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646281.aspx', '', '', '', '', '');

-- --------------------------------------------------------

--
-- テーブルの構造 `tables`
--

CREATE TABLE `tables` (
  `table_name` varchar(128) NOT NULL,
  `contents` varchar(16384) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- テーブルのデータのダンプ `tables`
--

INSERT INTO `tables` (`table_name`, `contents`) VALUES
('ABM_GETSTATE_Table1', 'Return code --- Description\r\n///\r\nABS_ALWAYSONTOP  --- The taskbar is in the always-on-top state. \r\n\r\nNote  As of Windows 7, ABS_ALWAYSONTOP is no longer returned because the taskbar is always in that state. Older code should be updated to ignore the absence of this value in not assume that return value to mean that the taskbar is not in the always-on-top state.\r\n///\r\nABS_AUTOHIDE --- The taskbar is in the autohide state.'),
('ABM_SETSTATE_Table1', 'Value --- Meaning\r\n///\r\n0 --- Autohide and always-on-top both off\r\n///\r\nABS_ALWAYSONTOP --- Always-on-top on, autohide off\r\n///\r\nABS_AUTOHIDE --- Autohide on, always-on-top off\r\n///\r\nABS_AUTOHIDE | ABS_ALWAYSONTOP --- Autohide and always-on-top both on'),
('ActivateKeyboardLayout_Table1', 'Value --- Meaning\r\n///\r\nHKL_NEXT 1 --- Selects the next locale identifier in the circular list of loaded locale identifiers maintained by the system.\r\n///\r\nHKL_PREV 0 --- Selects the previous locale identifier in the circular list of loaded locale identifiers maintained by the system.'),
('ActivateKeyboardLayout_Table2', 'Value --- Meaning\r\n///\r\nKLF_REORDER 0x00000008 --- If this bit is set, the system\'s circular list of loaded locale identifiers is reordered by moving the locale identifier to the head of the list. If this bit is not set, the list is rotated without a change of order.\r\n\r\nFor example, if a user had an English locale identifier active, as well as having French, German, and Spanish locale identifiers loaded (in that order), then activating the German locale identifier with the KLF_REORDER bit set would produce the following order: German, English, French, Spanish. Activating the German locale identifier without the KLF_REORDER bit set would produce the following order: German, Spanish, English, French.\r\n\r\nIf less than three locale identifiers are loaded, the value of this flag is irrelevant.\r\n///\r\nKLF_RESET 0x40000000 --- If set but KLF_SHIFTLOCK is not set, the Caps Lock state is turned off by pressing the Caps Lock key again. If set and KLF_SHIFTLOCK is also set, the Caps Lock state is turned off by pressing either SHIFT key.\r\n\r\nThese two methods are mutually exclusive, and the setting persists as part of the User\'s profile in the registry.\r\n///\r\nKLF_SETFORPROCESS 0x00000100 --- Activates the specified locale identifier for the entire process and sends the WM_INPUTLANGCHANGE message to the current thread\'s focus or active window.\r\n///\r\nKLF_SHIFTLOCK 0x00010000 --- This is used with KLF_RESET. See KLF_RESET for an explanation.\r\n///\r\nKLF_UNLOADPREVIOUS --- This flag is unsupported. Use the UnloadKeyboardLayout function instead.'),
('APPBARDATA_Table1', 'Value --- Meaning\r\n///\r\nABE_BOTTOM --- Bottom edge.\r\n///\r\nABE_LEFT --- Left edge.\r\n///\r\nABE_RIGHT --- Right edge.\r\n///\r\nABE_TOP --- Top edge.'),
('CANDIDATEFORM_Table1', 'Value --- Meaning\r\n///\r\nCFS_CANDIDATEPOS --- Displays the upper-left corner of the candidate list window at the position given by ptCurrentPos. The coordinates are relative to the upper-left corner of the window containing the list window and are subject to adjustment by the system. \r\n///\r\nCFS_EXCLUDE --- Exclude the candidate window from the area given by rcArea. The ptCurrentPos member specifies the coordinates of the current point of interest—typically the caret position.'),
('CANDIDATELIST_Table1', 'Value --- Meaning\r\n///\r\nIME_CAND_UNKNOWN --- Candidates are in a style other than the ones in the following list. \r\n///\r\nIME_CAND_READ --- Candidates are in the same reading. \r\n///\r\nIME_CAND_CODE --- Candidates are in a code range. \r\n///\r\nIME_CAND_MEANING --- Candidates are in the same meaning. \r\n///\r\nIME_CAND_RADICAL --- Candidates use the same radical character. \r\n///\r\nIME_CAND_STROKES --- Candidates are in the same number of strokes.'),
('Code Page Identifiers_Table1', 'Identifier --- .NET Name --- Additional information\r\n///\r\n037 --- IBM037 --- IBM EBCDIC US-Canada\r\n///\r\n437 --- IBM437 --- OEM United States\r\n///\r\n500 --- IBM500 --- IBM EBCDIC International\r\n///\r\n708 --- ASMO-708 --- Arabic (ASMO 708)\r\n///\r\n709 ---  --- Arabic (ASMO-449+, BCON V4)\r\n///\r\n710 ---  --- Arabic - Transparent Arabic\r\n///\r\n720 --- DOS-720 --- Arabic (Transparent ASMO); Arabic (DOS)\r\n///\r\n737 --- ibm737 --- OEM Greek (formerly 437G); Greek (DOS)\r\n///\r\n775 --- ibm775 --- OEM Baltic; Baltic (DOS)\r\n///\r\n850 --- ibm850 --- OEM Multilingual Latin 1; Western European (DOS)\r\n///\r\n852 --- ibm852 --- OEM Latin 2; Central European (DOS)\r\n///\r\n855 --- IBM855 --- OEM Cyrillic (primarily Russian)\r\n///\r\n857 --- ibm857 --- OEM Turkish; Turkish (DOS)\r\n///\r\n858 --- IBM00858 --- OEM Multilingual Latin 1 + Euro symbol\r\n///\r\n860 --- IBM860 --- OEM Portuguese; Portuguese (DOS)\r\n///\r\n861 --- ibm861 --- OEM Icelandic; Icelandic (DOS)\r\n///\r\n862 --- DOS-862 --- OEM Hebrew; Hebrew (DOS)\r\n///\r\n863 --- IBM863 --- OEM French Canadian; French Canadian (DOS)\r\n///\r\n864 --- IBM864 --- OEM Arabic; Arabic (864)\r\n///\r\n865 --- IBM865 --- OEM Nordic; Nordic (DOS)\r\n///\r\n866 --- cp866 --- OEM Russian; Cyrillic (DOS)\r\n///\r\n869 --- ibm869 --- OEM Modern Greek; Greek, Modern (DOS)\r\n///\r\n870 --- IBM870 --- IBM EBCDIC Multilingual/ROECE (Latin 2); IBM EBCDIC Multilingual Latin 2\r\n///\r\n874 --- windows-874 --- ANSI/OEM Thai (ISO 8859-11); Thai (Windows)\r\n///\r\n875 --- cp875 --- IBM EBCDIC Greek Modern\r\n///\r\n932 --- shift_jis --- ANSI/OEM Japanese; Japanese (Shift-JIS)\r\n///\r\n936 --- gb2312 --- ANSI/OEM Simplified Chinese (PRC, Singapore); Chinese Simplified (GB2312)\r\n///\r\n949 --- ks_c_5601-1987 --- ANSI/OEM Korean (Unified Hangul Code)\r\n///\r\n950 --- big5 --- ANSI/OEM Traditional Chinese (Taiwan; Hong Kong SAR, PRC); Chinese Traditional (Big5)\r\n///\r\n1026 --- IBM1026 --- IBM EBCDIC Turkish (Latin 5)\r\n///\r\n1047 --- IBM01047 --- IBM EBCDIC Latin 1/Open System\r\n///\r\n1140 --- IBM01140 --- IBM EBCDIC US-Canada (037 + Euro symbol); IBM EBCDIC (US-Canada-Euro)\r\n///\r\n1141 --- IBM01141 --- IBM EBCDIC Germany (20273 + Euro symbol); IBM EBCDIC (Germany-Euro)\r\n///\r\n1142 --- IBM01142 --- IBM EBCDIC Denmark-Norway (20277 + Euro symbol); IBM EBCDIC (Denmark-Norway-Euro)\r\n///\r\n1143 --- IBM01143 --- IBM EBCDIC Finland-Sweden (20278 + Euro symbol); IBM EBCDIC (Finland-Sweden-Euro)\r\n///\r\n1144 --- IBM01144 --- IBM EBCDIC Italy (20280 + Euro symbol); IBM EBCDIC (Italy-Euro)\r\n///\r\n1145 --- IBM01145 --- IBM EBCDIC Latin America-Spain (20284 + Euro symbol); IBM EBCDIC (Spain-Euro)\r\n///\r\n1146 --- IBM01146 --- IBM EBCDIC United Kingdom (20285 + Euro symbol); IBM EBCDIC (UK-Euro)\r\n///\r\n1147 --- IBM01147 --- IBM EBCDIC France (20297 + Euro symbol); IBM EBCDIC (France-Euro)\r\n///\r\n1148 --- IBM01148 --- IBM EBCDIC International (500 + Euro symbol); IBM EBCDIC (International-Euro)\r\n///\r\n1149 --- IBM01149 --- IBM EBCDIC Icelandic (20871 + Euro symbol); IBM EBCDIC (Icelandic-Euro)\r\n///\r\n1200 --- utf-16 --- Unicode UTF-16, little endian byte order (BMP of ISO 10646); available only to managed applications\r\n///\r\n1201 --- unicodeFFFE --- Unicode UTF-16, big endian byte order; available only to managed applications\r\n///\r\n1250 --- windows-1250 --- ANSI Central European; Central European (Windows)\r\n///\r\n1251 --- windows-1251 --- ANSI Cyrillic; Cyrillic (Windows)\r\n///\r\n1252 --- windows-1252 --- ANSI Latin 1; Western European (Windows)\r\n///\r\n1253 --- windows-1253 --- ANSI Greek; Greek (Windows)\r\n///\r\n1254 --- windows-1254 --- ANSI Turkish; Turkish (Windows)\r\n///\r\n1255 --- windows-1255 --- ANSI Hebrew; Hebrew (Windows)\r\n///\r\n1256 --- windows-1256 --- ANSI Arabic; Arabic (Windows)\r\n///\r\n1257 --- windows-1257 --- ANSI Baltic; Baltic (Windows)\r\n///\r\n1258 --- windows-1258 --- ANSI/OEM Vietnamese; Vietnamese (Windows)\r\n///\r\n1361 --- Johab --- Korean (Johab)\r\n///\r\n10000 --- macintosh --- MAC Roman; Western European (Mac)\r\n///\r\n10001 --- x-mac-japanese --- Japanese (Mac)\r\n///\r\n10002 --- x-mac-chinesetrad --- MAC Traditional Chinese (Big5); Chinese Traditional (Mac)\r\n///\r\n10003 --- x-mac-korean --- Korean (Mac)\r\n///\r\n10004 --- x-mac-arabic --- Arabic (Mac)\r\n///\r\n10005 --- x-mac-hebrew --- Hebrew (Mac)\r\n///\r\n10006 --- x-mac-greek --- Greek (Mac)\r\n///\r\n10007 --- x-mac-cyrillic --- Cyrillic (Mac)\r\n///\r\n10008 --- x-mac-chinesesimp --- MAC Simplified Chinese (GB 2312); Chinese Simplified (Mac)\r\n///\r\n10010 --- x-mac-romanian --- Romanian (Mac)\r\n///\r\n10017 --- x-mac-ukrainian --- Ukrainian (Mac)\r\n///\r\n10021 --- x-mac-thai --- Thai (Mac)\r\n///\r\n10029 --- x-mac-ce --- MAC Latin 2; Central European (Mac)\r\n///\r\n10079 --- x-mac-icelandic --- Icelandic (Mac)\r\n///\r\n10081 --- x-mac-turkish --- Turkish (Mac)\r\n///\r\n10082 --- x-mac-croatian --- Croatian (Mac)\r\n///\r\n12000 --- utf-32 --- Unicode UTF-32, little endian byte order; available only to managed applications\r\n///\r\n12001 --- utf-32BE --- Unicode UTF-32, big endian byte order; available only to managed applications\r\n///\r\n20000 --- x-Chinese_CNS --- CNS Taiwan; Chinese Traditional (CNS)\r\n///\r\n20001 --- x-cp20001 --- TCA Taiwan\r\n///\r\n20002 --- x_Chinese-Eten --- Eten Taiwan; Chinese Traditional (Eten)\r\n///\r\n20003 --- x-cp20003 --- IBM^5550 --- Taiwan ----\r\n///\r\n20004 --- x-cp20004 --- TeleText Taiwan\r\n///\r\n20005 --- x-cp20005 --- Wang Taiwan\r\n///\r\n20105 --- x-IA5 --- IA5 (IRV International Alphabet No. 5, 7-bit); Western European (IA5)\r\n///\r\n20106 --- x-IA5-German --- IA^5 --- German --- (7-bit)\r\n///\r\n20107 --- x-IA5-Swedish --- IA^5 --- Swedish --- (7-bit)\r\n///\r\n20108 --- x-IA5-Norwegian --- IA^5 --- Norwegian --- (7-bit)\r\n///\r\n20127 --- us-ascii --- US-ASCII (7-bit)\r\n///\r\n20261 --- x-cp20261 --- T.61\r\n///\r\n20269 --- x-cp20269 --- ISO ^6937 --- Non-Spacing --- Accent\r\n///\r\n20273 --- IBM273 --- IBM EBCDIC Germany\r\n///\r\n20277 --- IBM277 --- IBM EBCDIC Denmark-Norway\r\n///\r\n20278 --- IBM278 --- IBM EBCDIC Finland-Sweden\r\n///\r\n20280 --- IBM280 --- IBM EBCDIC Italy\r\n///\r\n20284 --- IBM284 --- IBM EBCDIC Latin America-Spain\r\n///\r\n20285 --- IBM285 --- IBM EBCDIC United Kingdom\r\n///\r\n20290 --- IBM290 --- IBM EBCDIC Japanese Katakana Extended\r\n///\r\n20297 --- IBM297 --- IBM EBCDIC France\r\n///\r\n20420 --- IBM420 --- IBM EBCDIC Arabic\r\n///\r\n20423 --- IBM423 --- IBM EBCDIC Greek\r\n///\r\n20424 --- IBM424 --- IBM EBCDIC Hebrew\r\n///\r\n20833 --- x-EBCDIC-KoreanExtended --- IBM EBCDIC Korean Extended\r\n///\r\n20838 --- IBM-Thai --- IBM EBCDIC Thai\r\n///\r\n20866 --- koi8-r --- Russian (KOI8-R); Cyrillic (KOI8-R)\r\n///\r\n20871 --- IBM871 --- IBM EBCDIC Icelandic\r\n///\r\n20880 --- IBM880 --- IBM EBCDIC Cyrillic Russian\r\n///\r\n20905 --- IBM905 --- IBM EBCDIC Turkish\r\n///\r\n20924 --- IBM00924 --- IBM EBCDIC Latin 1/Open System (1047 + Euro symbol)\r\n///\r\n20932 --- EUC-JP --- Japanese (JIS 0208-^1990 --- and --- 0212-1990)\r\n///\r\n20936 --- x-cp20936 --- Simplified Chinese (GB2312); Chinese Simplified (GB2312-80)\r\n///\r\n20949 --- x-cp20949 --- Korean Wansung\r\n///\r\n21025 --- cp1025 --- IBM EBCDIC Cyrillic Serbian-Bulgarian\r\n///\r\n21027 ---  --- (deprecated)\r\n///\r\n21866 --- koi8-u --- Ukrainian (KOI8-U); Cyrillic (KOI8-U)\r\n///\r\n28591 --- iso-8859-1 --- ISO 8859-^1 --- Latin --- 1; Western European (ISO)\r\n///\r\n28592 --- iso-8859-2 --- ISO 8859-^2 --- Central --- European; Central European (ISO)\r\n///\r\n28593 --- iso-8859-3 --- ISO 8859-^3 --- Latin --- 3\r\n///\r\n28594 --- iso-8859-4 --- ISO 8859-^4 --- Baltic ----\r\n///\r\n28595 --- iso-8859-5 --- ISO 8859-^5 --- Cyrillic ----\r\n///\r\n28596 --- iso-8859-6 --- ISO 8859-^6 --- Arabic ----\r\n///\r\n28597 --- iso-8859-7 --- ISO 8859-^7 --- Greek ----\r\n///\r\n28598 --- iso-8859-8 --- ISO 8859-8 Hebrew; Hebrew (ISO-Visual)\r\n///\r\n28599 --- iso-8859-9 --- ISO 8859-^9 --- Turkish ----\r\n///\r\n28603 --- iso-8859-13 --- ISO 8859-^13 --- Estonian ----\r\n///\r\n28605 --- iso-8859-15 --- ISO 8859-^15 --- Latin --- 9\r\n///\r\n29001 --- x-Europa --- Europa 3\r\n///\r\n38598 --- iso-8859-8-i --- ISO 8859-8 Hebrew; Hebrew (ISO-Logical)\r\n///\r\n50220 --- iso-2022-jp --- ISO ^2022 --- Japanese --- with no halfwidth Katakana; Japanese (JIS)\r\n///\r\n50221 --- csISO2022JP --- ISO ^2022 --- Japanese --- with halfwidth Katakana; Japanese (JIS-Allow ^1 --- byte --- Kana)\r\n///\r\n50222 --- iso-2022-jp --- ISO ^2022 --- Japanese --- JIS X 0201-1989; Japanese (JIS-Allow ^1 --- byte --- Kana - SO/SI)\r\n///\r\n50225 --- iso-2022-kr --- ISO ^2022 --- Korean ----\r\n///\r\n50227 --- x-cp50227 --- ISO ^2022 --- Simplified --- Chinese; Chinese Simplified (ISO 2022)\r\n///\r\n50229 ---  --- ISO ^2022 --- Traditional --- Chinese\r\n///\r\n50930 ---  --- EBCDIC Japanese (Katakana) Extended\r\n///\r\n50931 ---  --- EBCDIC US-Canada and Japanese\r\n///\r\n50933 ---  --- EBCDIC Korean Extended and Korean\r\n///\r\n50935 ---  --- EBCDIC Simplified Chinese Extended and Simplified Chinese\r\n///\r\n50936 ---  --- EBCDIC Simplified Chinese\r\n///\r\n50937 ---  --- EBCDIC US-Canada and Traditional Chinese\r\n///\r\n50939 ---  --- EBCDIC Japanese (Latin) Extended and Japanese\r\n///\r\n51932 --- euc-jp --- EUC Japanese\r\n///\r\n51936 --- EUC-CN --- EUC Simplified Chinese; Chinese Simplified (EUC)\r\n///\r\n51949 --- euc-kr --- EUC Korean\r\n///\r\n51950 ---  --- EUC Traditional Chinese\r\n///\r\n52936 --- hz-gb-2312 --- HZ-GB^2312 --- Simplified --- Chinese; Chinese Simplified (HZ)\r\n///\r\n54936 --- GB18030 --- Windows XP and later: GB^18030 --- Simplified --- Chinese (4 byte); Chinese Simplified (GB18030)\r\n///\r\n57002 --- x-iscii-de --- ISCII Devanagari\r\n///\r\n57003 --- x-iscii-be --- ISCII Bangla\r\n///\r\n57004 --- x-iscii-ta --- ISCII Tamil\r\n///\r\n57005 --- x-iscii-te --- ISCII Telugu\r\n///\r\n57006 --- x-iscii-as --- ISCII Assamese\r\n///\r\n57007 --- x-iscii-or --- ISCII Odia\r\n///\r\n57008 --- x-iscii-ka --- ISCII Kannada\r\n///\r\n57009 --- x-iscii-ma --- ISCII Malayalam\r\n///\r\n57010 --- x-iscii-gu --- ISCII Gujarati\r\n///\r\n57011 --- x-iscii-pa --- ISCII Punjabi\r\n///\r\n65000 --- utf-7 --- Unicode (UTF-7)\r\n///\r\n65001 --- utf-8 --- Unicode (UTF-8)'),
('Composition String_Table1', 'Value --- Meaning\r\n///\r\nATTR_INPUT --- Character being entered by the user. The IME has yet to convert this character.\r\n///\r\nATTR_INPUT_ERROR --- An error character that the IME cannot convert. For example, the IME cannot put together some consonants. \r\n///\r\nATTR_TARGET_CONVERTED --- Character selected by the user and then converted by the IME. \r\n///\r\nATTR_CONVERTED --- Character that the IME has already converted. \r\n///\r\nATTR_TARGET_NOTCONVERTED --- Character being converted. The user has selected this character but the IME has not yet converted it. \r\n///\r\nATTR_FIXEDCONVERTED --- Characters that the IME will no longer convert.'),
('COMPOSITIONFORM_Table1', 'Value --- Meaning\r\n///\r\nCFS_DEFAULT --- Move the composition window to the default position. The IME window can display the composition window outside the client area, such as in a floating window. \r\n///\r\nCFS_FORCE_POSITION --- Display the upper-left corner of the composition window at exactly the position given by ptCurrentPos. The coordinates are relative to the upper-left corner of the window containing the composition window and are not subject to adjustment by the IME. \r\n///\r\nCFS_POINT --- Display the upper-left corner of the composition window at the position given by ptCurrentPos. The coordinates are relative to the upper-left corner of the window containing the composition window and are subject to adjustment by the IME. \r\n///\r\nCFS_RECT --- Display the composition window at the position given by rcArea. The coordinates are relative to the upper-left corner of the window containing the composition window.'),
('COMPOSITIONSTRING_Table1', 'Value --- Content\r\n///\r\nATTR_INPUT --- Character currently being entered.\r\n///\r\nATTR_TERGET_CONVERTED --- Character currently being converted (already converted).\r\n///\r\nATTR_CONVERTED --- Character given from the conversion.\r\n///\r\nATTR_TARGET_NOTCONVERTED --- Character currently being converted (yet to be converted).\r\n///\r\nATTR_FIXEDCONVERTED --- Characters will not be converted anymore.\r\n///\r\nATTR_INPUT_ERROR --- Character is an error character and cannot be converted by the IME.'),
('COMPOSITIONSTRING_Table2', 'Content --- Description \r\nCharacter currently being entered.  --- Character that the user is entering. If this is Japanese, this character is a hiragana, katakana, or alphanumeric character that has yet to be converted by the IME.\r\n///\r\nCharacter currently being converted (already converted). --- Character that has been selected for conversion by the user and converted by the IME. \r\n///\r\nCharacter given from conversion. --- Character which the IME has converted.\r\n///\r\nCharacter currently being converted (yet to be converted). --- Character that has been selected for conversion by the user and not yet converted by the IME. If this is Japanese, this character is a hiragana, katakana, or alphanumeric character that the user has entered. \r\nCharacter is an error character and cannot be converted by the IME. ---Character is an error character and the IME cannot convert this character. For example, some consonants cannot be combined.'),
('EM_GETIMESTATUS_Table1', 'Value --- Meaning\r\n///\r\nEMSIS_COMPOSITIONSTRING --- Sets behavior for handling the composition string.'),
('EM_GETIMESTATUS_Table2', 'Return code --- Description\r\n///\r\nEIMES_GETCOMPSTRATONCE --- If this flag is set, the edit control hooks the WM_IME_COMPOSITION message with fFlags set to GCS_RESULTSTR and returns the result string immediately. If this flag is not set, the edit control passes the WM_IME_COMPOSITION message to the default window procedure and processes the result string from the WM_CHAR message; this is the default behavior of the edit control.\r\n///\r\nEIMES_CANCELCOMPSTRINFOCUS --- If this flag is set, the edit control cancels the composition string when it receives the WM_SETFOCUS message. If this flag is not set, the edit control does not cancel the composition string; this is the default behavior of the edit control.\r\n///\r\nEIMES_COMPLETECOMPSTRKILLFOCUS --- If this flag is set, the edit control completes the composition string upon receiving the WM_KILLFOCUS message. If this flag is not set, the edit control does not complete the composition string; this is the default behavior of the edit control.'),
('EM_SETIMESTATUS_Table1', 'Value --- Meaning\r\n///\r\nEMSIS_COMPOSITIONSTRING --- Sets behavior for the handling composition string.'),
('EM_SETIMESTATUS_Table2', 'Value --- Meaning\r\n///\r\nEIMES_GETCOMPSTRATONCE --- If this flag is set, the edit control hooks the WM_IME_COMPOSITION message with lParam set to GCS_RESULTSTR and returns the result string immediately. If this flag is not set, the edit control passes the WM_IME_COMPOSITION message to the default window procedure and handles the result string from the WM_CHAR message; this is the default behavior of the edit control.\r\n///\r\nEIMES_CANCELCOMPSTRINFOCUS --- If this flag is set, the edit control cancels the composition string when it receives the WM_SETFOCUS message. If this flag is not set, the edit control does not cancel the composition string; this is the default behavior of the edit control.\r\n///\r\nEIMES_COMPLETECOMPSTRKILLFOCUS --- If this flag is set, the edit control completes the composition string upon receiving the WM_KILLFOCUS message. If this flag is not set, the edit control does not complete the composition string; this is the default behavior of the edit control.'),
('GUIDELINE_Table1', 'Value --- Description\r\n///\r\nGL_LEVEL_NOGUIDELINE --- No guideline present. If the old guideline is shown, the UI should hide the old guideline.\r\n///\r\nGL_LEVEL_FATAL --- Fatal error has occurred. Some data may be lost.\r\n///\r\nGL_LEVEL_ERROR --- Error has occurred. Handling may not be continued.\r\n///\r\nGL_LEVEL_WARNING --- IME warning to user. Something unexpected has occurred, but the IME can continue handling.\r\n///\r\nGL_LEVEL_INFORMATION --- Information for the user.'),
('GUIDELINE_Table2', 'Value --- Description\r\n///\r\nGL_ID_UNKNOWN --- Unknown error. The application should refer to the error string. \r\nGL_ID_NOMODULE --- IME cannot find the module that the IME needs. \r\nGL_ID_NODICTIONARY --- IME cannot find the dictionary or the dictionary looks strange. \r\nGL_ID_CANNOTSAVE --- Dictionary or the statistical data cannot be saved. \r\nGL_ID_NOCONVERT --- IME cannot convert anymore.\r\n///\r\nGL_ID_TYPINGERROR --- Typing error. The IME cannot handle this typing. \r\n///\r\nGL_ID_TOOMANYSTROKE --- Two many keystrokes for one character or one clause. \r\n///\r\nGL_ID_READINGCONFLICT --- Reading conflict has occurred. For example, some vowels cannot be combined.  \r\n///\r\nGL_ID_INPUTREADING --- IME prompts the user now it is in inputting reading character state. \r\n///\r\nGL_ID_INPUTRADICAL --- IME prompts the user now it is in inputting radical character state. \r\n///\r\nGL_ID_INPUTCODE --- IME prompts the user to input the character code state. \r\n///\r\nGL_ID_CHOOSECANIDATE --- IME prompts the user to select the candidate string state. \r\n///\r\nGL_ID_REVERSECONVERSION --- IME prompts the user to provide the information of the reverse conversion. The information of reverse conversion can be obtained through \r\nImmGetGuideLine(hIMC, GGL_PRIVATE, lpBuf, dwBufLen). The information contained in lpBuf is in CANDIDATELIST format. \r\n///\r\nGL_ID_PRIVATE_FIRST --- ID located between GL_ID_PRIVATE_FIRST and GL_ID_PRIVATE_LAST is reserved for the IME. The IME can freely use these IDs for its own GUIDELINE. \r\n///\r\nGL_ID_PRIVATE_LAST --- ID located between GL_ID_PRIVATE_FIRST and GL_ID_PRIVATE_LAST is reserved for the IME. The IME can freely use these IDs for its own GUIDELINE.'),
('IME Composition String Values_Table1', 'Value --- Description\r\n///\r\nGCS_COMPATTR --- Retrieve or update the attribute of the composition string. \r\n///\r\nGCS_COMPCLAUSE --- Retrieve or update clause information of the composition string. \r\n///\r\nGCS_COMPREADATTR --- Retrieve or update the attributes of the reading string of the current composition. \r\n///\r\nGCS_COMPREADCLAUSE --- Retrieve or update the clause information of the reading string of the composition string. \r\n///\r\nGCS_COMPREADSTR --- Retrieve or update the reading string of the current composition. \r\n///\r\nGCS_COMPSTR --- Retrieve or update the current composition string.\r\n///\r\nGCS_CURSORPOS --- Retrieve or update the cursor position in composition string. \r\n///\r\nGCS_DELTASTART --- Retrieve or update the starting position of any changes in composition string. \r\n///\r\nGCS_RESULTCLAUSE --- Retrieve or update clause information of the result string. \r\n///\r\nGCS_RESULTREADCLAUSE --- Retrieve or update clause information of the reading string. \r\n///\r\nGCS_RESULTREADSTR --- Retrieve or update the reading string. \r\n///\r\nGCS_RESULTSTR --- Retrieve or update the string of the composition result.'),
('IME Conversion Mode Values_Table1', 'Bit --- Meaning\r\n///\r\nIME_CMODE_ALPHANUMERIC --- Alphanumeric input mode. This is the default, defined as 0x0000. \r\n///\r\nIME_CMODE_CHARCODE --- Set to 1 if character code input mode; 0 if not.\r\n///\r\nIME_CMODE_EUDC --- Set to 1 if EUDC conversion mode; 0 if not.\r\n///\r\nIME_CMODE_FIXED --- Windows Me/98, Windows 2000, Windows XP: Set to 1 if fixed conversion mode; 0 if not. \r\n///\r\nIME_CMODE_FULLSHAPE --- Set to 1 if full shape mode; 0 if half shape mode. \r\n///\r\nIME_CMODE_HANJACONVERT --- Set to 1 if HANJA convert mode; 0 if not. \r\n///\r\nIME_CMODE_KATAKANA --- Set to 1 if KATAKANA mode; 0 if HIRAGANA mode. \r\n///\r\nIME_CMODE_NATIVE --- Set to 1 if NATIVE mode; 0 if ALPHANUMERIC mode. \r\n///\r\nIME_CMODE_NOCONVERSION --- Set to 1 to prevent processing of conversions by IME; 0 if not. \r\n///\r\nIME_CMODE_ROMAN --- Set to 1 if ROMAN input mode; 0 if not. \r\n///\r\nIME_CMODE_SOFTKBD --- Set to 1 if Soft Keyboard mode; 0 if not. \r\n///\r\nIME_CMODE_SYMBOL --- Set to 1 if SYMBOL conversion mode; 0 if not.'),
('IME Escapes_Table1', 'Escape --- Description\r\n///\r\nIME_ESC_GET_EUDC_DICTIONARY --- Retrieve the path of the EUDC dictionary file. On input, the lpData parameter must be the pointer to the buffer to receive the path. This buffer must be equal to or greater than 80 * sizeof(TCHAR). On return, the buffer contains the null-terminated string specifying the full path of the dictionary. For use by the Chinese EUDC editor only; do not use in other applications. \r\n///\r\nIME_ESC_HANJA_MODE --- Convert from Hangul to Hanja. On input, lpData must point to the buffer that contains the Hangul character to convert; on output, it receives the converted Hanja as a null-terminated string. For use by the Korean editor; do not use in other applications. \r\n///\r\nIME_ESC_IME_NAME --- Retrieve the name of the IME. On input, the lpData parameter must be the pointer to the buffer to receive the name. On return, the buffer contains the null-terminated string specifying the IME name. For use by the Chinese EUDC editor only; do not use in other applications.\r\n\r\nWindows Me/98/95: The buffer must be no less than 16*sizeof(TCHAR).\r\n\r\nWindows NT, Windows 2000, Windows XP: The buffer must be no less than 64 characters.\r\n/// \r\nIME_ESC_MAX_KEY --- Return value of the function is the maximum number of key stokes for an EUDC character. For use by the Chinese EUDC editor only; do not use in other applications. \r\n///\r\nIME_ESC_QUERY_SUPPORT --- Check for implementation. On input, lpData points to the buffer that contains the IME Escape value. The function returns 0 if the escape is not implemented. \r\n///\r\nIME_ESC_SEQUENCE_TO_INTERNAL --- Return the character code that matches the specified sequence code. On input, the lpData parameter is the pointer to a 32-bit variable that contains the sequence code. For use by the Chinese EUDC editor only; do not use in other applications. Normally, the Chinese IME will encode its reading character codes into sequence 1 to n. \r\n///\r\nIME_ESC_SET_EUDC_DICTIONARY --- Set the EUDC dictionary file. On input, the lpData parameter is the pointer '),
('IME File Format_Table1', 'Information --- Description\r\n///\r\ndwFileOS --- The dwFileOS should be specified in the root block of the version information. The dwFileOS should be VOS__WINDOWS32 for Windows 95 and Windows NT IMEs.\r\n///\r\ndwFileType --- The dwFileType should be specified in the root block of the version information. The value is VFT_DRV.\r\n///\r\ndwFileSubtype --- The dwFileSubtype should be specified in the root block of the version information. The value is VFT2_DRV_INPUTMETHOD. \r\nFileDescription --- The FileDescription is specified in the language-specific block of the version information. This should include the IME name and the version. This string is for display purposes only. Currently, the string length is 32 TCHARS, but may be extended in a future version.\r\n///\r\nProductName --- The ProductName is specified in the language-specific block of the version information. Charset ID and Language ID The code page (character set ID) and language ID are specified in the variable information block of the version information resource. If there are many code pages (character set ID) and language IDs are specified in the block, the IME uses the first code page ID to display the text and uses the first language ID for the IME language.\r\n///\r\nThe charset ID and language ID --- Must match the IME language instead of the resource language.\r\n///\r\nThe file name --- Must be 8.3.'),
('IME Hot Key Identifiers_Table1', 'Identifiers --- Meaning\r\n///\r\nIME_CHOTKEY_IME_NONIME_TOGGLE --- (Simplified Chinese) Toggle between IME and non-IME operation when the language is Simplified Chinese. \r\n///\r\nIME_CHOTKEY_SHAPE_TOGGLE --- (Simplified Chinese) Toggle the shape conversion mode of IME. \r\n///\r\nIME_CHOTKEY_SYMBOL_TOGGLE --- (Simplified Chinese) Toggle the symbol conversion mode of IME. Symbol mode indicates that the user can input Chinese punctuation and symbols by mapping to the punctuation and symbols on the keyboard. \r\n///\r\nIME_ITHOTKEY_RECONVERTSTRING --- Windows Me/98, Windows 2000, Windows XP: (Traditional Chinese) Trigger reconversion. \r\n///\r\nIME_JHOTKEY_CLOSE_OPEN --- (Japanese) Alternately open and close the IME. \r\n///\r\nIME_KHOTKEY_ENGLISH --- (Korean) Switch to English. \r\n///\r\nIME_KHOTKEY_SHAPE_TOGGLE --- (Korean) Toggle the shape conversion mode of IME. \r\n///\r\nIME_KHOTKEY_HANJACONVERT --- (Korean) Switch to Hanja conversion. \r\n///\r\nIME_THOTKEY_IME_NONIME_TOGGLE --- (Traditional Chinese) Toggle between IME and non-IME operation when the language is Traditional Chinese. \r\n///\r\nIME_THOTKEY_SHAPE_TOGGLE --- (Traditional Chinese) Toggle the shape conversion mode of IME. \r\n///\r\nIME_THOTKEY_SYMBOL_TOGGLE --- (Traditional Chinese) Toggle the symbol conversion mode of IME.'),
('IME Sentence Mode Values_Table1', 'Constant --- Definition\r\n///\r\nIME_SMODE_AUTOMATIC --- The IME carries out conversion processing in automatic mode. \r\n///\r\nIME_SMODE_NONE --- No information for sentence. \r\n///\r\nIME_SMODE_PHRASEPREDICT --- The IME uses phrase information to predict the next character. \r\n///\r\nIME_SMODE_PLURALCLAUSE --- The IME uses plural clause information to carry out conversion processing. \r\n///\r\nIME_SMODE_SINGLECONVERT --- The IME carries out conversion processing in single-character mode. \r\n///\r\nIME_SMODE_CONVERSATION --- The IME uses conversation mode. This is useful for chat applications.'),
('ImeConfigure_Table1', 'Flag --- Description \r\n///\r\nIME_CONFIG_GENERAL --- Dialog for general purpose \r\nconfiguration.  \r\n///\r\nIME_CONFIG_REGWORD --- Dialog for register word.\r\n///  \r\nIME_CONFIG_SELECTDICTIONARY --- Dialog for selecting the IME dictionary.'),
('ImeConversionList_Table1', 'Flag --- Description\r\n///\r\nGCL_CONVERSION --- Specifies the reading string to the \r\nlpSrc parameter. The IME returns the result string in the lpDst parameter.\r\n/// \r\nGCL_REVERSECONVERSION --- Specifies the result string in the lpSrc parameter. The IME returns the reading string in the lpDst parameter.\r\n///\r\nGCL_REVERSE_LENGTH --- Specifies the result string in the lpSrc parameter. The IME returns the length that it can handle in GCL_REVERSECONVERSION.\r\n \r\nFor example, an IME cannot convert a result string with a sentence period to a reading string. As a result, it returns the string length in bytes without the sentence period.'),
('ImeEscape_Table1', 'uEscape --- Meaning\r\n///\r\nIME_ESC_QUERY _SUPPORT --- Checks for implementation. If this escape is not implemented, the return value is zero. \r\n///\r\nIME_ESC_RESERVED_FIRST --- Escape that is between IME_ESC_RESERVED_FIRST and IME_ESC_RESERVED_LAST is reserved by the system. \r\n///\r\nIME_ESC_RESERVED_LAST --- Escape that is between IME_ESC_RESERVED_FIRST and IME_ESC_RESERVED_LAST is reserved by the system. \r\nIME_ESC_PRIVATE_FIRST --- Escape that is between IME_ESC_PRIVATE_FIRST and IME_ESC_PRIVATE_LAST is reserved for the IME. The IME can freely use these escape functions for its own purposes. \r\n///\r\nIME_ESC_PRIVATE_LAST --- Escape that is between IME_ESC_PRIVATE_FIRST and IME_ESC_PRIVATE_LAST is reserved for the IME. The IME can freely use these escape functions for its own purposes.  \r\n///\r\nIME_ESC_SEQUENCE_TO_INTERNAL --- Escape that is Chinese specific. An \r\napplication that wants to run under all Far East platforms should not use this. It is for the Chinese EUDC editor. The *(LPWORD)lpData is the sequence code, and the return value is the character code for this sequence code. Typically, the Chinese IME will encode its reading character codes into sequence 1 to n. \r\n///\r\nIME_ESC_GET_EUDC_DICTIONARY --- Escape that is Chinese specific. An application that wants to run under all Far East platforms should not use this. It is for the Chinese EUDC editor. On return from the function, the \r\n(LPTSTR)lpData is filled with the full path file name of the EUDC dictionary. The size of this buffer pointed by lpData should be greater or egual to MAX_PATH * sizeof(TCHAR).\r\n\r\nNote: Windows 95/98 and Windows NT 4.0 EUDC editor expect IMEs just use the buffer up to 80*sizeof(TCHAR).\r\n///\r\nIME_ESC_SET_EUDC_DICTIONARY --- Sets the EUDC dictionary file. On input, the lpData parameter is the pointer to a null-terminated string specifying the full path. For use by the Chinese EUDC editor; do not use in other applications.\r\n///\r\nIME_ESC_MAX_KEY --- Escape that is Chinese specific. An application that wants to run under all Far East platforms should not use this. It is for the Chinese EUDC editor. The return value is the maximum keystrokes for a EUDC character.\r\n///\r\nIME_ESC_IME_NAME --- Escape that is Chinese specific. An application that wants to run under all Far East platforms should not use this. It is for the Chinese EUDC editor. On return from the function, the (LPTSTR) is the IME name to be displayed on the EUDC editor. The size of this buffer pointed to by lpData should be greater or equal to 16 * sizeof(TCHAR).\r\n///\r\nIME_ESC_SYNC_HOTKEY --- Escape that is (Traditional) Chinese specific. An application that wants to run under all Far East platforms should not use this. It is for synchronizing between different IMEs. The input parameter *(LPDWORD)lpData is the IME private hot key ID. If this ID is zero, this IME should check every private hot key ID it concerns.\r\n///\r\nIME_ESC_HANJA_MODE --- Escape that is Korean specific. An application that wants to run under all Far East platforms should not use this. It is for conversion from Hangeul to Hanja. The input parameter (LPTSTR)lpData is filled with Hangeul characters that will be converted to Hanja and its null-terminated string. When an application wants to convert any Hangeul character to a Hanja character by using the same method as the Hanja conversion when the composition character is present, the application only needs to request this function. The IME will then set itself as the Hanja conversion mode. \r\n///\r\nIME_ESC_GETHELPFILENAME --- Escape that is the name of the IME’s help file. On return from the function, the (LPTSTR)lpData is the full path file name of the IME’s help file. The path name should be less than MAX_PATH * sizeof(TCHAR). This is added to Windows 98 and Windows 2000. Note: Windows 98 expects the path length is less than 80 TCHARs.  IME_ESC_PRIVATE_HOTKEY lpdata points to a DWORD that contains the hot key ID (in the range of IME_HOTKEY_PRIVATE_FIRST and IME_HOTKEY_PRIVATE_LAST). After the system receives the hot key request within this range, the IMM will dispatch it'),
('ImeGetImeMenuItems_Table1', 'Bit --- Description \r\n///\r\nIGIMIF_RIGHTMENU --- If this bit is 1, this function returns the menu items for the right click Context menu.'),
('ImeGetImeMenuItems_Table2', 'Bit --- Description\r\n///\r\nIGIMII_CMODE --- Returns the menu items related to the \r\nconversion mode.\r\n///\r\nIGIMII_SMODE --- Returns the menu items related to the \r\nsentence mode.\r\n///\r\nIGIMII_CONFIGURE --- Returns the menu items related to the configuration of IME. \r\n///\r\nIGIMII_TOOLS --- Returns the menu items related to the IME tools.\r\n///\r\nIGIMII_HELP --- Returns the menu items related to IME help.\r\n///\r\nIGIMII_OTHER --- Returns the menu items related to others.\r\n///\r\nIGIMII_INPUTTOOLS --- Returns the menu items related to the IME input tools that provide the extended way to input the characters.'),
('ImeInquire_Table1', 'Flag --- Description \r\n///\r\nIME_SYSINFO_WINLOGON --- Tells the IME that the client process is the Winlogon process. The IME should not allow users to configure the IME when this flag is specified.\r\n///\r\nIME_SYSINFO_WOW16 --- Tells the IME that the client process is a 16-bit application.'),
('IMEMENUITEMINFOA_Table1', 'Value --- Meaning\r\n///\r\nIMFT_RADIOCHECK --- Displays checked menu items using a radio button mark instead of a check mark if the hbmpChecked member is NULL. \r\n///\r\nIMFT_SEPARATOR --- Specifies that the menu item is a separator. A menu item separator appears as a horizontal dividing line. The hbmpItem and szString members are ignored in this case. \r\n///\r\nIMFT_SUBMENU --- Specifies that the menu item is a submenu.'),
('IMEMENUITEMINFOA_Table2', 'Value --- Meaning\r\n///\r\nIMFS_CHECKED --- The menu item is checked. \r\n///\r\nIMFS_DEFAULT --- The menu item is the default. A menu can contain only one default menu item, which is displayed in bold. \r\n///\r\nIMFS_DISABLED --- The menu item is disabled, but not shaded. It can still be selected. \r\n///\r\nIMFS_ENABLED --- The menu item is enabled. This is the default state. \r\n///\r\nIMFS_GRAYED --- The menu item is disabled and shaded so it cannot be selected. \r\n///\r\nIMFS_HILITE --- The menu item is highlighted. \r\n///\r\nIMFS_UNCHECKED --- The menu item is unchecked. \r\n///\r\nIMFS_UNHILITE --- The menu item is not highlighted.'),
('IMEMENUITEMINFOW_Table1', 'Value --- Meaning\r\n///\r\nIMFT_RADIOCHECK --- Displays checked menu items using a radio button mark instead of a check mark if the hbmpChecked member is NULL. \r\n///\r\nIMFT_SEPARATOR --- Specifies that the menu item is a separator. A menu item separator appears as a horizontal dividing line. The hbmpItem and szString members are ignored in this case. \r\n///\r\nIMFT_SUBMENU --- Specifies that the menu item is a submenu.'),
('IMEMENUITEMINFOW_Table2', 'Value --- Meaning\r\n///\r\nIMFS_CHECKED --- The menu item is checked. \r\n///\r\nIMFS_DEFAULT --- The menu item is the default. A menu can contain only one default menu item, which is displayed in bold.\r\n///\r\nIMFS_DISABLED --- The menu item is disabled, but not shaded. It can still be selected. \r\n///\r\nIMFS_ENABLED --- The menu items is enabled. This is the default state. \r\n///\r\nIMFS_GRAYED --- The menu item is disabled and shaded so it cannot be selected. \r\n///\r\nIMFS_HILITE --- The menu item is highlighted. \r\n///\r\nIMFS_UNCHECKED --- The menu item is unchecked. \r\n///\r\nIMFS_UNHILITE --- The menu item is not highlighted.'),
('ImeRegisterWord_Table1', 'Value --- Description \r\n///\r\nIME_REGWORD_STYLE_EUDC --- String is within the EUDC range\r\n///\r\nIME_REGWORD_STYLE_USER_FIRST to IME_REGWORD_STYLE_USER_LAST --- Constants range from \r\nIME_REGWORD_STYLE_USER_FIRST to IME_REGWORD_STYLE_USER_LAST and are used for private styles of the IME ISV. The IME ISV can freely define its own style. For example: \r\n\r\n<pre>\r\n#define MSIME_NOUN (IME_REGWORD_STYLE_USER_FIRST) \r\n#define MSIME_VERB (IME_REGWORD_STYLE_USER_FISRT + 1)</pre>'),
('ImeSetCompositionString_Table1', 'Value --- Description \r\n///\r\nSCS_SETSTR --- Application sets the composition string, the reading string, or both. At least one of the lpComp and lpRead parameters must point to a valid string. If either string is too long, the IME truncates it.\r\n///\r\nSCS_CHANGEATTR --- Application sets attributes for the composition string, the reading string, or both. At least one of the lpComp and lpRead parameters must point to a valid attribute array.\r\n///\r\nSCS_CHANGECLAUSE --- Application sets the clause information for the composition string, the reading string, or both. At least one of the lpComp and \r\nlpRead parameters must point to a valid clause information array.\r\n///\r\nSCS_QUERYRECONVERTSTRING --- Application asks the IME to adjust its RECONERTSTRINGSTRUCTRE. If the application calls the ImeSetCompositionString function with this value, the IME adjusts the RECONVERTSTRING structure. The application can then pass the adjusted RECONVERTSTRING structure to this function with SCS_RECONVERTSTRING. The IME will not generate any WM_IMECOMPOSITION messages.\r\n/// \r\nSCS_SETRECONVERTSTRING --- Application asks the IME to reconvert the string contained in the RECONVERTSTRING structure.'),
('ImeToAsciiEx_Table1', 'Bits --- Contents\r\n///\r\n0-7 bit --- VK_PACKET\r\n///\r\n8-15 bit --- Leading byte\r\n///\r\n16-23 bit --- Trailing DBCS byte (if any)\r\n///\r\n24-31 bit  --- Reserved'),
('ImmAssociateContextEx_Table1', 'Value --- Meaning\r\n///\r\nIACE_CHILDREN --- Associate the input method context to the child windows of the specified window only.\r\n///\r\nIACE_DEFAULT --- Restore the default input method context of the window.\r\n///\r\nIACE_IGNORENOCONTEXT --- Do not associate the input method context with windows that are not associated with any input method context.'),
('ImmConfigureIME_Table1', 'Value --- Meaning\r\n///\r\nIME_CONFIG_GENERAL --- Display general-purpose configuration dialog box.\r\n///\r\nIME_CONFIG_REGISTERWORD --- Display register word dialog box.\r\n///\r\nIME_CONFIG_SELECTDICTIONARY --- Display dictionary selection dialog box.'),
('ImmCreateSoftKeyboard_Table1', 'Type --- Description\r\n///\r\nSOFTKEYBOARD_TYPE_T1 --- Type T1 soft keyboard. This kind of soft keyboard should be updated by IMC_SETSOFTKBDDATA. \r\n///\r\nSOFTKEYBOARD_TYPE_C1 --- Type C1 soft keyboard. This kind of soft keyboard should be updated by IMC_SETSOFTKBDDATA with two sets of 256-word array data. The first set is for nonshift state, and the second is for shift state.'),
('ImmEnumInputContext_Table1', 'Value --- Meaning\r\n///\r\n0 --- Current thread.\r\n///\r\n1 --- Current process.\r\n///\r\nThread ID --- Identifier of the thread for which to enumerate the context. This thread identifier can belong to another process.'),
('ImmGetCompositionString_Table1', 'Error Codes --- Description\r\n///\r\nIMM_ERROR_NODATA --- Composition data is not ready in the input context.\r\n///\r\nIMM_ERROR_GENERAL --- General error detected by IME.'),
('ImmGetConversionList_Table1', 'Value --- Meaning\r\n///\r\nGCL_CONVERSION --- Source string is the reading string. The function copies the result string to the destination buffer.\r\n///\r\nGCL_REVERSECONVERSION --- Source string is the result string. The function copies the reading string to the destination buffer.\r\n///\r\nGCL_REVERSE_LENGTH --- Source string is the result string. The function returns the size, in bytes, of the reading string created if GCL_REVERSECONVERSION is specified.'),
('ImmGetGuideLine_Table1', 'Value --- Meaning\r\n///\r\nGGL_LEVEL --- Return the error level.\r\n///\r\nGGL_INDEX --- Return the error index.\r\n///\r\nGGL_STRING --- Return the error message string.\r\n///\r\nGGL_PRIVATE --- Return information about reverse conversion.'),
('ImmGetGuideLine_Table2', 'Value --- Meaning\r\n///\r\nGL_LEVEL_ERROR --- Error. The IME might not be able to continue. \r\n///\r\nGL_LEVEL_FATAL --- Fatal error. The IME cannot continue, and data might be lost.\r\n/// \r\nGL_LEVEL_INFORMATION --- No error. Information is available for the user. \r\n///\r\nGL_LEVEL_NOGUIDELINE --- No error. Remove previous error message if still visible.\r\n///\r\nGL_LEVEL_WARNING --- Unexpected input or other result. The user should be warned, but the IME can continue.'),
('ImmGetGuideLine_Table3', 'Value --- Meaning\r\n///\r\nGL_ID_CANNOTSAVE --- The dictionary or the statistics data cannot be saved.\r\n/// \r\nGL_ID_NOCONVERT --- The IME cannot convert any more. \r\n///\r\nGL_ID_NODICTIONARY --- The IME cannot find the dictionary, or the dictionary has an unexpected format. \r\n///\r\nGL_ID_NOMODULE --- The IME cannot find the module that is needed. \r\n///\r\nGL_ID_READINGCONFLICT --- A reading conflict occurred. For example, some vowels cannot be put together to form one character. \r\n///\r\nGL_ID_TOOMANYSTROKE --- There are too many strokes for one character or one clause. \r\n///\r\nGL_ID_TYPINGERROR --- Typing error. The IME cannot handle this typing.\r\n///\r\nGL_ID_UNKNOWN --- Unknown error. Refer to the error message string. \r\n///\r\nGL_ID_INPUTREADING --- The IME is accepting reading character input from the end user. \r\n///\r\nGL_ID_INPUTRADICAL --- The IME is accepting radical character input from the end user.\r\n/// \r\nGL_ID_INPUTCODE --- The IME is accepting character code input from the end user. \r\n///\r\nGL_ID_CHOOSECANDIDATE --- The IME is accepting candidate string selection from the end user. \r\n///\r\nGL_ID_REVERSECONVERSION --- Information about reverse conversion is available by calling ImmGetGuideLine, specifying GGL_PRIVATE. The information retrieved is in CANDIDATELIST format.'),
('ImmGetImeMenuItems_Table1', 'Value --- Meaning\r\n///\r\nIGIMIF_RIGHTMENU --- Retrieve the menu items for the context menu, obtained by a right mouse click.'),
('ImmGetImeMenuItems_Table2', 'Value --- Meaning\r\n///\r\nIGIMII_CMODE --- Retrieve the menu items that control conversion mode.\r\n///\r\nIGIMII_SMODE --- Retrieve the menu items that control sentence mode.\r\n///\r\nIGIMII_CONFIGURE --- Retrieve the menu items that are related to IME configuration.\r\n///\r\nIGIMII_TOOLS --- Retrieve the menu items that are related to IME tools.\r\n///\r\nIGIMII_HELP --- Retrieve the menu items that control IME Help.\r\n///\r\nIGIMII_OTHER --- Retrieve the menu items that control other IME functions.\r\n///\r\nIGIMII_INPUTTOOLS --- Retrieve the menu items that control menu items related to IME input tools providing an extended way to input characters.'),
('ImmGetProperty_Table1', 'Value --- Meaning\r\n///\r\nIGP_CONVERSION --- Conversion capabilities.\r\n///\r\nIGP_GETIMEVERSION --- System version number for which the specified IME was created.\r\n///\r\nIGP_PROPERTY --- Property information.\r\n///\r\nIGP_SELECT --- Selection inheritance capabilities.\r\n///\r\nIGP_SENTENCE --- Sentence mode capabilities.\r\n///\r\nIGP_SETCOMPSTR --- Composition string capabilities.\r\n///\r\nIGP_UI --- User interface capabilities.'),
('ImmGetProperty_Table2', 'Value --- Meaning\r\n///\r\nIME_PROP_AT_CARET --- If set, conversion window is at the caret position. If clear, the window is near the caret position.\r\n///\r\nIME_PROP_SPECIAL_UI --- If set, the IME has a nonstandard user interface. The application should not draw in the IME window. \r\n///\r\nIME_PROP_CANDLIST_START_FROM_1 --- If set, strings in the candidate list are numbered starting at 1. If clear, strings start at 0. \r\n///\r\nIME_PROP_UNICODE --- If set, the IME is viewed as a Unicode IME. The operating system and the IME communicate through the Unicode IME interface. If clear, the IME uses the ANSI interface to communicate with the operating system. \r\n///\r\nIME_PROP_COMPLETE_ON_UNSELECT --- If set, the IME completes the composition string when the IME is deactivated. If clear, the IME cancels the composition string when the IME is deactivated, for example, from a keyboard layout change. \r\n///\r\nIME_PROP_ACCEPT_WIDE_VKEY --- If set, the IME processes the injected Unicode that came from the SendInput function by using VK_PACKET. If clear, the IME might not process the injected Unicode, and might send the injected Unicode to the application directly.'),
('ImmGetProperty_Table3', 'Value --- Meaning\r\n///\r\nUI_CAP_2700 --- Support text escapement values of 0 or 2700. For more information, see the lfEscapement member of the LOGFONT structure.\r\n///\r\nUI_CAP_ROT90 --- Support text escapement values of 0, 900, 1800, or 2700. For more information, see lfEscapement.\r\n///\r\nUI_CAP_ROTANY --- Support any text escapement value. For more information, see lfEscapement.'),
('ImmGetProperty_Table4', 'Value --- Meaning\r\n///\r\nSCS_CAP_COMPSTR --- Create the composition string by calling the ImmSetCompositionString function with the SCS_SETSTR value. \r\n///\r\nSCS_CAP_MAKEREAD --- Create the reading string from corresponding composition string when using the ImmSetCompositionString function with SCS_SETSTR and without setting lpRead.\r\n/// \r\nSCS_CAP_SETRECONVERTSTRING --- This IME can support reconversion. Use ImmSetCompositionString to do reconversion.'),
('ImmGetProperty_Table5', 'Value --- Meaning\r\n///\r\nSELECT_CAP_CONVMODE --- Inherit conversion mode when a new IME is selected.\r\n///\r\nSELECT_CAP_SENTENCE --- Inherit sentence mode when a new IME is selected.'),
('ImmGetProperty_Table6', 'Value --- Meaning\r\n///\r\nIMEVER_0310 --- The IME was created for Windows 3.1. \r\n///\r\nIMEVER_0400 --- The IME was created for Windows Me/98/95.');
INSERT INTO `tables` (`table_name`, `contents`) VALUES
('ImmNotifyIME_Table1', 'Value --- Meaning\r\n///\r\nNI_CHANGECANDIDATELIST --- An application changed the current selected candidate. The dwIndex parameter specifies an index of a candidate list to be selected and dwValue is not used.\r\n///\r\nNI_CLOSECANDIDATE --- An application directs the IME to close a candidate list. The dwIndex parameter specifies an index of the list to close, and dwValue is not used. The IME sends a IMN_CLOSECANDIDATE command to the application if it closes the list.\r\n///\r\nNI_COMPOSITIONSTR --- An application directs the IME to carry out an action on the composition string. The dwIndex parameter can be CPS_CANCEL, CPS_COMPLETE, CPS_CONVERT, or CPS_REVERT.\r\n///\r\nNI_IMEMENUSELECTED --- An application directs the IME to allow the application to handle the specified menu. The dwIndex parameter specifies the ID of the menu and dwValue is an application-defined value for that menu item.\r\n///\r\nNI_OPENCANDIDATE --- An application directs the IME to open a candidate list. The dwIndex parameter specifies the index of the list to open, and dwValue is not used. The IME sends a IMN_OPENCANDIDATE command to the application if it opens the list.\r\n///\r\nNI_SELECTCANDIDATESTR --- An application has selected one of the candidates. The dwIndex parameter specifies an index of a candidate list to be selected. The dwValue parameter specifies an index of a candidate string in the selected candidate list.\r\nNI_SETCANDIDATE_PAGESIZE --- The application changes the page size of a candidate list. The dwIndex parameter specifies the candidate list to be changed and must have a value in the range 0 to 3. The dwValue parameter specifies the new page size.\r\n///\r\nNI_SETCANDIDATE_PAGESTART --- The application changes the page starting index of a candidate list. The dwIndex parameter specifies the candidate list to be changed and must have a value in the range 0 to 3. The dwValue parameter specifies the new page start index.'),
('ImmNotifyIME_Table2', 'Value --- Meaning\r\n///\r\nCPS_CANCEL --- Clear the composition string and set the status to no composition string.\r\n///\r\nCPS_COMPLETE --- Set the composition string as the result string.\r\n///\r\nCPS_CONVERT --- Convert the composition string.\r\n///\r\nCPS_REVERT --- Cancel the current composition string and set the composition string to be the unconverted string.'),
('ImmRegisterWord_Table1', 'Value --- Meaning\r\n///\r\nIME_REGWORD_STYLE_EUDC --- The string is in the end-user-defined (EUDC) range.\r\n///\r\nAny value in the range from IME_REGWORD_STYLE_USER_FIRST to IME_REGWORD_STYLE_USER_LAST --- The string has a private style maintained by the specified IME. See the Remarks section for more details.'),
('ImmSetCompositionString_Table1', 'Value --- Meaning\r\n///\r\nSCS_SETSTR --- Set the composition string, the reading string, or both. At least one of the lpComp and lpRead parameters must indicate a valid string. If either string is too long, the IME truncates it.\r\n///\r\nSCS_CHANGEATTR --- Set attributes for the composition string, the reading string, or both. At least one of the lpComp and lpRead parameters must indicate a valid attribute array.\r\n///\r\nSCS_CHANGECLAUSE --- Set the clause information for the composition string, the reading string, or both. At least one of the lpComp and lpRead parameters must point to a valid clause information array.\r\n///\r\nSCS_SETRECONVERTSTRING --- Windows Me/98, Windows 2000, Windows XP: Ask IME to reconvert the string using a specified RECONVERTSTRING structure.\r\n///\r\nSCS_QUERYRECONVERTSTRING --- Windows Me/98, Windows 2000, Windows XP: Ask IME to adjust the RECONVERTSTRING structure. Then the application can pass the adjusted structure into this function using SCS_SETRECONVERTSTRING. IME does not generate any WM_IME_COMPOSITION messages.'),
('ImmShowSoftKeyboard_Table1', 'Value --- Meaning \r\n///\r\nSW_HIDE --- Hides the soft keyboard. \r\n///\r\nSW_SHOWNOACTIVATE --- Displays the soft keyboard.'),
('ImmUnregisterWord_Table1', 'Value --- Meaning\r\n///\r\nIME_REGWORD_STYLE_EUDC --- The string is in the end-user-defined character (EUDC) range.\r\n///\r\nAny value from IME_REGWORD_STYLE_USER_FIRST to IME_REGWORD_STYLE_USER_LAST --- The string is in a private style maintained by the specified IME.'),
('INDICM_REMOVEDEFAULTMENUITEMS_Table1', 'Value --- Description \r\n///\r\nRDMI_LEFT --- Removes the menu items of the left click menu. \r\n///\r\nRDMI_RIGHT --- Removes the menu items of the right click menu.'),
('INPUTCONTEXT_Table1', 'Member Name --- Description\r\n///\r\nA --- LOGFONTA for ANSI.\r\n///\r\nW --- LOGFONTW for Unicode.'),
('Keystroke Message Flags_Table1', 'Value --- Description\r\n///\r\nKF_ALTDOWN --- Manipulates the ALT key flag, which indicates whether the ALT key is pressed. \r\n///\r\nKF_DLGMODE --- Manipulates the dialog mode flag, which indicates whether a dialog box is active. \r\n///\r\nKF_EXTENDED --- Manipulates the extended key flag. \r\n///\r\nKF_MENUMODE --- Manipulates the menu mode flag, which indicates whether a menu is active. \r\n///\r\nKF_REPEAT --- Manipulates the repeat count. \r\n///\r\nKF_UP --- Manipulates the transition state flag.'),
('LoadKeyboardLayout_Table1', 'Value --- Meaning\r\n///\r\nKLF_ACTIVATE 0x00000001 --- Prior to Windows 8: If the specified input locale identifier is not already loaded, the function loads and activates the input locale identifier for the current thread.\r\n\r\nBeginning in Windows 8: If the specified input locale identifier is not already loaded, the function loads and activates the input locale identifier for the system.\r\n///\r\nKLF_NOTELLSHELL 0x00000080 --- Prior to Windows 8: Prevents a ShellProc hook procedure from receiving an HSHELL_LANGUAGE hook code when the new input locale identifier is loaded. This value is typically used when an application loads multiple input locale identifiers one after another. Applying this value to all but the last input locale identifier delays the shell\'s processing until all input locale identifiers have been added.\r\n\r\nBeginning in Windows 8: In this scenario, the last input locale identifier is set for the entire system.\r\n///\r\nKLF_REORDER 0x00000008 --- Prior to Windows 8: Moves the specified input locale identifier to the head of the input locale identifier list, making that locale identifier the active locale identifier for the current thread. This value reorders the input locale identifier list even if KLF_ACTIVATE is not provided.\r\n\r\nBeginning in Windows 8: Moves the specified input locale identifier to the head of the input locale identifier list, making that locale identifier the active locale identifier for the system. This value reorders the input locale identifier list even if KLF_ACTIVATE is not provided.\r\n///\r\nKLF_REPLACELANG 0x00000010 --- If the new input locale identifier has the same language identifier as a current input locale identifier, the new input locale identifier replaces the current one as the input locale identifier for that language. If this value is not provided and the input locale identifiers have the same language identifiers, the current input locale identifier is not replaced and the function returns NULL.\r\n///\r\nKLF_SUBSTITUTE_OK 0x00000002 --- Substitutes the specified input locale identifier with another locale preferred by the user. The system starts with this flag set, and it is recommended that your application always use this flag. The substitution occurs only if the registry key HKEY_CURRENT_USER\\Keyboard\\Layout\\Substitutes explicitly defines a substitution locale. For example, if the key includes the value name \"00000409\" with value \"00010409\", loading the U.S. English layout (\"00000409\") causes the Dvorak U.S. English layout (\"00010409\") to be loaded instead. The system uses KLF_SUBSTITUTE_OK when booting, and it is recommended that all applications use this value when loading input locale identifiers to ensure that the user\'s preference is selected.\r\n///\r\nKLF_SETFORPROCESS 0x00000100 --- Prior to Windows 8: This flag is valid only with KLF_ACTIVATE. Activates the specified input locale identifier for the entire process and sends the WM_INPUTLANGCHANGE message to the current thread\'s Focus or Active window. Typically, LoadKeyboardLayout activates an input locale identifier only for the current thread.\r\n\r\nBeginning in Windows 8: This flag is not used. LoadKeyboardLayout always activates an input locale identifier for the entire system if the current process owns the window with keyboard focus.\r\n///\r\nKLF_UNLOADPREVIOUS --- This flag is unsupported. Use the UnloadKeyboardLayout function instead.'),
('MAKELANGID_Table1', 'Primary language identifier --- Sublanguage identifier --- Meaning\r\n///\r\nLANG_NEUTRAL --- SUBLANG_NEUTRAL --- Language neutral\r\n///\r\nLANG_NEUTRAL --- SUBLANG_DEFAULT --- User default language\r\n///\r\nLANG_NEUTRAL --- SUBLANG_SYS_DEFAULT --- System default language\r\n///\r\nLANG_NEUTRAL --- SUBLANG_CUSTOM_DEFAULT --- Windows Vista and later: Default custom locale\r\n///\r\nLANG_NEUTRAL --- SUBLANG_CUSTOM_UNSPECIFIED --- Windows Vista and later: Unspecified custom locale\r\n///\r\nLANG_NEUTRAL --- SUBLANG_UI_CUSTOM_DEFAULT --- Windows Vista and later: Default custom Multilingual User Interface locale'),
('NI_COMPOSITIONSTR_Table1', 'Value --- Meaning\r\n///\r\nCPS_COMPLETE --- To determine the composition string as the result string. \r\n///\r\nCPS_CONVERT --- To convert the composition string.\r\n///\r\nCPS_REVERT --- To revert the composition string. The \r\ncurrent composition string will be canceled and the unconverted string will be set as the composition string.\r\n///\r\nCPS_CANCEL --- To clear the composition string and set \r\nthe status as no composition string.'),
('OemKeyScan_Table1', 'Bit --- Description\r\n///\r\n1 --- Either SHIFT key is pressed.\r\n///\r\n2 --- Either CTRL key is pressed.\r\n///\r\n4 --- Either ALT key is pressed.\r\n///\r\n8 --- The Hankaku key is pressed.\r\n///\r\n16 --- Reserved (defined by the keyboard layout driver).\r\n///\r\n32 --- Reserved (defined by the keyboard layout driver).'),
('PeekMessage_Table1', 'Value --- Meaning\r\n///\r\nPM_NOREMOVE 0x0000 --- Messages are not removed from the queue after processing by PeekMessage.\r\n///\r\nPM_REMOVE 0x0001 --- Messages are removed from the queue after processing by PeekMessage.\r\n///\r\nPM_NOYIELD 0x0002 --- Prevents the system from releasing any thread that is waiting for the caller to go idle (see WaitForInputIdle).\r\n\r\nCombine this value with either PM_NOREMOVE or PM_REMOVE.'),
('PeekMessage_Table2', 'Value --- Meaning\r\n///\r\nPM_QS_INPUT (QS_INPUT << 16) --- Process mouse and keyboard messages.\r\n///\r\nPM_QS_PAINT (QS_PAINT << 16) --- Process paint messages.\r\n///\r\nPM_QS_POSTMESSAGE ((QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER) << 16) --- Process all posted messages, including timers and hotkeys. \r\n///\r\nPM_QS_SENDMESSAGE (QS_SENDMESSAGE << 16) --- Process all sent messages.'),
('PostMessage_Table1', 'Value --- Meaning\r\n///\r\nHWND_BROADCAST((HWND)0xffff) --- The message is posted to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows. The message is not posted to child windows.\r\n/// \r\nNULL --- The function behaves like a call to PostThreadMessage with the dwThreadId parameter set to the identifier of the current thread.'),
('RegisterHotKey_Table1', 'Value --- Meaning\r\n///\r\nMOD_ALT 0x0001 --- Either ALT key must be held down.\r\n///\r\nMOD_CONTROL 0x0002 --- Either CTRL key must be held down.\r\n///\r\nMOD_NOREPEAT 0x4000 --- Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications.\r\n\r\nWindows Vista:  This flag is not supported.\r\n///\r\nMOD_SHIFT 0x0004 --- Either SHIFT key must be held down.\r\n///\r\nMOD_WIN 0x0008 --- Either WINDOWS key was held down. These keys are labeled with the Windows logo. Keyboard shortcuts that involve the WINDOWS key are reserved for use by the operating system.'),
('SendMessageTimeout_Table1', 'Value --- Meaning\r\n///\r\nSMTO_ABORTIFHUNG 0x0002 --- The function returns without waiting for the time-out period to elapse if the receiving thread appears to not respond or \"hangs.\"\r\n///\r\nSMTO_BLOCK 0x0001 --- Prevents the calling thread from processing any other requests until the function returns.\r\n/// SMTO_NORMAL 0x0000 --- The calling thread is not prevented from processing other requests while waiting for the function to return.\r\n///\r\nSMTO_NOTIMEOUTIFNOTHUNG 0x0008 --- The function does not enforce the time-out period as long as the receiving thread is processing messages.\r\n///\r\nSMTO_ERRORONEXIT 0x0020 --- The function should return 0 if the receiving window is destroyed or its owning thread dies while the message is being processed.'),
('System-Defined Messages_Table1', 'Prefix --- Message category\r\n///\r\nABM and ABN --- Application desktop toolbar\r\n///\r\nACM and ACN --- Animation control \r\n///\r\nBCM, BCN, BM, and BN --- Button control\r\n///\r\nCB and CBN --- ComboBox control\r\n///\r\nCBEM and CBEN --- ComboBoxEx control\r\n///\r\nCCM --- General control\r\n///\r\nCDM --- Common dialog box\r\n///\r\nDFM --- Default context menu\r\n///\r\nDL --- Drag list box\r\n///\r\nDM --- Default push button control\r\n///\r\nDTM and DTN --- Date and time picker control\r\n///\r\nEM and EN --- Edit control\r\n///\r\nHDM and HDN --- Header control\r\n///\r\nHKM --- Hot key control\r\n///\r\nIPM and IPN --- IP address control\r\n///\r\nLB and LBN --- List box control\r\n///\r\nLM --- SysLink control\r\n///\r\nLVM and LVN --- List view control\r\n///\r\nMCM and MCN --- Month calendar control\r\n///\r\nPBM --- Progress bar\r\n///\r\nPGM and PGN --- Pager control\r\n///\r\nPSM and PSN --- Property sheet\r\n///\r\nRB and RBN --- Rebar control\r\n///\r\nSB and SBN --- Status bar window\r\n///\r\nSBM --- Scroll bar control\r\n///\r\nSMC --- Shell menu\r\n///\r\nSTM and STN --- Static control\r\n///\r\nTB and TBN --- Toolbar\r\n///\r\nTBM and TRBN --- Trackbar control\r\n///\r\nTCM and TCN --- Tab control\r\n///\r\nTDM and TDN --- Task dialog\r\n///\r\nTTM and TTN --- Tooltip control\r\n///\r\nTVM and TVN --- Tree-view control\r\n///\r\nUDM and UDN --- Up-down control\r\n///\r\nWM --- General'),
('ToAscii_Table1', 'Return value --- Description\r\n///\r\n0 --- The specified virtual key has no translation for the current state of the keyboard.\r\n///\r\n1 --- One character was copied to the buffer.\r\n///\r\n2 --- Two characters were copied to the buffer. This usually happens when a dead-key character (accent or diacritic) stored in the keyboard layout cannot be composed with the specified virtual key to form a single character.'),
('ToAsciiEx_Table1', 'Return value --- Description\r\n///\r\n0 --- The specified virtual key has no translation for the current state of the keyboard.\r\n///\r\n1 --- One character was copied to the buffer.\r\n///\r\n2 --- Two characters were copied to the buffer. This usually happens when a dead-key character (accent or diacritic) stored in the keyboard layout cannot be composed with the specified virtual key to form a single character.'),
('ToUnicode_Table1', 'Return value --- Description\r\n///\r\n-1 --- The specified virtual key is a dead-key character (accent or diacritic). This value is returned regardless of the keyboard layout, even if several characters have been typed and are stored in the keyboard state. If possible, even with Unicode keyboard layouts, the function has written a spacing version of the dead-key character to the buffer specified by pwszBuff. For example, the function writes the character SPACING ACUTE (0x00B4), rather than the character NON_SPACING ACUTE (0x0301).\r\n///\r\n0 --- The specified virtual key has no translation for the current state of the keyboard. Nothing was written to the buffer specified by pwszBuff.\r\n///\r\n1 --- One character was written to the buffer specified by pwszBuff.\r\n///\r\n2 ≤ value --- Two or more characters were written to the buffer specified by pwszBuff. The most common cause for this is that a dead-key character (accent or diacritic) stored in the keyboard layout could not be combined with the specified virtual key to form a single character. However, the buffer may contain more characters than the return value specifies. When this happens, any extra characters are invalid and should be ignored.'),
('ToUnicodeEx_Table1', 'Return value --- Description\r\n///\r\n-1 --- The specified virtual key is a dead-key character (accent or diacritic). This value is returned regardless of the keyboard layout, even if several characters have been typed and are stored in the keyboard state. If possible, even with Unicode keyboard layouts, the function has written a spacing version of the dead-key character to the buffer specified by pwszBuff. For example, the function writes the character SPACING ACUTE (0x00B4), rather than the character NON_SPACING ACUTE (0x0301).\r\n///\r\n0 --- The specified virtual key has no translation for the current state of the keyboard. Nothing was written to the buffer specified by pwszBuff.\r\n///\r\n1 --- One character was written to the buffer specified by pwszBuff.\r\n///\r\n2 ≤ value --- Two or more characters were written to the buffer specified by pwszBuff. The most common cause for this is that a dead-key character (accent or diacritic) stored in the keyboard layout could not be combined with the specified virtual key to form a single character. However, the buffer may contain more characters than the return value specifies. When this happens, any extra characters are invalid and should be ignored.'),
('Virtual-Key Codes_Table1', 'Constant/value --- Description\r\n///\r\nVK_LBUTTON 0x01 --- Left mouse button\r\n///\r\nVK_RBUTTON 0x02 --- Right mouse button\r\n///\r\nVK_CANCEL 0x03 --- Control-break processing\r\n///\r\nVK_MBUTTON 0x04 --- Middle mouse button (three-button mouse)\r\n///\r\nVK_XBUTTON1 0x05 --- X1 mouse button\r\n///\r\nVK_XBUTTON2 0x06 --- X2 mouse button\r\n///\r\n- 0x07 --- Undefined\r\n///\r\nVK_BACK 0x08 --- BACKSPACE key\r\n///\r\nVK_TAB 0x09 --- TAB key\r\n///\r\n- 0x0A-0B --- Reserved\r\n///\r\nVK_CLEAR 0x0C --- CLEAR key\r\n///\r\nVK_RETURN 0x0D --- ENTER key\r\n///\r\n- 0x0E-0F --- Undefined\r\n///\r\nVK_SHIFT 0x10 --- SHIFT key\r\n///\r\nVK_CONTROL 0x11 --- CTRL key\r\n///\r\nVK_MENU 0x12 --- ALT key\r\n///\r\nVK_PAUSE 0x13 --- PAUSE key\r\n///\r\nVK_CAPITAL 0x14 --- CAPS LOCK key\r\n///\r\nVK_KANA 0x15 --- IME Kana mode\r\n///\r\nVK_HANGUEL 0x15 --- IME Hanguel mode (maintained for compatibility; use VK_HANGUL)\r\n///\r\nVK_HANGUL 0x15 --- IME Hangul mode\r\n///\r\n- 0x16 --- Undefined\r\n///\r\nVK_JUNJA 0x17 --- IME Junja mode\r\n///\r\nVK_FINAL 0x18 --- IME final mode\r\n///\r\nVK_HANJA 0x19 --- IME Hanja mode\r\n///\r\nVK_KANJI 0x19 --- IME Kanji mode\r\n///\r\n- 0x1A --- Undefined\r\n///\r\nVK_ESCAPE 0x1B --- ESC key\r\n///\r\nVK_CONVERT 0x1C --- IME convert\r\n///\r\nVK_NONCONVERT 0x1D --- IME nonconvert\r\n///\r\nVK_ACCEPT 0x1E --- IME accept\r\n///\r\nVK_MODECHANGE 0x1F --- IME mode change request\r\n///\r\nVK_SPACE 0x20 --- SPACEBAR\r\n///\r\nVK_PRIOR 0x21 --- PAGE UP key\r\n///\r\nVK_NEXT 0x22 --- PAGE DOWN key\r\n///\r\nVK_END 0x23 --- END key\r\n///\r\nVK_HOME 0x24 --- HOME key\r\n///\r\nVK_LEFT 0x25 --- LEFT ARROW key\r\n///\r\nVK_UP 0x26 --- UP ARROW key\r\n///\r\nVK_RIGHT 0x27 --- RIGHT ARROW key\r\n///\r\nVK_DOWN 0x28 --- DOWN ARROW key\r\n///\r\nVK_SELECT 0x29 --- SELECT key\r\n///\r\nVK_PRINT 0x2A --- PRINT key\r\n///\r\nVK_EXECUTE 0x2B --- EXECUTE key\r\n///\r\nVK_SNAPSHOT 0x2C --- PRINT SCREEN key\r\n///\r\nVK_INSERT 0x2D --- INS key\r\n///\r\nVK_DELETE 0x2E --- DEL key\r\n///\r\nVK_HELP 0x2F --- HELP key\r\n///\r\n0x30 --- 0 key\r\n///\r\n0x31 --- 1 key\r\n///\r\n0x32 --- 2 key\r\n///\r\n0x33 --- 3 key\r\n///\r\n0x34 --- 4 key\r\n///\r\n0x35 --- 5 key\r\n///\r\n0x36 --- 6 key\r\n///\r\n0x37 --- 7 key\r\n///\r\n0x38 --- 8 key\r\n///\r\n0x39 --- 9 key\r\n///\r\n- 0x3A-40 --- Undefined\r\n///\r\n0x41 --- A key\r\n///\r\n0x42 --- B key\r\n///\r\n0x43 --- C key\r\n///\r\n0x44 --- D key\r\n///\r\n0x45 --- E key\r\n///\r\n0x46 --- F key\r\n///\r\n0x47 --- G key\r\n///\r\n0x48 --- H key\r\n///\r\n0x49 --- I key\r\n///\r\n0x4A --- J key\r\n///\r\n0x4B --- K key\r\n///\r\n0x4C --- L key\r\n///\r\n0x4D --- M key\r\n///\r\n0x4E --- N key\r\n///\r\n0x4F --- O key\r\n///\r\n0x50 --- P key\r\n///\r\n0x51 --- Q key\r\n///\r\n0x52 --- R key\r\n///\r\n0x53 --- S key\r\n///\r\n0x54 --- T key\r\n///\r\n0x55 --- U key\r\n///\r\n0x56 --- V key\r\n///\r\n0x57 --- W key\r\n///\r\n0x58 --- X key\r\n///\r\n0x59 --- Y key\r\n///\r\n0x5A --- Z key\r\n///\r\nVK_LWIN 0x5B --- Left Windows key (Natural keyboard)\r\n///\r\nVK_RWIN 0x5C --- Right Windows key (Natural keyboard)\r\n///\r\nVK_APPS 0x5D --- Applications key (Natural keyboard)\r\n///\r\n- 0x5E --- Reserved\r\n///\r\nVK_SLEEP 0x5F --- Computer Sleep key\r\n///\r\nVK_NUMPAD0 0x60 --- Numeric keypad 0 key\r\n///\r\nVK_NUMPAD1 0x61 --- Numeric keypad 1 key\r\n///\r\nVK_NUMPAD2 0x62 --- Numeric keypad 2 key\r\n///\r\nVK_NUMPAD3 0x63 --- Numeric keypad 3 key\r\n///\r\nVK_NUMPAD4 0x64 --- Numeric keypad 4 key\r\n///\r\nVK_NUMPAD5 0x65 --- Numeric keypad 5 key\r\n///\r\nVK_NUMPAD6 0x66 --- Numeric keypad 6 key\r\n///\r\nVK_NUMPAD7 0x67 --- Numeric keypad 7 key\r\n///\r\nVK_NUMPAD8 0x68 --- Numeric keypad 8 key\r\n///\r\nVK_NUMPAD9 0x69 --- Numeric keypad 9 key\r\n///\r\nVK_MULTIPLY 0x6A --- Multiply key\r\n///\r\nVK_ADD 0x6B --- Add key\r\n///\r\nVK_SEPARATOR 0x6C --- Separator key\r\n///\r\nVK_SUBTRACT 0x6D --- Subtract key\r\n///\r\nVK_DECIMAL 0x6E --- Decimal key\r\n///\r\nVK_DIVIDE 0x6F --- Divide key\r\n///\r\nVK_F1 0x70 --- F1 key\r\n///\r\nVK_F2 0x71 --- F2 key\r\n///\r\nVK_F3 0x72 --- F3 key\r\n///\r\nVK_F4 0x73 --- F4 key\r\n///\r\nVK_F5 0x74 --- F5 key\r\n///\r\nVK_F6 0x75 --- F6 key\r\n///\r\nVK_F7 0x76 --- F7 key\r\n///\r\nVK_F8 0x77 --- F8 key\r\n///\r\nVK_F9 0x78 --- F9 key\r\n///\r\nVK_F10 0x79 --- F10 key\r\n///\r\nVK_F11 0x7A --- F11 key\r\n///\r\nVK_F12 0x7B --- F12 key\r\n///\r\nVK_F13 0x7C --- F13 key\r\n///\r\nVK_F14 0x7D --- F14 key\r\n///\r\nVK_F15 0x7E --- F15 key\r\n///\r\nVK_F16 0x7F --- F16 key\r\n///\r\nVK_F17 0x80 --- F17 key\r\n///\r\nVK_F18 0x81 --- F18 key\r\n///\r\nVK_F19 0x82 --- F19 key\r\n///\r\nVK_F20 0x83 --- F20 key\r\n///\r\nVK_F21 0x84 --- F21 key\r\n///\r\nVK_F22 0x85 --- F22 key\r\n///\r\nVK_F23 0x86 --- F23 key\r\n///\r\nVK_F24 0x87 --- F24 key\r\n///\r\n- 0x88-8F --- Unassigned\r\n///\r\nVK_NUMLOCK 0x90 --- NUM LOCK key\r\n///\r\nVK_SCROLL 0x91 --- SCROLL LOCK key\r\n///\r\n0x92-96 --- OEM specific\r\n///\r\n- 0x97-9F --- Unassigned\r\n///\r\nVK_LSHIFT 0xA0 --- Left SHIFT key\r\n///\r\nVK_RSHIFT 0xA1 --- Right SHIFT key\r\n///\r\nVK_LCONTROL 0xA2 --- Left CONTROL key\r\n///\r\nVK_RCONTROL 0xA3 --- Right CONTROL key\r\n///\r\nVK_LMENU 0xA4 --- Left MENU key\r\n///\r\nVK_RMENU 0xA5 --- Right MENU key\r\n///\r\nVK_BROWSER_BACK 0xA6 --- Browser Back key\r\n///\r\nVK_BROWSER_FORWARD 0xA7 --- Browser Forward key\r\n///\r\nVK_BROWSER_REFRESH 0xA8 --- Browser Refresh key\r\n///\r\nVK_BROWSER_STOP 0xA9 --- Browser Stop key\r\n///\r\nVK_BROWSER_SEARCH 0xAA --- Browser Search key\r\n///\r\nVK_BROWSER_FAVORITES 0xAB --- Browser Favorites key\r\n///\r\nVK_BROWSER_HOME 0xAC --- Browser Start and Home key\r\n///\r\nVK_VOLUME_MUTE 0xAD --- Volume Mute key\r\n///\r\nVK_VOLUME_DOWN 0xAE --- Volume Down key\r\n///\r\nVK_VOLUME_UP 0xAF --- Volume Up key\r\n///\r\nVK_MEDIA_NEXT_TRACK 0xB0 --- Next Track key\r\n///\r\nVK_MEDIA_PREV_TRACK 0xB1 --- Previous Track key\r\n///\r\nVK_MEDIA_STOP 0xB2 --- Stop Media key\r\n///\r\nVK_MEDIA_PLAY_PAUSE 0xB3 --- Play/Pause Media key\r\n///\r\nVK_LAUNCH_MAIL 0xB4 --- Start Mail key\r\n///\r\nVK_LAUNCH_MEDIA_SELECT 0xB5 --- Select Media key\r\n///\r\nVK_LAUNCH_APP1 0xB6 --- Start Application 1 key\r\n///\r\nVK_LAUNCH_APP2 0xB7 --- Start Application 2 key\r\n///\r\n- 0xB8-B9 --- Reserved\r\n///\r\nVK_OEM_1 0xBA --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \';:\' key\r\n///\r\nVK_OEM_PLUS 0xBB --- For any country/region, the \'+\' key\r\n///\r\nVK_OEM_COMMA 0xBC --- For any country/region, the \',\' key\r\n///\r\nVK_OEM_MINUS 0xBD --- For any country/region, the \'-\' key\r\n///\r\nVK_OEM_PERIOD 0xBE --- For any country/region, the \'.\' key\r\n///\r\nVK_OEM_2 0xBF --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'/?\' key\r\n///\r\nVK_OEM_3 0xC0 --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'`~\' key\r\n///\r\n- 0xC1-D7 --- Reserved\r\n///\r\n- 0xD8-DA --- Unassigned\r\n///\r\nVK_OEM_4 0xDB --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'[{\' key\r\n///\r\nVK_OEM_5 0xDC --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'\\|\' key\r\n///\r\nVK_OEM_6 0xDD --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \']}\' key\r\n///\r\nVK_OEM_7 0xDE --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'single-quote/double-quote\' key\r\n///\r\nVK_OEM_8 0xDF --- Used for miscellaneous characters; it can vary by keyboard.\r\n///\r\n- 0xE0 --- Reserved\r\n///\r\n0xE1 --- OEM specific\r\n///\r\nVK_OEM_102 0xE2 --- Either the angle bracket key or the backslash key on the RT 102-key keyboard\r\n///\r\n0xE3-E4 --- OEM specific\r\n///\r\nVK_PROCESSKEY 0xE5 --- IME PROCESS key\r\n///\r\n0xE6 --- OEM specific\r\n///\r\nVK_PACKET 0xE7 --- Used to pass Unicode characters as if they were keystrokes. The VK_PACKET key is the low word of a 32-bit Virtual Key value used for non-keyboard input methods. For more information, see Remark in KEYBDINPUT, SendInput, WM_KEYDOWN, and WM_KEYUP\r\n///\r\n- 0xE8 --- Unassigned\r\n///\r\n0xE9-F5 --- OEM specific\r\n///\r\nVK_ATTN 0xF6 --- Attn key\r\n///\r\nVK_CRSEL 0xF7 --- CrSel key\r\n///\r\nVK_EXSEL 0xF8 --- ExSel key\r\n///\r\nVK_EREOF 0xF9 --- Erase EOF key\r\n///\r\nVK_PLAY 0xFA --- Play key\r\n///\r\nVK_ZOOM 0xFB --- Zoom key\r\n///\r\nVK_NONAME 0xFC --- Reserved\r\n///\r\nVK_PA1 0xFD --- PA1 key\r\n///\r\nVK_OEM_CLEAR 0xFE --- Clear key'),
('VkKeyScan_Table1', 'Return value --- Description\r\n///\r\n1 --- Either SHIFT key is pressed.\r\n///\r\n2 --- Either CTRL key is pressed.\r\n///\r\n4 --- Either ALT key is pressed.\r\n///\r\n8 --- The Hankaku key is pressed\r\n///\r\n16 --- Reserved (defined by the keyboard layout driver).\r\n///\r\n32 --- Reserved (defined by the keyboard layout driver).'),
('VkKeyScanEx_Table1', 'Return value --- Description\r\n///\r\n1 --- Either SHIFT key is pressed.\r\n///\r\n2 --- Either CTRL key is pressed.\r\n///\r\n4 --- Either ALT key is pressed.\r\n///\r\n8 --- The Hankaku key is pressed\r\n///\r\n16 --- Reserved (defined by the keyboard layout driver).\r\n///\r\n32 --- Reserved (defined by the keyboard layout driver).'),
('WM_CHAR_Table1', 'Bits --- Meaning\r\n///\r\n0-15 --- The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative. \r\n///\r\n16-23 --- The scan code. The value depends on the OEM. \r\n///\r\n24 --- Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or 102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0. \r\n///\r\n25-28 --- Reserved; do not use. \r\n///\r\n29 --- The context code. The value is 1 if the ALT key is held down while the key is pressed; otherwise, the value is 0. \r\n///\r\n30 --- The previous key state. The value is 1 if the key is down before the message is sent, or it is 0 if the key is up. \r\n///\r\n31 --- The transition state. The value is 1 if the key is being released, or it is 0 if the key is being pressed.'),
('WM_IME_CHAR_Table1', 'Bit --- Meaning\r\n///\r\n0-15 --- Repeat count. Since the first byte and second byte are continuous, this is always 1. \r\n///\r\n16-23 --- Scan code for a complete Asian character. \r\n///\r\n24 --- Extended key. \r\n///\r\n25-28 --- Not used. \r\n///\r\n29 --- Context code. \r\n///\r\n30 --- Previous key state. \r\n///\r\n31 --- Transition state.'),
('WM_IME_COMPOSITION_Table1', 'Value --- Meaning\r\n///\r\nCS_INSERTCHAR --- Insert the wParam composition character at the current insertion point. An application should display the composition character if it processes this message.\r\n///\r\nCS_NOMOVECARET --- Do not move the caret position as a result of processing the message. For example, if an IME specifies a combination of CS_INSERTCHAR and CS_NOMOVECARET, the application should insert the specified character at the current caret position but should not move the caret to the next position. A subsequent WM_IME_COMPOSITION message with GCS_RESULTSTR will replace this character.'),
('WM_IME_KEYDOWN_Table1', 'Bit --- Meaning\r\n///\r\n0-15 --- Repeat count. \r\n///\r\n16-23 --- Scan code. \r\n///\r\n24 --- Extended key. This value is 1 if it is an extended key. Otherwise, it is 0. \r\n///\r\n25-28 --- Not used. \r\n///\r\n29 --- Context code. This value is always 0. \r\n///\r\n30 --- Previous key state. This value is 1 if the key is down or 0 if it is up.\r\n///\r\n31 --- Transition state. This value is always 0.'),
('WM_IME_KEYUP_Table1', 'Bit --- Meaning\r\n///\r\n0-15 --- Repeat count. This value is always 1. \r\n///\r\n16-23 --- Scan code. \r\n///\r\n24 --- Extended key. This value is 1 if it is an extended key. Otherwise, it is 0. \r\n///\r\n25-28 --- Not used.\r\n/// \r\n29 --- Context code. This value is always 0. \r\n///\r\n30 --- Previous key state. This value is always 1. \r\n///\r\n31 --- Transition state. This value is always 1.'),
('WM_IME_SETCONTEXT_Table1', 'Value --- Meaning\r\n///\r\nISC_SHOWUICOMPOSITIONWINDOW --- Show the composition window by user interface window.\r\n///\r\nISC_SHOWUIGUIDWINDOW --- Show the guide window by user interface window.\r\n///\r\nISC_SHOWUISOFTKBD --- Show the soft keyboard by user interface window.\r\n///\r\nISC_SHOWUICANDIDATEWINDOW --- Show the candidate window of index 0 by user interface window.\r\n///\r\nISC_SHOWUICANDIDATEWINDOW << 1 --- Show the candidate window of index 1 by user interface window.\r\n///\r\nISC_SHOWUICANDIDATEWINDOW << 2 --- Show the candidate window of index 2 by user interface window.\r\n///\r\nISC_SHOWUICANDIDATEWINDOW << 3 --- Show the candidate window of index 3 by user interface window.'),
('WM_INPUTLANGCHANGEREQUEST_Table1', 'Value --- Meaning\r\n///\r\nINPUTLANGCHANGE_BACKWARD 0x0004 --- A hot key was used to choose the previous input locale in the installed list of input locales. This flag cannot be used with the INPUTLANGCHANGE_FORWARD flag.\r\n///\r\nINPUTLANGCHANGE_FORWARD 0x0002 --- A hot key was used to choose the next input locale in the installed list of input locales. This flag cannot be used with the INPUTLANGCHANGE_BACKWARD flag.\r\n///\r\nINPUTLANGCHANGE_SYSCHARSET 0x0001 --- The new input locale\'s keyboard layout can be used with the system character set.'),
('WM_KEYDOWN_Table1', 'Bits --- Meaning\r\n///\r\n0-15 --- The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative. \r\n///\r\n16-23 --- The scan code. The value depends on the OEM. \r\n///\r\n24 --- Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or 102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0. \r\n///\r\n25-28 --- Reserved; do not use. \r\n///\r\n29 --- The context code. The value is always 0 for a WM_KEYDOWN message. \r\n///\r\n30 --- The previous key state. The value is 1 if the key is down before the message is sent, or it is zero if the key is up. \r\n///\r\n31 --- The transition state. The value is always 0 for a WM_KEYDOWN message.'),
('WM_KEYUP_Table1', 'Bits --- Meaning\r\n///\r\n0-15 --- The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the user holding down the key. The repeat count is always 1 for a WM_KEYUP message. \r\n///\r\n16-23 --- The scan code. The value depends on the OEM. \r\n///\r\n24 --- Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or 102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0. \r\n///\r\n25-28 --- Reserved; do not use. \r\n///\r\n29 --- The context code. The value is always 0 for a WM_KEYUP message. \r\n///\r\n30 --- The previous key state. The value is always 1 for a WM_KEYUP message. \r\n///\r\n31 --- The transition state. The value is always 1 for a WM_KEYUP message.');

-- --------------------------------------------------------

--
-- テーブルの構造 `translation`
--

CREATE TABLE `translation` (
  `id` int(11) NOT NULL,
  `original` varchar(128) NOT NULL,
  `translated` varchar(128) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- ダンプしたテーブルのインデックス
--

--
-- テーブルのインデックス `entries`
--
ALTER TABLE `entries`
  ADD PRIMARY KEY (`entry_name`),
  ADD UNIQUE KEY `entry_name` (`entry_name`);

--
-- テーブルのインデックス `tables`
--
ALTER TABLE `tables`
  ADD PRIMARY KEY (`table_name`),
  ADD UNIQUE KEY `table_name` (`table_name`);

--
-- テーブルのインデックス `translation`
--
ALTER TABLE `translation`
  ADD PRIMARY KEY (`id`);

--
-- ダンプしたテーブルの AUTO_INCREMENT
--

--
-- テーブルの AUTO_INCREMENT `translation`
--
ALTER TABLE `translation`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
