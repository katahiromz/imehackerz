-- phpMyAdmin SQL Dump
-- version 5.2.1
-- https://www.phpmyadmin.net/
--
-- ホスト: 127.0.0.1
-- 生成日時: 2024-08-14 03:43:14
-- サーバのバージョン： 10.4.32-MariaDB
-- PHP のバージョン: 8.2.12

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- データベース: `imehackerz_ja`
--

-- --------------------------------------------------------

--
-- テーブルの構造 `entries`
--

CREATE TABLE `entries` (
  `entry_name` varchar(60) NOT NULL,
  `entry_type` varchar(32) NOT NULL,
  `description` varchar(8192) DEFAULT NULL,
  `syntax` varchar(2048) DEFAULT NULL,
  `parameters` varchar(2048) DEFAULT NULL,
  `return_value` varchar(1024) DEFAULT NULL,
  `remarks` varchar(4096) DEFAULT NULL,
  `see_also` varchar(2048) DEFAULT NULL,
  `added_time` timestamp NOT NULL DEFAULT current_timestamp(),
  `modified_time` timestamp NOT NULL DEFAULT current_timestamp(),
  `header` varchar(128) DEFAULT NULL,
  `modules` varchar(128) DEFAULT NULL,
  `sources` varchar(256) DEFAULT NULL,
  `translators` varchar(128) DEFAULT NULL,
  `ros_location` varchar(256) DEFAULT NULL,
  `analysis` varchar(512) DEFAULT NULL,
  `prev_page` varchar(64) NOT NULL,
  `next_page` varchar(64) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- テーブルのデータのダンプ `entries`
--

INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('ABM_ACTIVATE', 'メッセージ', 'システムにAppBarがアクティブ化したことを通知する。AppBarは、WM_ACTIVATEメッセージへの反応としてこのメッセージを呼び出すべきだ。', 'SHAppBarMessage(ABM_ACTIVATE, pabd);', 'pabd --- アクティブ化するAppBarを識別するAPPBARDATA構造体へのポインタ。あなたはこのメッセージを送信するときにcbSizeとhWndメンバーを指定しなければならない。他のメンバーは無視される。', 'TRUEを常に返す。', 'このメッセージは、pabdによって指し示される構造体のhWndメンバーがautohide AppBarを識別していれば、無視される。システムは自動的にautohide AppBarに対してZオーダーをセットする。', 'SHAppBarMessage|APPBARDATA', '2016-09-21 12:17:17', '2016-09-21 12:17:17', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787943.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_GETAUTOHIDEBAR', 'メッセージ', 'スクリーンの端に関連付けられたautohideなAppBarへのハンドルを取得する。もしシステムに複数のモニターがあれば、プライマリーなタスクバーを含むモニターが使われる。\r\n\r\n注意: 特定のモニターでautohideなAppBarに問い合わせを行うには、ABM_GETAUTOHIDEBAREXを使う。', 'hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, pabd);', 'pabd --- スクリーンの端を指定するAPPBARDATA構造体へのポインタ。あなたはこのメッセージを送信するときに、cbSizeとuEdgeメンバーを指定しなければならない。他のメンバーは無視される。', 'autohideなAppBarへのハンドルを返す。もしエラーが発生したか、autohideなAppBarが指定された端に関連付けられていなければ、NULLを戻り値として返す。', '', 'SHAppBarMessage|APPBARDATA|ABM_GETAUTOHIDEBAREX', '2016-09-21 12:21:34', '2016-09-21 12:21:34', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787945.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_GETAUTOHIDEBAREX', 'メッセージ', 'スクリーンの端に関連付けられたautohideなAppBarへのハンドルを取得する。このメッセージは、複数モニターの状況で、特定のモニターを指定できるようにABM_GETAUTOHIDEBARを拡張する。', 'hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, pabd);', 'pabd --- スクリーンの端とモニターを指定するAPPBARDATA構造体へのポインタ。あなたはこのメッセージを送信するときに、cbSize、uEdge、rcメンバーを指定しなければならない。他のメンバーは無視される。', 'autohideなAppBarへのハンドルを返す。もしエラーが起きたか、与えられたモニターで与えられた端に関連付けられたautohideなAppBarが存在しなければ、戻り値としてNULLを返す。', '', 'SHAppBarMessage|APPBARDATA|ABM_GETAUTOHIDEBAR', '2016-09-21 12:25:04', '2016-09-21 12:25:04', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/hh706878.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_GETSTATE', 'メッセージ', 'Windowsタスクバーにおいて、autohideで、always-on-topな状態たちを取得する。', 'uState = (UINT) SHAppBarMessage(ABM_GETSTATE, pabd);', 'pabd --- APPBARDATA構造体へのポインタ。あなたはこのメッセージを送信するときに、cbSizeメンバーを指定しなければならない。他のメンバーは無視される。', 'タスクバーがautohideでもalways-on-top状態でもなければゼロを返す。さもなければ戻り値は、以下の１個または両方の値である：\r\n\r\n[table:ABM_GETSTATE_Table1]', '', 'SHAppBarMessage|APPBARDATA|ABM_SETSTATE', '2016-09-21 12:27:51', '2016-09-21 12:27:51', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787947.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_GETTASKBARPOS', 'メッセージ', 'Windowsタスクバーのバウンディング長方形（限界範囲）を取得する。', 'fResult = (BOOL) SHAppBarMessage(ABM_GETTASKBARPOS, pabd);', 'APPBARDATA構造体へのポインタ。rcメンバーは、タスクバーのバウンディング長方形（限界範囲）をスクリーン座標系で受け取る。あなたはこのメッセージを送信するときに、cbSizeメンバーを指定しなければならない。他のメンバーは無視される。', '成功ならTRUEを返す。さもなければFALSE。', 'これはシステムタスクバーのみに適用される。他のオブジェクト、特にサードパーティーのソフトウェアで供給されるツールバーは、存在し得る。結果として、Windowsタスクバーによってカバーされないスクリーン領域のいくつかはユーザーに見えないかもしれない。タスクバーにも他のアプリのAppBarにもカバーされないスクリーン領域を取得するには、すなわち、アプリで利用可能なワーキング領域を取得するは、GetMonitorInfo関数を使う。', 'SHAppBarMessage|APPBARDATA', '2016-09-21 12:38:46', '2016-09-21 12:38:46', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787949.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_NEW', 'メッセージ', '新しいAppBarを登録し、システムがAppBarに通知メッセージを送信するために使うべきメッセージ識別子を指定する。AppBarはこのメッセージを他のAppBarメッセージを送信する前に送信するべきである。', 'fRegistered = (BOOL) SHAppBarMessage(ABM_NEW, pabd);', 'pabd --- APPBARDATA構造体へのポインタ。新しいAppBarのウィンドウハンドルとメッセージ識別子を含む。あなたはこのメッセージを送信するときに、cbSize、hWnd、そしてuCallbackMessageメンバーを指定しなければならない。他のメンバーは無視される。', '成功ならTRUEを返す。エラーが発生したか、AppBarがすでに登録済みならFALSEを返す。', '', 'SHAppBarMessage|APPBARDATA|ABM_REMOVE', '2016-09-21 12:42:09', '2016-09-21 12:42:09', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787951.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_QUERYPOS', 'メッセージ', 'AppBarに対してサイズとスクリーン位置を要求する。要求されたときに、このメッセージはAppBarに対するスクリーンの端とバウンディング長方形（限界領域）を提案する。システムはAppBarがWindowsタスクバーや他のAppBarを邪魔しないようにそのバウンディング長方形を補正する。', 'SHAppBarMessage(ABM_QUERYPOS, pabd);', 'pabd --- APPBARDATA構造体へのポインタ。uEdgeメンバーはスクリーンの端を指定し、rcメンバーは提案されたバウンディング長方形を含む。SHAppBarMessage関数から戻ったとき、rcは承認されたバウンディング長方形を含む。あなたはこのメッセージを送信するときに、cbSize、hWnd、uEdge、rcメンバーを指定しなければならない。他のメンバーは無視される。', 'TRUEを常に返す。', 'AppBarは、ABM_SETPOSメッセージを送信する前に、このメッセージを送信すべきだ。', 'SHAppBarMessage|APPBARDATA|ABM_SETPOS', '2016-09-21 12:46:41', '2016-09-21 12:46:41', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787953.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_REMOVE', 'メッセージ', 'システム内部のリストからAppBarを除去することにより、AppBarの登録を解除する。システムはAppBarにもはや通知メッセージを送信しなくなり、AppBarによって使われるスクリーン領域を使うのを邪魔しなくなる。', 'SHAppBarMessage(ABM_REMOVE, pabd);', 'pabd --- APPBARDATA構造体へのポインタ。登録を解除するAppBarへのハンドルを含む。あなたはこのメッセージを送信するときに、cbSizeとhWndメンバーを指定しなければならない。他のメンバーは無視される。', 'TRUEを常に返す。', 'このメッセージはシステムがABN_POSCHANGED通知メッセージをすべてのAppBarたちに送信させる。', 'SHAppBarMessage|APPBARDATA|ABM_NEW', '2016-09-21 12:50:55', '2016-09-21 12:50:55', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787955.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_SETAUTOHIDEBAR', 'メッセージ', 'スクリーンの指定された端に対して、autohideなAppBarを登録または登録を解除する。もしスクリーンが複数のモニターを持っていれば、プライマリーなタスクバーのあるモニターが使われる。\r\n\r\n注意: 特定のモニターでautohideなAppBarを登録または登録を解除するには、ABM_SETAUTOHIDEBAREXを使う。', 'fSuccess = (BOOL) SHAppBarMessage(ABM_SETAUTOHIDEBAR, pabd);', 'pabd --- APPBARDATA構造体へのポインタ。AppBarを登録するには、lParamにTRUEをセットし、登録を解除するにはFALSEをセットする。あなたはこのメッセージを送信するときに、cbSize、hWnd、uEdge、そしてlParamメンバーを指定しなければならない。他のメンバーは無視される。', '成功ならTRUEを返す。エラーが発生したか、autohideなAppBarがすでに与えられた端に登録されていればFALSEを返す。', 'システムは、スクリーンのそれぞれの端に対して、1個のautohideなAppBarのみを受け入れる。これはAPPBARDATA構造体のuEdgeメンバーがセットされているときに決定される。', 'SHAppBarMessage|APPBARDATA|ABM_SETAUTOHIDEBAREX', '2016-09-21 12:55:29', '2016-09-21 12:55:29', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787957.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_SETAUTOHIDEBAREX', 'メッセージ', 'スクリーンの与えられた端に対してautohideなAppBarを登録または登録を解除する。このメッセージは複数モニターの状況で特定のモニターを指定することを可能にするためにABM_SETAUTOHIDEBARを拡張する。', 'fSuccess = (BOOL) SHAppBarMessage(ABM_SETAUTOHIDEBAR, pabd);', 'pabd --- APPBARDATA構造体へのポインタ。AppBarを登録するにはlParamメンバーにTRUEをセットする。登録を解除するにはFALSEをセットする。あなたはこのメッセージを送信するときに、cbSize、hWnd、uEdge、rc、そしてlParamメンバーを指定しなければならない。他のメンバーは無視される。', '成功ならTRUEを返す。エラーが発生したか、指定されたモニターで指定された端に対してautohideなAppBarがすでに登録されていれば、FALSEを返す。', 'システムは、それぞれのモニターのそれぞれの端に対して1個のautohideなAppBarのみを受け入れる。モニターはrcメンバーによって決定され、端は、APPBARDATA構造体のuEdgeメンバーによって決定される。', 'SHAppBarMessage|APPBARDATA|ABM_SETAUTOHIDEBAR', '2016-09-21 12:59:55', '2016-09-21 12:59:55', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/hh706879.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_SETPOS', 'メッセージ', 'AppBarのサイズとスクリーン位置をセットする。このメッセージはAppBarに対するスクリーンの端とバウンディング長方形（限界領域）を指定する。システムはWindowsタスクバーや他のAppBarを邪魔しないようにバウンディング長方形を補正するかもしれない。', 'SHAppBarMessage(ABM_SETPOS, pabd);', 'pabd --- APPBARDATA構造体へのポインタ。uEdgeメンバーはスクリーンの端を指定し、rcメンバーはバウンディング長方形を含む。SHAppBarMessage関数から戻ったときに、rcは承認されたバウンディング長方形を含んでいる。あなたはこのメッセージを送信するときに、cbSize、hWnd、uEdge、rcメンバーを指定しなければならない。他のメンバーは無視される。', '常にTRUEを返す。', 'このメッセージはシステムにすべてのAppBarへABN_POSCHANGED通知メッセージを送信させる。', 'SHAppBarMessage|APPBARDATA|ABM_QUERYPOS', '2016-09-21 13:03:29', '2016-09-21 13:03:29', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787959.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_SETSTATE', 'メッセージ', 'Windowsタスクバーのautohideとalways-on-top状態をセットする。', 'SHAppBarMessage(ABM_SETSTATE, pabd);', 'pabd --- APPBARDATA構造体へのポインタ。あなたはこのメッセージを送信するときに、cbSizeとhWndメンバーを指定しなければならない。望みの状態に対するデータはlParamメンバーにおいて以下の値のいずれかが送信される。\r\n\r\n[table:ABM_SETSTATE_Table1]', '常にTRUEを返す。', '', 'SHAppBarMessage|APPBARDATA|ABM_GETSTATE', '2016-09-21 13:05:54', '2016-09-21 13:05:54', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787961.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABM_WINDOWPOSCHANGED', 'メッセージ', 'AppBarの位置が変更されたときにシステムに通知する。AppBarは、WM_WINDOWPOSCHANGEDメッセージへの反応として、このメッセージを呼び出すべきだ。', 'SHAppBarMessage(ABM_WINDOWPOSCHANGED, pabd);', 'pabd --- アクティブ化するAppBarを識別するAPPBARDATA構造体へのポインタ。あなたはこのメッセージを送信するときに、cbSizeとhWndメンバーを指定しなければならない。', '常にTRUEを返す。', 'このメッセージはpabdによって指し示される構造体のhWndメンバーが、autohideなAppBarを識別するとき、無視される。', 'SHAppBarMessage|APPBARDATA', '2016-09-21 13:10:28', '2016-09-21 13:10:28', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787963.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABN_FULLSCREENAPP', 'メッセージ', 'フルスクリーンのアプリが開こうとしているか、閉じようとしているときに、AppBarに通知する。この通知は、ABM_NEWメッセージでセットされたアプリ定義のメッセージの形で送信される。', 'ABN_FULLSCREENAPP\r\n    fOpen = (BOOL) lParam;', 'fOpen --- フルスクリーンのアプリが開こうとしているか、閉じようとしているかを指定するフラグ。アプリが開かれようとしているなら、このパラメータはTRUEであり、閉じようとしているならFALSEである。', '戻り値はない。', 'フルスクリーンのアプリが開かれようとしているとき、AppBarはZオーダーの底に落ちなければならない。閉じようとしているとき、AppBarはZオーダーの位置を復元しなければならない。', 'ABM_NEW', '2016-09-21 13:14:13', '2016-09-21 13:14:13', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787965.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABN_POSCHANGED', 'メッセージ', 'AppBarのサイズと位置に影響を与えたかもしれないイベントが起きたとき、AppBarに通知する。イベントは、タスクバーのサイズ、位置、表示状態の変更を含み、さらにスクリーンの同じ端の別のAppBarの追加、除去、サイズ変更をも含む。', 'ABN_POSCHANGED', 'パラメータはない。', '戻り値はない。', 'APpBarは、ABM_QUERYPOSとABM_SETPOSメッセージを送信することにより、この通知メッセージに反応すべきだ。もし位置が変更されたら、AppBarはMoveWindow関数を新しい位置へ移動するために呼び出すべきだ。', 'ABM_QUERYPOS', '2016-09-21 13:17:46', '2016-09-21 13:17:46', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787967.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABN_STATECHANGE', 'メッセージ', 'タスクバーのautohideやalways-on-top状態が変更されたことをAppBarに通知する。すなわち、ユーザーがタスクバーのプロパティシートで「Always on top」か「Auto hide」チェックボックスを選択または選択を解除した。', 'ABN_STATECHANGE', '引数はない。', '戻り値はない。', 'An appbar can use this notification message to set its state to conform to that of the taskbar, if desired.', '', '2016-09-21 13:21:02', '2016-09-21 13:21:02', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787969.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ABN_WINDOWARRANGE', 'メッセージ', 'ユーザーがタスクバーのショートカットメニューから「重ねて表示」「上下に並べて表示」「左右に並べて表示」コマンドを選択したときに、AppBarに通知する。', 'ABN_WINDOWARRANGE\r\n    fBeginning = (BOOL) lParam;', 'fBeginning --- 操作が始まっており、かつウィンドウがまだ動いていないときに、このパラメータはTRUEである。操作が完了したときにこのぱれめーたはFALSEである。', '戻り値はない。', 'システムはこの通知メッセージを２度送信する。最初はlParamをTRUEにセットして、二回目はlParamをFALSEにセットして送信する。最初の通知はウィンドウが「重ねて表示」か「並べて表示」される前に送信される。そして二回目は、「重ねて表示」か「並べて表示」の操作が完了したときに送信される。', '', '2016-09-21 13:25:56', '2016-09-21 13:25:56', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb787971.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('About Messages and Message Queues', '', 'MS-DOSベースのアプリとは違って、Windowsベースのアプリはイベント駆動型である。それらは、入力を取得するためにCランタイムライブラリ呼び出しのような、明示的な関数呼び出しをしない。代わりに入力が渡されるまでシステムを待つ。\r\n\r\nシステムはアプリに対するすべての入力をアプリの様々なウィンドウに渡す。各ウィンドウは、ウィンドウプロシージャと呼ばれる関数を持ち、システムは、ウィンドウに対する入力があったときはいつでもそれを呼び出す。詳しくはウィンドウプロシージャを参照せよ。\r\n\r\nもしトップレベルのウィンドウが数秒以上メッセージへの反応を停止したら、システムはそのウィンドウを反応なしと見なす。この場合、システムはウィンドウを隠し、それを同じZオーダー、位置、サイズ、視覚属性を持つ「ゴーストウィンドウ」で置き換える。これはユーザーがそれを動かし、サイズを変更し、閉じることさえ可能にする。しかしながら、アプリが反応しないために、可能なアクションは限られている。デバッガーモードでは、システムはゴーストウィンドウを生成しない。', '', '', '', '', 'Window Procedure', '2016-09-04 00:06:37', '2016-09-04 00:06:37', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', '', 'Windows Messages'),
('About Supplementary Characters', '', '補助文字とは、BMPを超える場所に位置する文字と、UTF-16コードの値のサロゲートである。UTF-16では、サロゲートペア（surrogate pair）は、１個の補助文字を表現するのに必要である。最初の（上位の）サロゲートは、U+D800～U+DBFFの範囲の16ビットコードの値である。二番目の（下位の）サロゲートは、U+DC00～U+DFFFの範囲の16ビットコードの値である。サロゲートのメカニズムを使えば、UTF-16は1,114,112の潜在的なUnicode文字をサポートできる。補助文字、サロゲート、そしてサロゲートペアに関する詳細は、「Unicode標準」を参照せよ。\r\n\r\n注意：Windows 2000は、補助文字の基本的な入出力と並べ替えのサポートを導入した。しかしながら、すべてのシステムコンポーネントは、補助文字に対して互換性があるわけではない。\r\n\r\nOSは、補助文字を次のようにサポートする。\r\n\r\n * OpenTypeフォントcmapテーブルのフォーマット12は、直接4バイト文字コードをサポートする。詳しくは、OpenTypeフォント仕様を参照せよ。\r\n * Windows は、サロゲートを有効にしたIMEをサポートする。\r\n * Windows GDI APIは、フォントにおいてフォーマット12 cmapテーブルをサポートするので、サロゲートも正しく表示される。\r\n * Uniscribe APIは補助文字をサポートする。\r\n * エディットとリッチエディットを含むWindowsコントロールは、補助文字をサポートする。\r\n * HTMLエンジンは、表示と（Outlook Expressを通じて）編集とフォームの投稿のために補助文字を含むHTMLページをサポートする。\r\n * オペレーティングシステムの並べ替え（sorting）テーブルは、補助文字をサポートする。', '', '', '', '', '', '2016-09-20 11:37:01', '2016-09-20 11:37:01', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('About Unicode and Character Sets', '', '世界の文字ベースのデータは、Unicodeと伝統的な文字セットの両方を使って開発された。そのため、Windowsは文字ベースのデータをアプリがオリジナルの文字セットからUnicodeまたは別の伝統的な文字セットに変換するのを助ける文字セット関数たちを提供する。これらの文字セット関数たちは、他のオペレーティングシステムへ転送したり、使ったりするために、アプリが文字ベースのデータを作成するのを助ける（Unicodeをサポートしないオペレーティングシステムを含む）。\r\n\r\nUnicodeの詳細は、この概要のスコープを超えるので、Unicode標準を参照せよ。\r\n\r\nこのセクションは以下のトピックスをカバーする。\r\n\r\n * 文字セット\r\n * エンドユーザー定義とプライベート使用領域文字\r\n * Windows APIにおけるUnicode', '', '', '', '', 'Character Sets|End-User-Defined and Private Use Area Characters|Unicode in the Windows API', '2016-09-18 03:42:08', '2016-09-18 03:42:08', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317711.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Accessing the HIMC', '', 'IME が入力コンテキストにアクセスするとき、IME は、入力コンテキストのポインタを取得するためにImmLockIMC 関数を呼ぶ。ImmLockIMC 関数は、IMM のロックカウントを１つ増加させ、ImmUnlockIMC 関数は、IMM のロックカウントを１つ減少させる。', '', '', '', '', 'ImmLockIMC|ImmUnlockIMC', '2016-09-10 10:29:05', '2016-09-10 10:29:05', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Accessing the HIMCC', '', 'IME が入力コンテキストのコンポーネントにアクセスするとき、IME は IMCC のポインタを取得するためにImmLockIMCC を呼ぶ必要がある。ImmLockIMCC 関数は IMCC に対するロックカウントを１つ増加させ、一方 ImmUnlockIMC 関数は IMCC に対する IMM ロックカウントを１つ減少させる。ImmReSizeIMCC 関数は、IMCC のサイズを入力引数で指定したサイズへ変更できる。\r\n\r\n時として、IME は、入力コンテキストの新しいコンポーネントを作成する必要がある。そのため IME は、ImmCreateIMCC 関数を呼ぶことができる。入力コンテキスト中の新しく作成したコンポーネントを破棄するために、IME は ImmDestroyIMCC 関数を呼ぶことができる。', '', '', '', '', 'ImmLockIMCC|ImmUnlockIMCC|ImmCreateIMCC|ImmDestroyIMCC', '2016-09-10 10:30:26', '2016-09-10 10:30:26', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ActivateKeyboardLayout', '関数', '呼び出し側スレッドまたは現在のプロセスに対して入力ロケール識別子（ 旧名キーボードレイアウトハンドル）を設定します。入力ロケール識別子は、キーボードの物理レイアウトだけでなく、ロケールも指定します。', 'HKL ActivateKeyboardLayout(\r\n  HKL hkl,     // 入力ロケール識別子\r\n  UINT Flags   // 入力ロケール識別子フラグ\r\n);', 'hkl --- アクティブ化する入力ロケール識別子を指定します。\r\n\r\nWindows 95/98：このパラメータは、LoadKeyboardLayout 関数か GetKeyboardLayoutList 関数で取得するか、または次表のいずれかの値を指定することができます。\r\n\r\nWindows NT：入力ロケール識別子は、LoadKeyboardLayout 関数であらかじめロードされていなければなりません。このパラメータには、キーボードレイアウトのハンドル、または次の値のいずれかを指定してください。\r\n\r\n[table:ActivateKeyboardLayout_Table1]\r\n///\r\nFlags --- 入力ロケール識別子をどのようにアクティブ化するかを指定します。このパラメータには次の値のいずれかを指定することができます。\r\n\r\n[table:ActivateKeyboardLayout_Table2]', 'Windows NT 3.51 以前：戻り値は BOOL 型です。関数が成功すると、0 以外の値が返ります。関数が失敗すると、0 が返ります。\r\n\r\nWindows 95/98 および Windows NT 4.0 以降：戻り値は HKL 型です。関数が成功すると、以前の入力ロケール識別子（ 旧名キーボードレイアウトハンドル）が返ります。関数が失敗すると、0 が返ります。\r\n拡張エラー情報を取得するには、GetLastError 関数を使います。', 'この関数はキーボードレイアウトの制限を受けません。hkl パラメータは実際には入力ロケール識別子です。入力ロケール識別子には音声入力コンバータ、IME、またはその他のあらゆる入力形式が含まれており、キーボードレイアウトよりも広い概念を持ちます。入力ロケール識別子は、一度に複数ロードすることができますが、アクティブ化できるのは 1 つだけです。複数の入力ロケール識別子をロードすると、切り替えを迅速に行うことができます。\r\n\r\nWindows 95/98：アプリケーションは、上位ワードを 0 に、下位ワードをロケール識別子にセットして、有効な入力ロケール識別子を作成することができます。入力ロケール識別子を使うと、物理レイアウトに影響を与えずに入力言語を変更することができます。\r\n\r\nロケールごとに複数の入力メソッドエディタ（IME）が使えるときは、上位ワード（ デバイスハンドル）が 0 である入力ロケール識別子を渡すと、そのロケールに属する IME のリストの最初にある IME がアクティブ化されます。', 'LoadKeyboardLayout|GetKeyboardLayoutName|UnloadKeyboardLayout', '2016-09-11 08:12:30', '2016-09-11 08:12:30', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc430248.aspx', 'Microsoft', '', '', '', ''),
('APPBARDATA', '構造体', 'システムのAppBarメッセージに関する情報を含む。', 'typedef struct {\r\n  DWORD  cbSize;\r\n  HWND   hWnd;\r\n  UINT   uCallbackMessage;\r\n  UINT   uEdge;\r\n  RECT   rc;\r\n  LPARAM lParam;\r\n} APPBARDATA, *PAPPBARDATA;', 'cbSize --- この構造体のバイトサイズ。\r\n///\r\nhWnd --- AppBarウィンドウのハンドル。すべてのメッセージがこのメンバーを使うわけではない。個別のメッセージを参照せよ。\r\n///\r\nuCallbackMessage --- アプリ定義のメッセージ識別子。アプリは通知メッセージに指定した識別子を使い、hWndメンバーで識別されたAppBarに通知メッセージを送信する。このメンバーはABM_NEWメッセージを送信するときに使われる。\r\n///\r\nuEdge --- スクリーンの端を指定する値。メンバーは以下のいずれかのメッセージを送信するときに使われる。\r\n\r\n * ABM_GETAUTOHIDEBAR\r\n * ABM_SETAUTOHIDEBAR\r\n * ABM_GETAUTOHIDEBAREX\r\n * ABM_SETAUTOHIDEBAREX\r\n * ABM_QUERYPOS\r\n * ABM_SETPOS\r\n\r\nこのメンバーは次のいずれかの値である。\r\n\r\n[table:APPBARDATA_Table1]\r\n///\r\nrc --- メッセージによって異なるRECT構造体。\r\n\r\n * ABM_GETTASKBARPOS、ABM_QUERYPOS、ABM_SETPOS: AppBarもしくはWindowsタスクバーのスクリーン座標系のバウンディング長方形。\r\n * ABM_GETAUTOHIDEBAREX、ABM_SETAUTOHIDEBAREX: 操作が行われるモニター。この情報はGetMonitorInfo関数を通じて取得できる。\r\n///\r\nlParam --- メッセージに依存する値。このメンバーは次のメッセージで使われる。\r\n\r\n * ABM_SETAUTOHIDEBAR\r\n * ABM_SETAUTOHIDEBAREX\r\n * ABM_SETSTATE\r\n\r\n詳しくはそれぞれのメッセージを参照せよ。', '', '', '', '2016-09-21 13:34:01', '2016-09-21 13:34:01', '<shellapi.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb773184.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Application-Created Input Context', '', 'アプリのウィンドウは、未確定のコンポジション文字列を含む IME のあらゆる状態を管理するために、ウィンドウハンドルを入力コンテキストに関連付けできる。一度、アプリが入力コンテキストをウィンドウハンドルに関連付けると、システムはウィンドウがアクティブになったときに自動的にコンテキストを選択する。このように、アプリは、フォーカスの取得・解放処理における複雑さから解放されている。', '', '', '', '', 'IME Input Context|Default Input Context', '2016-09-10 10:26:30', '2016-09-10 10:26:30', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Application-Defined Messages', '', 'アプリは、自分のウィンドウで使うため、あるいは他のプロセスと通信するためにメッセージを作成できる。アプリがアプリ所有のメッセージを作成したら、それらを受け取るウィンドウプロシージャはメッセージを解釈し、適切な処理を提供しなければならない。\r\n\r\nメッセージ識別子の値は次のように使われる。\r\n\r\n * システムはシステム定義のメッセージについてメッセージ識別子の値を0x0000から0x03FF（WM_USER - 1）の間を予約している。アプリはこれらの値をプライベートなメッセージとして使うことができない。\r\n * 0x0400（WM_USER）から0x7FFFまでの範囲の値は、プライベートなウィンドウクラスのメッセージ識別子として利用可能である。\r\n * アプリがバージョン4.0をマークしていれば、0x8000（WM_APP）から0xBFFFの範囲のメッセージ識別子の値をプライベートなメッセージとして使用できる。\r\n * システムはアプリがメッセージ登録のため、RegisterWindowMessage関数を呼び出すと0xC000から0xFFFFまでの範囲のメッセージ識別子を返す。この関数が返したメッセージ識別子は、システム全体で一意（unique）であることが保証される。この関数の使用は、他のアプリが他の目的で同じメッセージを使用したときに起こる競合を回避する。', '', '', '', '', '', '2016-09-04 00:41:05', '2016-09-04 00:41:05', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'System-Defined Messages', 'Message Routing'),
('Broadcasting Messages', '', 'それぞれのメッセージは、メッセージ識別子と２つのパラメータ、wParamとlParamからなる。メッセージ識別子は、メッセージの目的を指定する一意な値だ。パラメータたちは、メッセージ特有の追加的な情報を提供する。（訳略）\r\n\r\nメッセージ放映は、単純にシステムにおける複数の受取人にメッセージを送信することである。アプリからメッセージを放映するには、メッセージの受取人を指定してBroadcastSystemMessage関数を使う。個別の受取人を指定するよりも、1個以上の受取人のタイプを指定しなければならない。これらのタイプは、アプリたち、インストール可能なドライバーたち、ネットワークドライバーたち、そしてシステムレベルのデバイスドライバーたちである。システムは、それぞれの指定されたタイプのすべてのメンバーたちへ放映メッセージを送信する。\r\n\r\nシステムはたいてい、システムレベルのデバイスドライバーたちや関連するコンポーネントたちの内部で行われる変更への反応として、メッセージたちを放映する。ドライバーや関連するコンポーネントは、その変更を伝えるためにメッセージをアプリたちやその他のコンポーネントたちにメッセージを放映する。（訳略）\r\n\r\nシステムは次の順番でメッセージを放映する：システムレベルのデバイスドライバー、ネットワークドライバー、インストール可能なドライバー、そしてアプリ。これは、システムレベルのデバイスドライバーが受取人として選ばれれば、それは最初にメッセージに反応する機会を得ることを意味する。与えられた受取人タイプの範囲で、他のドライバーよりも前に受け取るドライバーはないことを保証される。これは、特定のドライバーに対するメッセージは、大局的に一意なメッセージ識別子を持たねばならず、他のドライバーはそれを意図せず処理することはできないことを意味する。\r\n\r\nあなたは、HWND_BROADCASTを指定したSendMessage、SendMessageCallback、SendMessageTimeout、SendNotifyMessage関数でメッセージをすべてのトップレベルのウィンドウにメッセージを送信できる。\r\n\r\nアプリは、アプリのトップレベルのウィンドウたちのウィンドウプロシージャを通じてメッセージを受け取る。メッセージは子ウィンドウには送信されない。サービスはウィンドウプロシージャやサービスコントロールハンドラーを通じてメッセージを受け取ることができる。\r\n\r\nシステムレベルのデバイスドライバーは、システムメッセージを放映するために関連するシステムレベルの関数を使う。', '', '', '', '', '', '2016-09-04 09:30:16', '2016-09-04 09:30:16', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Message Deadlocks', 'Query Messages'),
('CANDIDATEFORM', '構造体', '候補ウィンドウの位置情報を含みます。', 'typedef struct {\r\n  DWORD dwIndex;\r\n  DWORD dwStyle;\r\n  POINT ptCurrentPos;\r\n  RECT  rcArea;\r\n} CANDIDATEFORM;', 'dwIndex --- 候補リスト識別子である符号なしの長整数値です。これは0から31までの値です。\r\n///\r\ndwStyle --- 位置スタイルである符号なしの長整数値です。これは次のうち1個の値です。\r\n\r\n[table:CANDIDATEFORM_Table1]\r\n///\r\nptCurrentPos --- dwStyleの値に依存する、候補ウィンドウかキャレット位置の左上端の座標を含むPOINT構造体です。\r\n///\r\nrcArea --- 排除領域の左上端と右下端の座標を含むRECT構造体です。', '', '', '', '2016-08-28 07:13:04', '2016-08-28 07:13:04', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741223.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('CANDIDATEINFO', '構造体', '候補情報のヘッダーである。この構造体は、最大で 32 個の候補リストを所持でき、これらの候補リストは、同じメモリーブロックの中にないといけない。', 'typedef struct {\r\n    DWORD dwSize;\r\n    DWORD dwCount;\r\n    DWORD dwOffset[32];\r\n    DWORD dwPrivateSize;\r\n    DWORD dwPrivateOffset;\r\n} CANDIDATEINFO;', 'dwSize --- このメモリーブロックのサイズ。\r\n///\r\ndwCount --- このメモリーブロックに含まれる候補リストの個数。\r\n///\r\ndwOffset[32] --- 中身は、この構造体の開始位置からのオフセットであり、各オフセットは、それぞれの候補リストの開始位置を指定する。\r\n///\r\ndwPrivateSize --- このメモリーブロックのプライベート領域のサイズ。\r\n///\r\ndwPrivateOffset --- この構造体の開始位置からプライベート領域の開始位置へのオフセット。', '', '', 'CANDIDATELIST', '2016-09-10 04:09:24', '2016-09-10 04:09:24', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('CANDIDATELIST', '構造体', '候補リストの情報を含みます。', 'typedef struct {\r\n  DWORD dwSize;\r\n  DWORD dwStyle;\r\n  DWORD dwCount;\r\n  DWORD dwSelection;\r\n  DWORD dwPageStart;\r\n  DWORD dwPageSize;\r\n  DWORD dwOffset[1];\r\n} CANDIDATELIST;', 'dwSize --- 構造体とオフセット配列とすべての候補文字列たちのバイトサイズを符号なしの長整数型。\r\n///\r\ndwStyle --- 候補スタイルの値達を含む符号なしの長整数型。これは1個以上の次の値です。\r\n\r\n[table:CANDIDATELIST_Table1]\r\n///\r\ndwCount --- 候補文字列たちの個数を持つ符号なしの長整数値です。\r\n///\r\ndwSelection --- 選択された候補文字列のインデックスを含む符号なしの長整数値です。\r\n/// \r\ndwPageStart --- 候補ウィンドウの最初の候補文字列のインデックスを含む長整数値です。これはユーザーがPageUpやPageDownキーを押すと変わります。\r\n///\r\ndwPageSize --- 候補ウィンドウで1ページに表示される候補文字列の個数を表す符号なしの長整数値です。ユーザーはPageUpやPageDownキーなどのIME定義のキーにより次のページに移動できます。もしこの数がゼロなら、アプリは適切な値をアプリ自身が定義できます。\r\n///\r\ndwOffset --- この構造体の先頭から最初の候補文字列の開始位置までのオフセットを表す符号なしの長整数値の配列のアドレス。このメンバーの直後に続きのオフセットたちが続き、32ビットのオフセット配列をなします。', '', '', 'CANDIDATEINFO', '2016-08-28 07:28:13', '2016-08-28 07:28:13', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741224.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Character Messages', '', 'キーストロークメッセージは、キーストロークに関するたくさんの情報を提供するが、文字のキーストロークに対する文字コードは提供しない。文字コードを取得するためには、アプリは、TranslateMessage関数をそのスレッドメッセージループ内で含まなければならない。TranslateMessageはWM_KEYDOWNやWM_SYSKEYDOWNメッセージをキーボードレイアウトに渡す。レイアウトは、メッセージの仮想キーコードをテストして、もし文字キーに対応していれば、同等の文字コードを提供する（SHIFT、CAPS LOCKキーの状態を考慮する）。それから、文字コードを含む文字メッセージを生成し、メッセージキューの先頭にメッセージを置く。メッセージキューの次の繰り返しでは、文字メッセージはキューから取り除かれ、適切なウィンドウプロシージャにメッセージを配送する。\r\n\r\nこのセクションは、次のトピックスをカバーする。\r\n\r\n * 非システム文字メッセージ\r\n * デッド文字メッセージ', '', '', '', '', '', '2016-09-14 10:55:29', '2016-09-14 10:55:29', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Character Sets', '', '文字セットは、文字コードの値を識別するための文字の写像である。現在最もよく使われる文字セットは文字エンコーディングの世界標準のUnicodeである。内部的にはWindowsアプリはUnicodeのUTF-16実装を使う。UTF-16においてはほとんどの文字は2バイトコードで識別される。あまり使われない補助文字は、2バイトコードの対である「サロゲート（surrogate）ペア」として表現される。詳しくは、「サロゲートと補助文字」を参照せよ。\r\n\r\nいくつかのWindowsアプリは、Windows Me/98/95でネイティブな古い文字セットを扱わなければならない。Windowsコードページは、アプリがそれらの文字セットを扱うのを許可する。それらの文字セットは以下のように分類できる。\r\n\r\n * シングル文字セット（SBCS）。SBCSでは、それぞれの文字は1バイトの幅で識別される。\r\n * マルチバイト文字セット。特にダブルバイト文字セット（DBCS）。マルチバイト文字セットは、アジアの言語において膨大な数の文字を表現する手段を提供する。\r\n\r\n詳しくは、以下のトピックスを参照せよ。\r\n\r\n * コードページ\r\n * ダブルバイト文字セット\r\n * シングルバイト文字セット\r\n * サロゲートと補助文字\r\n * Unicode', '', '', '', '', 'Code Pages|Double-byte Character Sets|Single-byte Character Sets|Surrogates and Supplementary Characters|Unicode', '2016-09-18 03:49:25', '2016-09-18 03:49:25', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317743.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('CLIENTIMC', '構造体', 'imm32.dll 側の入力コンテキスト情報を表す構造体です。', 'typedef struct tagCLIENTIMC\r\n{\r\n    HANDLE hInputContext;   /* LocalAlloc\'ed LHND */\r\n    LONG cLockObj;\r\n    DWORD dwFlags;\r\n    DWORD dwCompatFlags;\r\n    RTL_CRITICAL_SECTION cs;\r\n    UINT uCodePage;\r\n    HKL hKL;\r\n    BOOL bCtfIme;\r\n} CLIENTIMC, *PCLIENTIMC, NEAR *NPCLIENTIMC, FAR *LPCLIENTIMC;', 'hInputContext --- LocalAlloc 関数によって割り当てられた INPUTCONTEXT 構造体へのハンドル。\r\n///\r\ncLockObj --- ロックカウントです。\r\n///\r\ndwFlags --- CLIENTIMC_* フラグを指定します。\r\n///\r\ndwCompatFlags --- (不明)\r\n///\r\ncs --- これは排他制御のためのクリティカルセクションです。\r\n///\r\nuCodePage --- コード ページを表す整数値。\r\n///\r\nhKL --- キーボード レイアウトのハンドル。\r\n///\r\nbCtfIme --- (不明)', '', '', 'ImmLockClientImc|ImmUnlockClientImc|INPUTCONTEXT', '2024-08-14 00:21:15', '2024-08-14 00:21:15', '<imm32_undoc.h>', '', 'katahiromzによる分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('Code Pages', '', '現在書かれているほとんどのアプリは、文字データを主にUTF-16を使ったUnicodeとして扱う。しかしながら、多くのレガシーなアプリはコードページをもとにした文字セットを使い続けている。新しいアプリでもコードページを扱う必要がある。それは次の理由のためである。\r\n\r\n * レガシーなアプリと通信するため\r\n * Unicodeをサポートしていない古いメールとニュースサーバーと通信するため\r\n * UnicodeをサポートしていないWindowsコンソールと通信するため\r\n\r\n注意：新しいWindowsアプリは、様々なコードページの非一貫性を避けるために、またローカリゼーションの簡単さのためにUnicodeを使うべきである。\r\n\r\n各コードページは、コードページ識別子で表現される。例えば、1252は、Unicodeと文字セットAPI関数たちで処理される。サポートされたコードページ識別子のリストについては、コードページ識別子を三奏せよ。Microsoft Go Global Developer Centerにおいてコードページを参照すれば、多くのコードページのすべての説明が手に入る。\r\n\r\nWindowsコードページは、ANSIコードページと呼ばれ、国際的な文字を表現するための、127を超えた非ASCIIの値のためのコードページである。これらのコードページは、Windows Meにおいてネイティブに使用され、また、Windows NTとそれ以降で利用可能である。\r\n\r\n注意：初めは、Windowsコードページ1252は、ANSI創案をもとに下、英語やその他の西ヨーロッパで広く使われるコードページだった。その創案は最終的にISO 8859-1になったが、Windowsコードページ1252は、標準が定まる前に実装されたので、ISO-8859-1とは正確には同じではない。\r\n\r\n多くのWindows API関数は\"A\" (ANSI)と\"W\" (ワイド、Unicode)バージョンを持つ。\"A\"バージョンは、Windowsコードページに基づくテキストを扱う。\"W\"バージョンはUnicodeテキストを扱う。See Windows Data Types for Strings and Conventions for Function Prototypes.\r\n\r\nWindowsコードページは、しばしばアクティブなコードページとかシステムのアクティブなコードページとして参照される。Windows オペレーティングシステムは、常に１つの現在のアクティブなWindowsコードページを持つ。すべてのANSIバージョンのAPI関数は現在のアクティブなコードページを使う。\r\n\r\nOEMコードページは、線の描画や句読点文字を表す非ASCIIの値に対するコードページである。それらのコードページは、最初はMS-DOSで使われ、まだコンソールアプリでも使われている。それらはFAT12、FAT16、FAT32ファイルシステムで非拡張ファイル名としても使われている（「ファイル名で使われる文字セット」を参照）。英語に対する通常のOEMコードページはコードページ437である。\r\n\r\nWindowsコードページとOEMコードページの両方で、0x00から0x7Fまでのコードは、7ビットのASCII文字セットである。0x00から0x19までと0x7Fは常に、標準化された制御文字を表し、0x20から0x7Eまでは標準化された表示可能な文字を表す。残りの0x80から0xFFまでのコードの文字は、文字セットによって変わる。それぞれの文字セットは異なる特殊文字を含み、言語や言語のグループでたいていカスタマイズされる。Windowsコードページ1252とOEMコードページ437は、一般に合衆国で使われる。\r\n\r\nさらにWindowsとOEMコードページでは、あなたのアプリは非ネイティブなコードページを使用できる。その例はEBCDICやMacintoshコードページである。\r\n\r\nUTF-7とUTF-8のエンコーディングは、コードページとして実装されている。他のコードと同じように、各ページは数の識別子として知られていて、同じUnicodeと文字セット関数たちの多くで扱える。\r\n\r\nコードページは、シングルバイト文字セット（SBCS）ページとダブルバイト文字セット（DBCS）ページのいずれかである。SBCSページでは、各バイトは直接1文字を表し、正確に区別された256文字を表すことができる（制御文字、通常の文字、数字、句読点、記号などを含む）。DBCSコードページは、たいてい日本語や中国語などの言語で使われる。そのようなコードページでは、いくつかの文字は特定のバイト値において２バイトのエンコーディングを持つ。そのバイト値は、常に127以上であり、リードバイト（lead byte）と呼ばれる。リードバイトは、トレイルバイト（trail byte）と連結されて、１つの文字のみを表す。\r\n\r\nいくつかのレガシーなプロトコルは、SBCSとDBCSコードページの使用を必要とする。それぞれのSBCS/DBCSコードページは異なる文字をサポートするが、Unicodeで提供されるすべての文字をサポートしたコードページはない。それぞれのSBCS/DBCSコードページは、異なるエンコーディングの異なるサブセットをサポートする。\r\n\r\n注意：SBCSやDBCSコードページから別のコードページへ変換したデータは壊れやすい。なぜなら、異なるコードページの同じデータは、別の文字としてエンコードされるからである。UnicodeからSBCSやDBCSへ変換されたデータは、データロスの可能性がある。なぜなら、与えられたコードページでは、Unicodeデータに固有なデータをすべて表現できないからである。\r\n\r\nさらにSBCSやDBCSコードページについて、あなたのアプリではマルチバイト文字セットのコードページ52936、54936、51949、5022xが利用可能である。それらはDBCSのアプローチに似ている。マルチバイト文字セットのコードページは、いくつかの文字において２バイトのエンコーディングを超える。UTF-7やUTF-8は、7ビットまたは8ビットのバイトたちに基づいてUnicodeをエンコードする似たようなアプローチを使う。詳しくはUnicodeを参照せよ。\r\n\r\nいくつかのUniocdeと文字セット関数たちは、アプリがコードページを扱うことを許可する。アプリは、コードページに関する情報を取得するためにGetCPInfoやGetCPInfoEx関数を使うことができる。この情報は、文字列変換に失敗したときのデフォルトの文字を含む。\r\n\r\nアプリは、WindowsコードページとUnicode文字列の間で変換するのにMultiByteToWideCharとWideCharToMultiByte関数を使うことができる。MultiByteといっても、それらの関数はSBCS、DBCS、マルチバイト文字セットのコードページで同じように機能する。\r\n\r\n注意：WideCharToMultiByteは、もし与えられたコードページがUnicode文字列のすべての文字を表現できなければ、データを失うことがある。\r\n\r\nあなたのアプリは、標準ランタイムライブラリー関数たちを使って、WindowsコードページとOEMコードページの間で変換することができる。しかしながら、それらの関数の使用は、データを失う危険性がある。それぞれのコードページで表現する文字が正確にマッチしないことがあるからだ。\r\n\r\nあなたのアプリは、GetACP関数を呼ぶことができる。この関数は、現在のWindows (ANSI) コードページの識別子を取得する。', '', '', '', '', 'Unicode|Conventions for Function Prototypes', '2016-09-18 04:30:08', '2016-09-18 04:30:08', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317752.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Components of the UI Window', '', 'UI ウィンドウは、現在の入力コンテキストを参照することにより、コンポジションウィンドウや状態ウィンドウを登録・表示できる。UI ウィンドウのコンポーネントたちのクラススタイルは、CS_IME ビットを含んでいなければならない。UI ウィンドウのウィンドウインスタンスは、現在の入力コンテキストからコンポジション文字列、フォント、そして位置の情報を得る。\r\n\r\nアプリのウィンドウがフォーカスを得たとき、システムは、入力コンテキストをこのウィンドウに与え、現在の入力コンテキストを UI ウィンドウにセットする。システムはそのとき、WM_IME_SETCONTEXT メッセージに入力コンテキストをつけて、アプリへ送信する。すると、アプリはこのメッセージを UI ウィンドウに渡す。もし、現在の入力コンテキストが他の入力コンテキストに入れ替わっていたら、UI ウィンドウは、コンポジションウィンドウを再描画すべきだ。現在の入力コンテキストは変更されたときはいつでも、UI ウィンドウは正しいコンポジションウィンドウを表示する。したがって、IME の状態は保証される。\r\n\r\nUI ウィンドウは、その状態やコンポジション文字列、候補リストを表示するために、子ウィンドウやポップアップウィンドウを作成できる。しかしながら、それらのウィンドウは、UI ウィンドウによって所有される必要があり、また、無効な (disabled) ウィンドウとして作成される必要がある。IME によって作成されたどんなウィンドウも、フォーカスを得てはならない。', '', '', '', '', 'WM_IME_SETCONTEXT', '2016-09-10 10:21:32', '2016-09-10 10:21:32', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Composition String', '', 'コンポジション文字列とは、コンポジションウィンドウにおける現在のテキストである。これはIMEが文字列を確定するためのテキストである。それぞれのコンポジション文字列は、1個以上の「文節」からなる。文節とは、IMEが結果文字列に変換できる最小の文字の組み合わせである。コンポジション文字列を取得・設定するためには、アプリはそれぞれImmGetCompositionStringとImmSetCompositionString関数を呼ぶ。\r\n\r\nユーザーがコンポジションウィンドウでテキストを入力したら、コンポジション文字列の状態を追跡する。この状態は属性情報、文節情報、タイプ情報、カーソル位置を含んでいる。アプリはコンポジション状態をImmGetCompositionString 関数で取得できる。\r\n\r\n属性情報は、コンポジション文字列における文字の状態を指定する8ビットの値の配列として格納される。ある1文節のすべての文字は同じ属性を持たなければならない。配列は1文字につき1つの値を含む。DBCSでは各1バイトが1個の値を持ち、Unicodeでは各Unicode文字が1個の値を持つ。配列中のそれぞれの値については、ビット0～3までが次の値の組み合わせである。\r\n\r\n[table:Composition String_Table1]\r\n\r\nその他の値は予約済みである。日本語ではATTR_INPUT属性を持つ未変換の文字はひらがな、カタカナ、英数字である。韓国語では、この属性はIMEが変換していないハングル文字を表す。繁体字と簡体字では、それぞれのIMEがある範囲で文字を制限する。\r\n\r\nコンポジション文字列状態に含まれる文節情報は、コンポジション文字列における文節の位置を表す32ビットの値の配列である。その配列は、各文節に対して1つの値を含む。最後の値は、文字列全部の長さを表す。この配列における各値は、文字列の最初から文節までのバイト単位のオフセットを指定する。最初の文節は常に文字列の開始であるから、最初の値は常にゼロである。（訳略）\r\n\r\nコンポジション文字列状態に含まれるタイプ情報は、ユーザーがキーボードから入力したものを表すヌル終端の文字列である。\r\n\r\nコンポジション文字列状態に含まれるカーソル位置は、コンポジション文字列における相対的なカーソル位置を表す値である。この値は、文字列の最初からの文字単位のオフセットである。もしこの値がゼロなら、カーソルは最初の文字列の直前にある。もしこの値が文字列の長さに等しければ、カーソルは最後の文字の直後にある。\r\n\r\nアプリは、ImmSetCompositionString 関数を使って、コンポジション文字列やコンポジション状態の要素をセットできる。それらの変更に基づいてコンポジションウィンドウの見た目を変えることを確認するために、この関数はアプリに通知メッセージをウィンドウに送信することを許可する。コンポジション状態の要素の組み合わせをセットしたアプリは、コンポジションウィンドウに対して通知メッセージが1つだけ生成されるように、通知を無効にすることができる（訳OK？）。\r\n\r\n最後に、エディットコントロールは、IMEによるコンポジション文字列の処理を変更するために二つのメッセージをサポートする。詳しくはEM_GETIMESTATUSとEM_SETIMESTATUSを参照せよ。エディットコントロールについての詳細はエディットコントロールを参照せよ。', '', '', '', '', 'ImmGetCompositionString|ImmSetCompositionString|EM_GETIMESTATUS|EM_SETIMESTATUS', '2016-09-03 03:51:05', '2016-09-03 03:51:05', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317765.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('COMPOSITIONFORM', '構造体', 'コンポジションウィンドウの位置情報を含みます。', 'typedef struct {\r\n  DWORD dwStyle;\r\n  POINT ptCurrentPos;\r\n  RECT  rcArea;\r\n} COMPOSITIONFORM;', 'dwStyle --- 位置スタイルを含む符号なしの長整数値であり、以下のうちどれかの値です。\r\n\r\n[table:COMPOSITIONFORM_Table1]\r\n///\r\nptCurrentPos --- コンポジションウィンドウの左上端の座標を含むPOINT構造体です。\r\n///\r\nrcArea --- コンポジションウィンドウの左上端と右下端の座標を含むRECT構造体です。', '', '', 'COMPOSITIONSTRING', '2016-08-28 07:33:39', '2016-08-28 07:33:39', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741225.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('COMPOSITIONSTRING', '構造体', 'コンポジション文字列の情報を持つ。変換の間、IME は変換情報をこ\r\nの構造体へ格納する。', 'typedef struct {\r\n    DWORD dwSize;\r\n    DWORD dwCompReadAttrLen;\r\n    DWORD dwCompReadAttrOffset;\r\n    DWORD dwCompReadClsLen;\r\n    DWORD dwCompReadClsOffset;\r\n    DWORD dwCompReadStrLen;\r\n    DWORD dwCompReadStrOffset;\r\n    DWORD dwCompAttrLen;\r\n    DWORD dwCompAttrOffset;\r\n    DWORD dwCompClsLen;\r\n    DWORD dwCompClsOffset;\r\n    DWORD dwCompStrLen;\r\n    DWORD dwCompStrOffset;\r\n    DWORD dwCursorPos;\r\n    DWORD dwDeltaStart;\r\n    DWORD dwResultReadClsLen;\r\n    DWORD dwResultReadClsOffset;\r\n    DWORD dwResultReadStrLen;\r\n    DWORD dwResultReadStrOffset;\r\n    DWORD dwResultClsLen;\r\n    DWORD dwResultClsOffset;\r\n    DWORD dwResultStrLen;\r\n    DWORD dwResultStrOffset;\r\n    DWORD dwPrivateSize;\r\n    DWORD dwPrivateOffset;\r\n} COMPOSITIONSTRING;', 'dwSize --- この構造体のメモリーブロックのサイズ。\r\n///\r\ndwCompReadAttrLen --- コンポジション文字列の読みの文字列の属性情報の長さ。\r\n///\r\ndwCompReadAttrOffset --- この構造体の開始位置から属性へのオフセット。属性情報はここに格納される。\r\n///\r\ndwCompReadClsLen --- コンポジション文字列の読みの文字列の文節情報の長さ。\r\n///\r\ndwCompReadClsOffset --- この構造体の開始位置から文節へのオフセット。文節情報はここに格納される。\r\n///\r\ndwCompReadStrLen --- コンポジション文字列の読みの文字列の長さ。\r\n///\r\ndwCompReadStrOffset --- この構造体の開始位置から読みの文字列へのオフセット。コンポジション文字列の読みの文字列は、ここに格納される。\r\n///\r\ndwCompAttrLen --- コンポジション文字列の属性情報の長さ。\r\n///\r\ndwCompAttrOffset --- この構造体の開始位置から属性へのオフセット。属性情報はここに格納される。\r\n///\r\ndwCompClsLen --- コンポジション文字列の文節情報の長さ。\r\n///\r\ndwCompClsOffset --- この構造体の開始位置から文節へのオフセット。文節情報はここに格納される。\r\n///\r\ndwCompStrLen --- コンポジション文字列の長さ。\r\n///\r\ndwCompStrOffset --- この構造体の開始位置からコンポジション文字列へのオフセット。コンポジション文字列はここに格納される。\r\n///\r\ndwCursorPos --- コンポジション文字列におけるカーソルの位置。\r\n///\r\ndwDeltaStart --- コンポジション文字列における変更部分の開始位置。もし、コンポジション文字列が以前の状態から変更されていれば、その変更点の最初の位置がここに格納される。\r\n///\r\ndwResultReadClsLen --- 結果文字列の読みの文字列の文節情報の長さ。\r\n///\r\ndwResultReadClsOffset --- この構造体の開始位置から結果読み文節へのオフセット。文節情報はここに格納される。\r\n///\r\ndwResultReadStrLen --- 結果文字列の読みの文字列の長さ。\r\n///\r\ndwResultReadStrOffset --- この構造体の開始位置から読みの文字列へのオフセット。結果文字列の読みの文字列がここに格納される。\r\n///\r\ndwResultClsLen --- 結果文字列の文節情報の長さ。\r\n///\r\ndwResultClsOffset --- この構造体の開始位置から結果文節へのオフセット。文節情報はここに格納される。\r\n///\r\ndwResultStrLen --- 結果文字列の長さ。\r\n///\r\ndwResultStrOffset --- この構造体の開始位置から結果文字列へのオフセット。結果文字列はここに格納される。\r\n///\r\ndwPrivateSize --- このメモリーブロックのプライベート領域のサイズ。\r\n///\r\ndwPrivateOffset --- この構造体の開始位置からプライベート領域へのオフセット。プライベート領域はここに格納される。', '', 'Unicode の場合の注記：すべての dw*StrLen メンバーは、対応するバッファ内の Unicode 文字列のサイズである。その他の dw*Len や dw*Offset メンバーは、対応するバッファ内のバイト数である。\r\n\r\n属性（attribute）情報の形式は、各文字に対応するバイトの配列である。次の値が提供される。リストにないものは予約済みである。\r\n\r\n[table:COMPOSITIONSTRING_Table1]\r\n\r\n以下は上の表で述べられた内容の説明である。\r\n\r\n[table:COMPOSITIONSTRING_Table2]\r\n\r\n属性情報の長さは、文字列の長さと同じ。それぞれのバイトが文字列の１バイトに対応する。文字列がDBCS 文字を含んでいたとしても、属性情報は、先行（lead）バイトと二番目のバイトの両方の情報バイトを持つ。\r\n\r\nWindows NT Unicode では、属性情報の長さは、Unicode 文字の個数での長さと同じだ。それぞれの属性バイトは、それぞれの Unicode 文字に対応する。\r\n\r\n文節情報の形式は、ダブルワードの配列であり、文節の位置を表す数値を指定する。文節の位置は、そのコンポジション文字列の位置であり、それはこの位置から始まる文節を伴う。少なくとも、情報の長さは２ダブルワード以上である。これは、文節情報の長さは少なくとも 8 バイトであることを意味する。最初のダブルワード値は、ゼロであり、それは最初の文節の位置である。最後のダブルワード値は、この文字列の長さでなければならない。例えば、文字列が 3 つの文節を持てば、文節情報は 4 ダブルワードを持つ。最初のダブルワードはゼロだ。二番目のダブルバイトは、二番目の文節の開始位置を表す。三番目のダブルバイトは、三番目の文節の開始位置を指定する。最後のダブルバイトは、この文字列の長さである。\r\n\r\nWindows NT Unicode では、それぞれの文節の位置と、その文字列の長さは、Unicode 文字でカウントされる。\r\n\r\ndwCursorPos メンバーは、カーソル位置を指定し、文字の個数でコンポジション文字列のどこにカーソルが位置するのかを示す。カウントはゼロから始まる。もしカーソルがコンポジション文字列の直後に位置していれば、この値は、コンポジション文字列の長さに等しいはずだ。もしもカーソルがなければ、-1 の値が指定される。コンポジション文字列が存在しなければ、このメンバーは無効である。\r\n\r\nWindows NT Unicode では、カーソル位置は Unicode 文字で数えられる。', '', '2016-09-10 04:06:02', '2016-09-10 04:06:02', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Context Code', '', 'コンテキストコードは、キーストロークメッセージが生成されたときにALTキーが押されていたかを表す。ALTキーが押されていればこのコードは1であり、上がっていればゼロである。', '', '', '', '', '', '2016-09-14 10:44:38', '2016-09-14 10:44:38', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Dead-Character Messages', '', '（訳注：このページは翻訳しない）\r\n\r\nSome non-English keyboards contain character keys that are not expected to produce characters by themselves. Instead, they are used to add a diacritic to the character produced by the subsequent keystroke. These keys are called dead keys. The circumflex key on a German keyboard is an example of a dead key. To enter the character consisting of an \"o\" with a circumflex, a German user would type the circumflex key followed by the \"o\" key. The window with the keyboard focus would receive the following sequence of messages:\r\n\r\n1. WM_KEYDOWN \r\n2. WM_DEADCHAR \r\n3. WM_KEYUP \r\n4. WM_KEYDOWN \r\n5. WM_CHAR \r\n6. WM_KEYUP\r\n\r\nTranslateMessage generates the WM_DEADCHAR message when it processes the WM_KEYDOWN message from a dead key. Although the wParam parameter of the WM_DEADCHAR message contains the character code of the diacritic for the dead key, an application typically ignores the message. Instead, it processes the WM_CHAR message generated by the subsequent keystroke. The wParam parameter of the WM_CHAR message contains the character code of the letter with the diacritic. If the subsequent keystroke generates a character that cannot be combined with a diacritic, the system generates two WM_CHAR messages. The wParam parameter of the first contains the character code of the diacritic; the wParam parameter of the second contains the character code of the subsequent character key.\r\n\r\nThe TranslateMessage function generates the WM_SYSDEADCHAR message when it processes the WM_SYSKEYDOWN message from a system dead key (a dead key that is pressed in combination with the ALT key). An application typically ignores the WM_SYSDEADCHAR message.', '', '', '', '', '', '2016-09-17 06:46:17', '2016-09-17 06:46:17', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Default and Application IME Window', '', 'システムは、既定の IME ウィンドウをスレッドの初期化時に作成し、それをスレッドに自動的に渡す。このIME ウィンドウが、IME を意識していないアプリの IME UI となる。\r\n\r\nIME や IMM が WM_IME_xxx メッセージを生成するとき、IME を意識していないアプリは、それらをDefWindowProc 関数に渡す。それから、必要なメッセージを DefWindowProc が既定の IME ウィンドウに送信する。IME を意識していないアプリでは、既定の IME ウィンドウは IME の既定のふるまいを提供する。IMEを意識しているアプリは、メッセージをフックしていないときでも IME ウィンドウを使う。アプリは、必要に応じて、アプリ所有の IME ウィンドウを使うことができる。', '', '', '', '', 'DefWindowProc', '2016-09-10 10:16:02', '2016-09-10 10:16:02', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Default Input Context', '', '既定では、システムは各スレッドのために、既定の入力コンテキストを作成する。すべての、IME を意識しないウィンドウはこのコンテキストを共有する。', '', '', '', '', 'IME Input Context|Application-Created Input Context', '2016-09-10 10:25:18', '2016-09-10 10:25:18', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('DefWindowProc', '関数', '既定のウィンドウプロシージャを呼び出して、アプリケーションが処理しないウィンドウメッセージに対して、既定の処理を提供します。この関数は、すべてのメッセージが処理されることを保証します。DefWindowProc 関数には、既定のウィンドウプロシージャが受け取るのと同じパラメータが渡されます。', 'LRESULT DefWindowProc(\r\n  HWND hWnd,      // ウィンドウのハンドル\r\n  UINT Msg,       // メッセージの識別子\r\n  WPARAM wParam,  // メッセージの最初のパラメータ\r\n  LPARAM lParam   // メッセージの 2 番目のパラメータ\r\n);', 'hWnd --- メッセージを受信したウィンドウプロシージャのハンドルを指定します。\r\n///\r\nMsg --- メッセージを指定します。\r\n///\r\nwParam --- メッセージの追加情報を指定します。このパラメータの意味は、Msg パラメータの値によって異なります。\r\n///\r\nlParam --- メッセージの追加情報を指定します。このパラメータの意味は Msg パラメータの値によってり異なります。', 'メッセージ処理の結果が返ります。戻り値の意味は、メッセージによって異なります。', '', 'Window|Procedure|CallWindowProc|DefDlgProc|WindowProc', '2016-08-27 05:24:48', '2016-08-27 05:24:48', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc410753.aspx', 'Microsoft', '', '', '', ''),
('Double-byte Character Sets', '', 'ダブルバイト文字セット（DBCS）は、「拡張８ビット文字セット」として知られており、シングルバイト文字セット（SBCS）の拡張であり、１つのコードページとして実装される。DBCSは、はじめは、日本語や中国語などの言語を扱うSBCS設計を拡張するために開発された。英語の数字や文字を含む、DBCSのいくつかの文字は、シングルバイトのコードの値を持つ。その他の文字、例えば、中国語の表意文字や、日本語の漢字は、ダブルバイトのコードの値を持つ。DBCSはWindowsコードページやOEMコードページのいずれかに相当する。DBCSコードページは、例えばEBCDICコードページのような非ネイティブなコードページを含むことができる。それらのコードページの定義については「コードページ」を参照せよ。\r\n\r\n注意：新しいWindowsアプリは、様々なコードページの非一貫性とローカリゼーションの簡単さのため、Unicodeを使うべきだ。しかしながら、レガシーなプロトコルでは、DBCSコードページを使う必要があるかもしれない。それぞれのDBCSコードページは異なる文字たちをサポートするが、Unicodeで提供されるすべての文字をサポートするページはない。それぞれのDBCSコードページは異なるサブセットをサポートし、異なってエンコードされる。DBCSコードページから別のコードページへ変換したデータは、壊れる可能性がある。なぜなら、異なるコードページの同じデータの値は、別の文字としてエンコードされるからだ。UnicodeからDBCSへ変換されたデータは、データが失われる可能性がある。なぜなら、与えられたコードページは、Unicodeデータで使われるすべての文字を表現できないかもしれないからだ。\r\n\r\nDBCS文字列を解釈するためには、アプリは、文字列の開始位置からスタートして、順番にスキャンしなければならない。リードバイト（lead byte）に遭遇したら、次のバイトをトレイルバイト（trailing byte）として扱うことで、正しくスキャンできる。もしアプリは一度に1バイトのみをスキャンし、バックスラッシュ（半角の円記号）を表すコードの値に遭遇したとき、そのバイトは２バイト文字のトレイルバイトかもしれない。アプリは直前のバイトがリードバイトのときに、１バイトをバックアップすることはできない。なぜなら、そのバイトはリードバイトとしてもトレイルバイトとしても使うことができるからである。したがって、アプリは本質的にバックスラッシュで起こる同じような問題がある。別の言葉で言えば、DBCSにおける部分文字列の検索は、SBCSやUnicodeeよりも複雑である。したがって、DBCSをサポートするアプリは、strstr関数ではなく_mbsstrのような特殊な関数を使わなければならない。\r\n\r\nあなたのアプリは\"A\"バージョンのWindows関数と共にDBCS Windowsコードページを使う。「関数プロトタイプとコードページに対する慣習」を参照せよ。DBCSコードページを識別することを助けるために、アプリはGetCPInfoかGetCPInfoEx関数を使うことができる。アプリは２バイト文字のリードバイトを確かめるために、IsDBCSLeadByte関数を使うことができる。加えて、MultiByteToWideCharやWideCharToMultiByte関数をUnicode文字列とDBCS文字列の間の変換で使うことができる。', '', '', '', '', 'Code Pages', '2016-09-18 04:51:38', '2016-09-18 04:51:38', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd317794.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('EM_GETIMESTATUS', 'メッセージ', 'エディットコントロールがどのようにIMEと対話するかを表す状態フラグの集合を取得します。', 'EM_GETIMESTATUS', 'wParam --- 取得する状態の種類です。このパラメータは次の値を指定できます。\r\n\r\n[table:EM_GETIMESTATUS_Table1]\r\n///\r\nlParam --- このパラメータは使われません。', '取得する状態の種類に応じたデータです。EMSIS_COMPOSITIONSTRINGの値を指定すると、以下の1個以上の値を返します。\r\n\r\n[table:EM_GETIMESTATUS_Table2]', 'リッチエディット: EM_GETIMESTATUSメッセージはサポートされません。', 'EM_SETIMESTATUS', '2016-09-03 04:32:47', '2016-09-03 04:32:47', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb761580.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('EM_SETIMESTATUS', 'メッセージ', 'エディットコントロールがどのようにIMEと対話するかを決める状態フラグたちをセットします。', 'EM_SETIMESTATUS', 'wParam --- セットする状態の種類です。このパラメータは、次の値を指定できます。\r\n\r\n[table:EM_SETIMESTATUS_Table1]\r\n///\r\nlParam --- 状態の種類に応じたデータです。もしwParamがEMSIS_COMPOSITIONSTRINGなら、このパラメータは、以下の1個以上の値です。\r\n\r\n[table:EM_SETIMESTATUS_Table2]', 'lParamパラメータの直前の値を返します。', 'リッチエディット: EM_SETIMESTATUSメッセージはサポートされません。', 'EM_GETIMESTATUS', '2016-09-03 04:42:20', '2016-09-03 04:42:20', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/bb761645.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Enhanced Reconversion', '', 'アプリは、コンポジション文字列とは異なるターゲットの文字列をセットできる。ターゲット文字列（またはその一部）はそのとき、IME によって高い優先順位でターゲットの文節に入る。RECONVERTSTRING 構造体のターゲットの文字列は、コンポジション文字列の一部でなければならない。アプリが再変換の間、ユーザのフォーカスを変更したくないときは、ターゲットの文字列が指定されるべきだ。IME はその場合、その文字列を参照できる。', '', '', '', '', 'RECONVERTSTRING', '2016-09-10 10:40:57', '2016-09-10 10:40:57', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Extended-Key Flag', '', '拡張キーフラグは、キーストロークメッセージが拡張キーボードにおける追加的なキーのうちの一つから発生したかを表す。拡張キーは、キーボードの右側のALTやCTRLキー、INS、DEL、HOME、END、PAGE UP、PAGE DOWN、矢印キー、PRINT SCRNキー、そしてテンキーの割り算（/）とENTERキーである。拡張キーフラグは、キーが拡張キーのときセットされる。', '', '', '', '', '', '2016-09-14 10:43:15', '2016-09-14 10:43:15', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Generating Messages', '', 'IME は IME メッセージを生成する必要がある。IME が変換プロセスを初期化したとき、IME は、WM_IME_STARTCOMPOSITION メッセージを生成する必要がある。もし、IME がコンポジション文字列を変更したら、IME は、WM_IME_COMPOSITION メッセージを生成する必要がある。\r\n\r\nIME がメッセージを生成する方法には、二通りある。一つは、ImeToAsciiEx 関数で与えられるlpTransMsgList バッファを使うこと、もう一つは、ImmGenerateMessage 関数を呼ぶことだ。\r\n\r\n * メッセージ生成にlpTransMsgListを使う方法\r\n * メッセージ生成にメッセージバッファを使う方法', '', '', '', '', 'Using lpTransMsgList to Generate Messages|Using the Message Buffer to Generate Messages|WM_IME_STARTCOMPOSITION|WM_IME_COMPOSITION|ImeToAsciiEx|ImmGenerateMessage', '2016-09-10 10:31:57', '2016-09-10 10:31:57', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('GetActiveWindow', '関数', 'GetActiveWindow\r\n \r\n呼び出し側のスレッドのメッセージキューに関連付けられているアクティブウィンドウのウィンドウハンドルを取得します。', 'HWND GetActiveWindow(VOID);', 'パラメータはありません。', '関数が成功すると、呼び出し側のスレッドに関連付けられているアクティブウィンドウのハンドルが返ります。それ以外の場合、NULL が返ります。', 'フォアグラウンドウィンドウのハンドルを取得するには、GetForegroundWindow を使います。\r\n\r\nWindows 98 と Windows NT 4.0 SP3 以降： 他のスレッドのメッセージキューに関連付けられているアクティブウィンドウのウィンドウハンドルを取得するには、GetGUIThreadInfo を使います。', 'GetForegroundWindow|GetGUIThreadInfo|SetActiveWindow', '2016-09-11 08:15:21', '2016-09-11 08:15:21', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc410861.aspx', 'Microsoft', '', '', '', ''),
('GetFocus', '関数', '呼び出し側のスレッドに関連付けられているウィンドウの中から、キーボードフォーカスを持つウィンドウのハンドルを取得します。', 'HWND GetFocus(VOID);', 'パラメータはありません。', '関数が成功すると、呼び出し側のスレッドに関連付けられている、キーボードフォーカスを持つウィンドウのハンドルが返ります。呼び出し側のスレッドのメッセージキューが、キーボードフォーカスを持つウィンドウを持たないときは、NULL が返ります。', 'GetFocus は、現在のスレッドのメッセージキューに対応する、キーボードフォーカスを持つウィンドウを返します。GetFocus が NULL を返した場合、キーボードフォーカスを持つウィンドウに、他のスレッドのキューが関連付けられています。\r\n\r\n現在ユーザーが作業しているウィンドウのハンドルを取得するには、GetForegroundWindow 関数を使います。AttachThreadInput 関数を使うと、現在のスレッドのメッセージキューを、他のスレッドが保持しているウィンドウに関連付けることができます。\r\n\r\nWindows 98 および Windows NT 4.0 SP3 以降：フォアグラウンドキューまたは他のスレッドのキューのキーボードフォーカスを持つウィンドウを取得するには、GetGUIThreadInfo 関数を使います。', 'GetForegroundWindow|GetGUIThreadInfo|SetFocus|WM_KILLFOCUS|WM_SETFOCUS', '2016-09-11 08:16:33', '2016-09-11 08:16:33', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364641.aspx', 'Microsoft', '', '', '', ''),
('GetKeyboardLayout', '関数', '指定されたスレッドに対してアクティブな入力ロケール識別子（ 旧名キーボードレイアウト）を取得します。idThread パラメータが 0 の場合、アクティブスレッドに対する入力ロケール識別子が返ります。', 'HKL GetKeyboardLayout(\r\n  DWORD idThread  // スレッド識別子\r\n);', 'idThread --- 照会するスレッドを指定するか、現在のスレッドに対しては 0 を指定します。', 'そのスレッドに対する入力ロケール識別子（ 旧名キーボードレイアウトハンドル）が返ります。下位ワードにはその入力言語に対する言語識別子が入り、上位ワードにはキーボードの物理レイアウトに対するデバイスハンドルが入ります。', '入力ロケール識別子には音声入力コンバータ、IME、またはその他のあらゆる入力形式が含まれており、キーボードレイアウトよりも広い概念を持ちます。', 'ActivateKeyboardLayout|LoadKeyboardLayout|WM_INPUTLANGCHANGE', '2016-09-11 08:17:51', '2016-09-11 08:17:51', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364671.aspx', 'Microsoft', '', '', '', ''),
('GetKeyboardLayoutList', '関数', 'システムにある現在の一連の入力ロケールに対応する、入力ロケール識別子（ 旧名キーボードレイアウトハンドル）を取得します。この関数により、識別子は与えられたバッファにコピーされます。', 'UINT GetKeyboardLayoutList(\r\n  int nBuff,       // 配列要素のバッファサイズ\r\n  HKL FAR *lpList  // 入力ロケール識別子のためのバッファ\r\n);', 'nBuff --- バッファが保持できるハンドルの最大数を指定します。\r\n///\r\nlpList --- 入力ロケール識別子の配列を受け取るバッファへのポインタを指定します。', '関数が成功すると、バッファにコピーされた入力ロケール識別子の数か、または nBuff パラメータが 0 の場合は、現在の入力ロケール識別子全体を受け取るのに必要なバッファのサイズが配列要素数で返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、GetLastError 関数を使います。', '入力ロケール識別子には音声入力コンバータ、IME、またはその他のあらゆる入力形式が含まれており、キーボードレイアウトよりも広い概念を持ちます。', 'GetKeyboardLayout', '2016-09-11 08:20:09', '2016-09-11 08:20:09', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364672.aspx', 'Microsoft', '', '', '', ''),
('GetKeyboardLayoutName', '関数', 'アクティブな入力ロケール識別子（ 旧名キーボードレイアウト）の名前を取得します。', 'BOOL GetKeyboardLayoutName(\r\n  LPTSTR pwszKLID   // 入力ロケール識別子名のためのバッファへのポインタ\r\n);', 'pwszKLID --- 終端の NULL 文字を含んだ入力ロケール識別子の名前を受け取る、少なくとも KL_NAMELENGTH 文字のサイズを持つバッファへのポインタを指定します。このパラメータは、レイアウトの置き換えが発生した場合を除き、LoadKeyboardLayout 関数に提供される文字列のコピーになります。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、GetLastError 関数を使います。', '入力ロケール識別子には音声入力コンバータ、IME、またはその他のあらゆる入力形式が含まれており、キーボードレイアウトよりも広い概念を持ちます。\r\n\r\nWindows NT/2000：GetKeyboardLayoutName 関数は、システムに対するアクティブな入力ロケール識別子の名前を受け取ります。\r\n\r\nWindows 95：GetKeyboardLayoutName 関数は、呼び出し側のスレッドに対するアクティブな入力ロケール識別子の名前を受け取ります。', 'ActivateKeyboardLayout|LoadKeyboardLayout|UnloadKeyboardLayout', '2016-09-11 08:21:33', '2016-09-11 08:21:33', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364673.aspx', 'Microsoft', '', '', '', ''),
('GetKeyState', '関数', '指定された仮想キーの状態を取得します。状態とは、キーが押されているか、押されていないか、トグルになっているかどうか（ オンとオフの 2 つがあり、キーを押すたびに入れ替わります）を表します。', 'SHORT GetKeyState(\r\n  int nVirtKey   // 仮想キーコード\r\n);', 'nVirtKey［入力］ --- 仮想キーコードを指定します。希望の仮想キーが文字キーまたは数字キー（A～Z、a～z、0～9）である場合、nVirtKey にその文字の ASCII コードを指定しなければなりません。他のキーの場合は、仮想キーコードを指定しなければなりません。\r\n\r\nヨーロッパなどの英語以外のキーボードレイアウトを使っている場合、A～Z と 0～9 の各範囲に相当する ASCII コードは、アクセント付きを含め、ほとんどの文字を表すために使われています。たとえば、ドイツ語のキーボードレイアウトでは、ASCII の「O」（0x4F）の値に相当する仮想キーは「o」キーを意味しますが、VK_OEM_1 は「ウムラウト（¨）付きの o」キーを意味します。', '戻り値は、指定された仮想キーの状態を表します。各値は次のことを意味します。\r\n\r\n * 最上位ビットが 1 のときはキーが押されていることを、0 のときはキーが押されていないことを示します。\r\n * 最下位ビットが 1 のときはキーがトグル状態にあることを示します。たとえば、CapsLock キーが ON になっているときは、トグル状態になります。最下位ビットが 0 のときはキーが OFF になっていて、トグルが解除されていることを示します。キーボードにトグルキーのインジケータランプが用意されている場合、キーがトグル状態になっているとランプは点灯し、トグル解除状態ではランプは消灯します。', 'スレッドがメッセージキューからキーメッセージを読み出すたびに、この関数が返すキーの状態は変化します。キーの状態は、ハードウェアによる割り込みレベルの状態を反映しません。割り込みレベルの情報を取得するには、GetAsyncKeyState 関数を使ってください。\r\n\r\nアプリケーションは、キーボード入力メッセージに応じて GetKeyState を呼び出します。この関数は、入力メッセージが生成されたときのキーの状態を取得します。\r\n\r\nすべての仮想キーの状態を取得するには、GetKeyboardState 関数を使います。\r\n\r\nアプリケーションは nVirtKey パラメータの値として、VK_SHIFT、VK_CONTROL、VK_MENU の各仮想キーコード定数を使えます。この場合、左右を区別することなく、Shift、Ctrl、Alt の各キーの状態を取得できます。また、アプリケーションは nVirtKey の値として次の仮想キーコード定数を使うことにより、これらのキーの左右を区別できます。\r\n\r\n * VK_LSHIFT\r\n * VK_RSHIFT\r\n * VK_LCONTROL\r\n * VK_RCONTROL\r\n * VK_LMENU\r\n * VK_RMENU\r\n\r\n左右を区別するこれらの定数は、GetKeyboardState、SetKeyboardState、GetAsyncKeyState、GetKeyState、MapVirtualKey の各関数に限って利用できます。', 'GetAsyncKeyState|GetKeyboardState|MapVirtualKey|SetKeyboardState', '2016-09-11 08:23:55', '2016-09-11 08:23:55', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364676.aspx', 'Microsoft', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('GUIDELINE', '構造体', 'IME が送り出すガイドライン情報を所持する。', 'typedef struct {\r\n    DWORD dwSize;\r\n    DWORD dwLevel; // the error level.\r\n        // GL_LEVEL_NOGUIDELINE, GL_LEVEL_FATAL,\r\n        // GL_LEVEL_ERROR, GL_LEVEL_WARNNING,\r\n        // GL_LEVEL_INFORMATION\r\n    DWORD dwIndex; // GL_ID_NODICTIONARY and so on.\r\n    DWORD dwStrLen; // Error Strings, if this is 0, there\r\n        // is no error string.\r\n    DWORD dwStrOffset;\r\n    DWORD dwPrivateSize;\r\n    DWORD dwPrivateOffset;\r\n} GUIDELINE;', 'dwLevel --- 以下のようなエラーレベルを指定する。\r\n\r\n[table:GUIDELINE_Table1]\r\n///\r\ndwIndex --- 次の値を指定する。\r\n\r\n[table:GUIDELINE_Table2]\r\n///\r\ndwPrivateSize --- プライベート領域のサイズ。\r\n///\r\ndwPrivateOffset --- この構造体からプライベート領域の開始位置へのオフセット。プライベート領域はここに格納される。', '', 'Unicode では、dwStrLen メンバーは Unicode 文字で数えたときのエラー文字列のサイズである。dwSize、 \r\ndwStrOffset、 dwPrivateSize などの他のサイズのパラメータは、バイト数で数えたときのサイズである。', '', '2016-09-10 04:11:28', '2016-09-10 04:11:28', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Hot-Key Support', '', 'ホットキーは、キューにある他のキーをバイパスして、スレッドのメッセージキューの先頭に置くメッセージであるWM_HOTKEYメッセージを生成する、キーの組み合わせである。アプリは、ユーザーから高い優先順位のキーボード入力を取得するためにホットキーを使う。例えば、キーの組み合わせCTRL+Cでホットキーを定義することで、アプリはユーザーが長い時間のかかる操作をキャンセルすることを許可する。\r\n\r\nホットキーを定義するためには、アプリはWM_HOTKEYメッセージを生成するキーの組み合わせと、メッセージを受け取るウィンドウと、ホットキーの識別子を指定してRegisterHotKey関数を呼ぶ。ユーザーがホットキーを押したとき、ウィンドウを作成したスレッドのメッセージキューにWM_HOTKEYメッセージが置かれる。メッセージのwParamパラメータは、ホットキーの識別子を含む。アプリは１つのスレッドに複数のホットキーを定義できるが、それぞれのホットキーはユニークな識別子を持たなければならない。アプリが終了するまえに、アプリはホットキーを破棄するためにUnregisterHotKey関数を使うべきである。アプリはユーザーがホットキーを簡単に選べるようにするために、ホットキーコントロールを使うことができる。ホットキーコントロールは、たいていウィンドウをアクティブにするホットキーを定義するために使われる。それらはRegisterHotKeyとUnregisterHotKey関数を使わない。代わりに、ホットキーコントロールを使うアプリは、ホットキーをセットするためにWM_SETHOTKEYメッセージを送信する。ユーザーがホットキーを押したときはいつでも、システムはSC_HOTKEYを指定したWM_SYSCOMMANDメッセージを送信する。ホットキーコントロールの詳細は、「ホットキーコントロール」の「ホットキーコントロールの使い方」を参照せよ。', '', '', '', '', '', '2016-09-15 09:53:14', '2016-09-15 09:53:14', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_CLOSESTATUSWINDOW', 'コマンド', '状態ウィンドウを隠すようにIMEウィンドウを指図します。このコマンドを送信するために、アプリは下記に示される設定のパラメーターでWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_CLOSESTATUSWINDOW', 'wParam --- IMC_CLOSESTATUSWINDOWにセットします。\r\n/// \r\nlParam --- 使われません。', '成功なら、ゼロを返します。失敗なら非ゼロを返します。', 'IME状態ウィンドウがすでに隠されているとき、このコマンドは何もしません。たとえアプリがこのコマンドをIMEウィンドウに送信できるとしても、アプリは、対応するIMN_CLOSESTATUSWINDOWコマンドを受け取りません。', 'WM_IME_CONTROL|IMN_CLOSESTATUSWINDOW', '2016-08-27 11:26:39', '2016-08-27 11:26:39', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318152.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_GETCANDIDATEPOS', 'コマンド', '候補ウィンドウの位置を取得するようにIMEウィンドウを指図します。このコマンドを送信するために、アプリは以下に示されるパラメーター設定でWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_GETCANDIDATEPOS', 'wParam --- IMC_GETCANDIDATEPOSにセットします。\r\n///\r\nlParam --- 候補ウィンドウの位置を含むCANDIDATEFORM構造体へのポインターを指定します。', '成功ならゼロを返します。失敗なら非ゼロを返します。', 'IMEは候補ウィンドウを補正するかもしれないので、アプリはウィンドウをどのように再配置するか決める目的でこのコマンドを実際の位置を取得するために使います。取得した位置は、現在の入力フォーカスを持つウィンドウに相対的なウィンドウ座標になります。', 'WM_IME_CONTROL|CANDIDATEFORM|IMC_SETCANDIDATEPOS', '2016-08-27 11:32:09', '2016-08-27 11:32:09', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318153.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_GETCOMPOSITIONFONT', 'コマンド', 'コンポジションウィンドウの未決定の文字列を表示するために使われる論理フォントを取得するようにIMEウィンドウを指図します。このコマンドを送信するために、アプリは、以下に示されるパラメーター設定でWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_GETCOMPOSITIONFONT', 'wParam --- IMC_GETCOMPOSITIONFONTにセットします。\r\n///\r\nlParam --- 論理フォントに関する情報を取得するためのLOGFONT構造体へのポインタを指定します。', '成功ならゼロを返します。失敗なら非ゼロを返します。', '', 'WM_IME_CONTROL|IMC_SETCOMPOSITIONFONT', '2016-08-27 11:35:09', '2016-08-27 11:35:09', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318154.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_GETCOMPOSITIONWINDOW', 'コマンド', 'コンポジションウィンドウの位置を取得するようにIMEウィンドウを指図します。このコマンドを送信するには、以下に示されるパラメーター設定でWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_GETCOMPOSITIONWINDOW', 'wParam --- IMC_GETCOMPOSITIONWINDOWにセットします。\r\n///\r\nlParam --- コンポジションウィンドウの位置を含むCOMPOSITIONFORM 構造体へのポインタです。', '成功ならゼロを返します。失敗なら非ゼロを返します。', 'IMEは、コンポジションウィンドウの位置を補正するかもしれないので、ウィンドウをどこに再配置するか決定する目的で、アプリはこのコマンドを実際の位置を取得するために使います。取得した位置は、現在の入力フォーカスを持つウィンドウに対する相対的なウィンドウ座標になります。', 'WM_IME_CONTROL|IMC_SETCOMPOSITIONWINDOW|COMPOSITIONFORM', '2016-08-27 11:39:37', '2016-08-27 11:39:37', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318155.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_GETSTATUSWINDOWPOS', 'コマンド', '状態ウィンドウの位置を取得するようにIMEウィンドウを指図します。このコマンドを送信するためには、アプリは、以下に示されるパラメーター設定でWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_GETSTATUSWINDOWPOS', 'wParam --- IMC_GETSTATUSWINDOWPOSにセットします。\r\n///\r\nlParam --- 使いません。', 'スクリーンの左上端から相対的なスクリーン座標における状態ウィンドウの位置のx座標とy座標を含むPOINTS構造体を返します。', '', 'WM_IME_CONTROL|IMC_SETSTATUSWINDOWPOS', '2016-08-27 11:43:18', '2016-08-27 11:43:18', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318156.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_OPENSTATUSWINDOW', 'コマンド', '状態ウィンドウを表示するように、IMEウィンドウを指図します。このコマンドを送信するためには、アプリは、以下に示されるパラメーター設定でWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_OPENSTATUSWINDOW', 'wParam --- IMC_OPENSTATUSWINDOWにセットします。\r\n///\r\nlParam --- 使いません。', '成功ならゼロを返します。失敗なら非ゼロを返します。', 'このコマンドは、OSがIME状態モードが表示でなければ無視されます。ユーザーはタスクバーからIME状態モードをセットまたはクリアできます。\r\n\r\nもし状態ウィンドウがすでに表示されていれば、このコマンドは何もしません。アプリはこのコマンドをIMEウィンドウに送信できますが、アプリは、対応するIMN_OPENSTATUSWINDOWコマンドを受け取りません。', 'WM_IME_CONTROL|IMC_CLOSESTATUSWINDOW|IMN_OPENSTATUSWINDOW', '2016-08-27 11:48:59', '2016-08-27 11:48:59', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318157.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_SETCANDIDATEPOS', 'コマンド', '候補ウィンドウの位置をセットするように、IMEウィンドウを指図します。このウィンドウを送信するためには、アプリは、以下に示されるパラメーター設定でWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_SETCANDIDATEPOS', 'wParam --- IMC_SETCANDIDATEPOSにセットします。\r\n/// \r\nlParam --- 候補ウィンドウのx座標とy座標を含むCANDIDATEFORM構造体へのポインタを指定します。アプリは、この構造体のdwIndexメンバーをセットすべきです。', '成功ならゼロを返します。失敗なら非ゼロを返します。', 'このコマンドは、アプリ自身がコンポジション文字列を表示し、かつ、候補の表示はIMEウィンドウに任せるようなアプリ向けを想定しています。', 'WM_IME_CONTROL|IMC_GETCANDIDATEPOS|CANDIDATEFORM', '2016-08-27 11:54:24', '2016-08-27 11:54:24', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318158.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_SETCOMPOSITIONFONT', 'コマンド', 'コンポジションウィンドウにおいて、未決定の文字列を表示するために使う論理フォントを指定するように、IMEウィンドウを指図します。このコマンドを送信するためには、アプリは、下記に示されるパラメーター設定でWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_SETCOMPOSITIONFONT', 'wParam\r\nSet to IMC_SETCOMPOSITIONFONT. \r\nlParam\r\nPointer to a LOGFONT structure that contains information about the logical font.', '成功ならゼロを返します。失敗なら非ゼロを返します。', 'このコマンドを処理したら、IMEウィンドウは入力コンテキストにおいて現在選択されているフォントを変更します。', 'WM_IME_CONTROL|IMC_GETCOMPOSITIONFONT', '2016-08-27 11:57:03', '2016-08-27 11:57:03', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318159.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_SETCOMPOSITIONWINDOW', 'コマンド', 'コンポジションウィンドウのスタイルをセットするように、IMEウィンドウを指図します。このコマンドを送信するためには、アプリは、以下に示されるパラメーター設定でWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_SETCOMPOSITIONWINDOW', 'wParam --- IMC_SETCOMPOSITIONWINDOWにセットします。\r\n///\r\nlParam --- スタイル情報を含むCOMPOSITIONFORM構造体へのポインタを指定します。', '成功ならゼロを返します。失敗なら非ゼロを返します。', 'このコマンドは、現在の入力コンテキストにおけるスタイルをセットし、さらにスタイルは、その入力コンテキストを受け取るそれぞれのIMEウィンドウに適用されます。\r\n\r\n既定では、IMEウィンドウは、CFS_POINTスタイルを持ちます。このスタイルでは、IMEウィンドウは、コンポジションウィンドウを開いたときに、現在のキャレット位置とウィンドウ クライアント領域を使います。', 'WM_IME_CONTROL|IMC_GETCOMPOSITIONWINDOW|COMPOSITIONFORM', '2016-08-27 12:01:34', '2016-08-27 12:01:34', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318160.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMC_SETSTATUSWINDOWPOS', 'コマンド', '状態ウィンドウの位置をセットするようにIMEウィンドウを指図します。このコマンドを送信するためには、アプリは以下に示されるパラメーター設定でWM_IME_CONTROLメッセージを使います。', 'LRESULT IMC_SETSTATUSWINDOWPOS', 'wParam --- IMC_SETSTATUSWINDOWPOSにセットします。\r\n///\r\nlParam --- 状態ウィンドウの位置のx座標とy座標を含むPOINTS構造体へのポインタを指定します。座標は、ディスプレイの左上端に相対的なスクリーン座標です。', '成功ならゼロを返します。失敗なら非ゼロを返します。', '', 'WM_IME_CONTROL|IMC_GETSTATUSWINDOWPOS', '2016-08-27 12:04:24', '2016-08-27 12:04:24', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318161.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME and Localized Language Compatibility', '', 'Windows 2000 は、すべてのローカライズされた言語バージョンにおける完全に組み込まれた IME サポートを持つ。すなわち、Windows 2000 のどんな言語についても IME をインストールして使うことができる。IME 開発者は、それらの IME をそれらの環境でテストすべきだ。この新しい特徴はまた、そして、正しい文字セットとフォント情報を含み、別の言語の OS においても正しく閲覧できるように、IME ヘルプの内容を準備させることを IME 開発者に要求する。\r\n\r\nまた、IME 開発者は、Windows 2000 に対しては Unicode IME を開発すべきだ。Unicode IME は、どんなシステムロケールでも Unicode アプリで動作するだろう。Unicode ではない IME については、それらを使うために、IME がサポートする言語と同じ言語をサポートするため、ユーザはシステムロケールを変更しなければならない。', '', '', '', '', '', '2016-09-10 11:03:53', '2016-09-10 11:03:53', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Aware Applications', '', '新しい IME アーキテクチャの主な利点の一つは、アプリと IME の間のよりよい通信ロジックを提供することだ。以下は、IME と関わることができるアプリの例である：\r\n\r\n * IME を意識していないアプリ。この種のアプリは、IME を少しも制御しない。しかしながら、DBCS を受け入れるアプリと同じようにユーザは IME を使ってアプリに DBCS 文字を打ち込むことができる。\r\n * IME を半分意識しているアプリ。この種のアプリは、たいてい様々な IME のコンテキスト（開く、閉じる、コンポジションフォームなど）を制御する。しかし、IME に対して UI を表示しない。\r\n * IME を完全に意識しているアプリ。この種のアプリは、たいてい IME によって与えられた情報を表示する責任があることを完全に要求する。\r\n\r\nWindows 95 と Windows NT 4.0 以降では、IME を意識していないアプリは、1 個の既定の IME ウィンドウと1 個の既定の入力コンテキストでサポートされる。\r\n\r\nIME を半分意識しているアプリは、自分自身の IME ウィンドウを作成するだろう。それはアプリケーションIME ウィンドウと呼ばれる。それは定義済みシステム IME クラスを使う。アプリに与えられた自分自身の入力コンテキストを扱うかもしれないし、扱わないかもしれない。\r\n\r\nIME を完全に意識したアプリは、自分自身で入力コンテキストを扱い、IME ウィンドウを使うことなく入力コンテキストによって与えられた必要な情報を表示するだろう。', '', '', '', '', '', '2016-09-10 10:12:26', '2016-09-10 10:12:26', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Cancel Reconversion', '', '再変換によって生成されたコンポジション文字列をユーザがキャンセルしたとき、IME は、オリジナルの再変換文字列を確定すべきである。さもなければアプリは文字列を失うだろう。', '', '', '', '', 'RECONVERTSTRING', '2016-09-10 10:41:55', '2016-09-10 10:41:55', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Class', '', 'Win32 システムは、IME クラス（ウィンドウクラス）を提供する。このクラスは、定義済みの EDIT クラスのようなユーザによって定義される。システム IME クラスは、IME のすべての UI を扱い、IME とアプリ（IMM 関数を含む）からすべてのコントロールメッセージを扱う。アプリは、このクラスを使って、所有する IME UI を作成できる。システム IME クラスは、IME によっては置き換えられないが、定義済みクラスとして保たれる。\r\n\r\nこのクラスは、ウィンドウプロシージャを持つ。それは、実際に、WM_IME_SELECT メッセージを扱う。このメッセージは、新しく選択された IME の hKL (キーボードレイアウトのハンドル)を持っている。システム IME クラスは、この hKL を持ったそれぞれの IME で定義されたクラスの名前を取得する。この名前を使って、システム IME クラスは、現在アクティブな IME の UI ウィンドウを作成する。', '', '', '', '', 'WM_IME_SELECT', '2016-09-10 10:17:10', '2016-09-10 10:17:10', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Composition String Values', '', 'これらの値は、ImmGetCompositionStringとWM_IME_COMPOSITIONで使われる。\r\n\r\n[table:IME Composition String Values_Table1]', '', '', '', '', 'ImmGetCompositionString|WM_IME_COMPOSITION', '2016-09-03 02:58:24', '2016-09-03 02:58:24', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318164.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Conversion Mode Values', '', 'これらの値はImmGetConversionStatusとImmSetConversionStatus関数で使われる。\r\n\r\n[table:IME Conversion Mode Values_Table1]\r\n\r\nこの他のビットは予約済みである。', '', '', '', '', 'ImmGetConversionStatus|ImmSetConversionStatus', '2016-09-03 03:04:33', '2016-09-03 03:04:33', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318165.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME File Format', '', 'IME は、次のフィールドをバージョン情報リソースに正しく指定する必要がある。これは、固定ファイル情報の部分と、可変長情報の部分を含む。バージョン情報リソースにおける詳しい情報については、Microsoft Platform SDK を参照されたい。\r\n\r\n以下が、IME ファイルが含むべき特定の設定である：\r\n\r\n[table:IME File Format_Table1]', '', '', '', '', '', '2016-09-10 10:53:19', '2016-09-10 10:53:19', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Hot Key Identifiers', '', 'これらの識別子は、ImmSimulateHotKey 関数と共に使われる。\r\n\r\n[table:IME Hot Key Identifiers_Table1]', '', '', '', '', 'ImmSimulateHotKey', '2016-09-03 03:16:53', '2016-09-03 03:16:53', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318167.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Input Context', '', 'それぞれのウィンドウは、IME 入力コンテキストに関連付けられる。IMM は、IME の状態やデータなどを管理するために、また、IME とアプリの間で通信するために、入力コンテキストを使う。\r\n\r\n * 既定の入力コンテキスト\r\n * アプリ作成の入力コンテキスト', '', '', '', '', 'Default Input Context|Application-Created Input Context', '2016-09-10 10:24:13', '2016-09-10 10:24:13', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Menu Functions', '', 'この関数集合の目的は、システムタスクバーの IME 関連のアイコンを減らすためにある。これは、Windows 98 と Windows 2000 で登場した新しい機能だ。\r\n\r\nWindows システムプログラムは、現在の hKL（キーボードレイアウト）が IME であれば、タスクバーに二つのアイコンを導入する。一つのアイコンは、システムタスクバーにある、現在のキーボードレイアウトを示すシステム ML アイコンである。もう一方は、フォーカスされたウィンドウの IME 状態を表すシステムペンアイコンである。たいてい、IME は、追加的なアイコンをタスクバーに置く。このアイコンに対するコンテキストメニューは、完全に IME に依存している。IME アイコンをタスクバーに持つことは、ユーザにとって IME の特別な機能にアクセスする素早い方法だ。しかしながら、IME に関連付けられた三つのアイコンが存在し、それらの追加的なアイコンは、ユーザが欲する以上のものであるかもしれない。\r\n\r\nもしシステムが IME に対して IME メニュー項目たちをシステムペンアイコンに挿入する方法を提供すれば、IME は余分なアイコンをタスクバーに追加する必要はない。\r\n\r\nIME は、IME メニュー項目を取得するために、IME 関数 ImeGetImeMenuItems を呼ぶ。\r\n\r\nアプリは、IME の特別なメニュー項目を取得するために、ImmGetImeMenuItems を使うことができる。それらの項目は、コンテキストメニューに追加できる。ImmNotify を呼び出すことで、選択項目が IME によって処理できる。', '', '', '', '', 'ImmGetImeMenuItems|ImmNotifyIME', '2016-09-10 10:43:37', '2016-09-10 10:43:37', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Menu Notification', '', 'アプリが IME のメニュー項目を扱いたいとき、ImmNotifyIME 関数を呼ぶことができる。IME によって追加されたメニュー項目が選択されたとき、フォーカスされたスレッドのもとで ImmNotifyIME が呼ばれる。', '', '', '', '', 'ImmNotifyIME|NotifyIME', '2016-09-10 10:44:33', '2016-09-10 10:44:33', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME Sentence Mode Values', '', 'これらの値は、ImmGetConversionStatusとImmSetConversionStatus 関数で使われる。\r\n\r\n[table:IME Sentence Mode Values_Table1]\r\n\r\nビット16から31まではIMEで使用するため、予約済みである。', '', '', '', '', 'ImmGetConversionStatus|ImmSetConversionStatus', '2016-09-03 03:12:18', '2016-09-03 03:12:18', '', '', 'IME Sentence Mode Values', 'Katayama Hirofumi MZ', '', '', '', ''),
('IME User Interface', '', 'IME UI（User Interface；操作系）は、IME ウィンドウ、UI ウィンドウを含み、さらに UI ウィンドウのコンポーネントも含んでいる。\r\n\r\nIME クラスとは、定義済みのグローバルなウィンドウクラスであり、IME の操作系をすべて実現する。IME クラスの通常の特徴は、他のコントロールと同じである。そのウィンドウインスタンスは、CreateWindowEx 関数で作成できる。スタティックコントロールのように、ユーザの入力に反応させなくすることもできるが、IME のすべての UI を実現するために、あらゆる種類のコントロールメッセージを受け取る。アプリは、IME クラスを使って、所有する IME ウィンドウを作成できるし、既定の IME ウィンドウを ImmGetDefaultIMEWnd 関数を通じて取得できる。古い Windows 3.1 とは違って、それらのウィンドウハンドルを使って今や IME を制御したいアプリ（IME を意識したアプリ）が以下の長所を実現することができる：\r\n\r\n * 新しい IME は、候補リストウィンドウを含む。それぞれのアプリは、自分自身の UI のウィンドウインスタンスを持つことができるので、ユーザは他のアプリに切り替えるために操作を途中で中断することができる。Windows 3.1 日本語版では、ユーザは他のアプリに切り替える前に、最初に操作を終了する必要があった。\r\n * IME UI ウィンドウは、アプリのウィンドウハンドルを知らされて、アプリにさまざまな既定のふるまいを提供できる。例えば、IME ウィンドウの自動再配置や、ウィンドウキャレット位置の自動追跡、それぞれのアプリのためのモードの表示などが可能だ。\r\n\r\nシステムは、一つだけの IME クラスを提供するが、それらは、二種類の IME ウィンドウである。一つは、特に DefWindowProc 関数によって、システムによって作られ、一つのスレッドのすべての「IME を意識しないアプリ」で共有されるものであり、「既定の IME ウィンドウ」と呼ばれるものだ。もう一つは、IME を意識したアプリにより作成され、「アプリケーション IME ウィンドウ」と呼ばれるものだ。', '', '', '', '', 'ImmGetDefaultIMEWnd|DefWindowProc', '2016-09-10 10:14:32', '2016-09-10 10:14:32', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeConfigure', '関数', 'ImeConfigure 関数は、IME のオプショナルな情報を要求するために使うダイアログを提供する。', 'BOOL WINAPI ImeConfigure(\r\n    HKL hKL,\r\n    HWND hWnd,\r\n    DWORD dwMode,\r\n    LPVOID lpData)', 'hKL --- IME の入力言語ハンドル。\r\n///\r\nhWnd --- 親ウィンドウのハンドル。\r\n///\r\ndwMode --- ダイアログのモード。以下のフラグが与えられる。\r\n\r\n[table:ImeConfigure_Table1]\r\n///\r\nlpData --- VOID へのポインタで、それは(dwMode == IME_CONFIG_REGISTERWORD)\r\nのときのみ、REGISTERWORD 構造体へのポインタになるだろう。さもなければ\r\nlpData は単に無視されるべきだ。また、もし初期文字列情報が与えられなけれ\r\nば、IME_CONFIG_REGISTER モードで NULL を指定できる。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', 'IME は次のような疑似コードで lpData をチェックする。\r\n\r\n<pre>if (dwmode != IME_CONFIG_REGISTERWORD)\r\n{\r\n    // オリジナルの実行をする。\r\n}\r\nelse if (IsBadReadPtr(lpdata, sizeof(REGISTERWORD)) == FALSE)\r\n{\r\n    if (IsBadStringPtr(PREGISTERWORD(lpdata)->lpReading, (UINT)-1) == FALSE)\r\n    {\r\n        // 読みの文字列を単語登録ダイアログにセットする。\r\n    }\r\n    if (IsBadStringPtr(PREGISTERWORD(lpdata)->lpWord, (UINT)-1) == FALSE)\r\n    {\r\n        // 単語文字列を単語登録ダイアログにセットする。\r\n    }\r\n}</pre>', 'REGISTERWORD', '2016-08-29 06:31:13', '2016-08-29 06:31:13', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeConversionList', '関数', 'ImeConversionList 関数は、別の文字や文字列から変換後の結果リストを取得する。', 'DWORD WINAPI IMEConversionList(\r\n    HIMC             hIMC,\r\n    LPCTSTR          lpSrc,\r\n    LPCANDIDATELIST  lpDst,\r\n    DWORD            dwBufLen,\r\n    UINT             uFlag)', 'hIMC --- 入力コンテキスト。\r\n///\r\nlpSrc --- 変換元の文字列。\r\n///\r\nlpDst --- 変換先バッファへのポインタ。\r\n///\r\ndwBufLen --- 変換先バッファの長さ。\r\n///\r\nuFlag --- 現在、以下の 3 つのフラグのうち 1 つを選択できる。\r\n\r\n[table:ImeConversionList_Table1]', '戻り値は、結果文字列リストのバイト数である。', 'この関数は、アプリ、あるいは IME 関連のメッセージを生成していない IME によって呼び出されることを想\r\n定している。したがって、この関数において、IME は IME 関連のメッセージを生成すべきではない。', '', '2016-08-29 06:28:46', '2016-08-29 06:28:46', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeDestroy', '関数', 'ImeDestroy 関数は IME 自身を終了する。', 'BOOL WINAPI ImeDestroy(UINT uReserved)', 'uReserved --- 予約済み。現在はゼロであるべき。このバージョンでは、それがゼロでなければ IME は\r\nFALSE を返すべき。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'ImeInquire', '2016-08-29 06:32:24', '2016-08-29 06:32:24', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMEDPI', '構造体', 'IME DPI (device programming interface)を提供する構造体です。', 'typedef struct IMEDPI\r\n{\r\n  struct IMEDPI *pNext;\r\n  HINSTANCE      hInst;\r\n  HKL            hKL;\r\n  IMEINFO        ImeInfo;\r\n  UINT           uCodePage;\r\n  WCHAR          szUIClass[16];\r\n  DWORD          cLockObj;\r\n  DWORD          dwFlags;\r\n  ... IME function pointers ...\r\n} IMEDPI, *PIMEDPI, NEAR *NPIMEDPI, FAR *LPIMEDPI;', 'pNext --- 次のIME DPIを指します。\r\n///\r\nhInst --- IME のインスタンスのハンドルです。\r\n///\r\nhKL --- キーボードレイアウトのハンドルです。\r\n///\r\nImeInfo --- IMEINFO 構造体です。\r\n///\r\nuCodePage --- コードページを表す整数値です。\r\n///\r\nszUIClass --- IME UIクラスの名前です。\r\n///\r\ncLockObj --- ロックカウントです。\r\n///\r\ndwFlags --- IMEDPI_FLAG_* フラグ群です。', '', 'IMM システムはIMEの読み込み中に、読み込み後にIMM IMEと対話するためにIME DPIを確立しようとします。', 'ImmLockImeDpi|ImmUnlockImeDpi|IMEINFO', '2024-08-13 11:16:51', '2024-08-13 11:16:51', '<imm32_undoc.h>', '', 'katahiromzによる分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeEnumRegisterWord', '関数', 'ImeEnumRegisterWord 関数は、指定された読みの文字列、スタイル、および登録済み文字列データと共に\r\n登録済み文字列の情報を列挙する。', 'UINT WINAPI ImeEnumRegisterWord(\r\n    HKL                   hKL,\r\n    REGISTERWORDENUMPROC  lpfnEnumProc,\r\n    LPCTSTR               lpszReading,\r\n    DWORD                 dwStyle,\r\n    LPCTSTR               lpszString,\r\n    LPVOID                lpData)', 'hKL --- 入力言語ハンドル。\r\n///\r\nlpfnEnumProc --- コールバック関数のアドレス。\r\n///\r\nlpszReading --- 列挙される読みの文字列を指定する。もし lpszReading が NULL であれば、ImeEnumRegisterWord は、指定された dwStyle と lpszString 引数にマッチする、すべての利用可能な読みの文字列を列挙する。\r\n///\r\ndwStyle --- 列挙対象のスタイルを指定する。もし dwStyle が NULL ならば、ImeEnumRegisterWordは、指定された lpszReading と lpszString にマッチする、すべての利用可能なスタイルを列挙する。\r\n///\r\nlpszString --- 列挙対象の登録済み文字列を指定する。もし lpszString が NULL であれば、ImeEnumRegisterWord は、指定された lpszReading と dwStyle 引数にマッチする、すべての登録済み文字列を列挙する。\r\n///\r\nlpData --- アプリが供給するデータのアドレス。', '関数が成功したら、戻り値は、コールバック関数が返した最後の値である。その意味は、アプリによって定義\r\nされる。', 'もし lpszReading、dwStyle、そして lpszString のすべてが NULL であれば、ImeEnumRegisterWord は、IME\r\n辞書のすべての登録済み文字列を列挙する。もし入力引数のうち２つが NULL であれば、\r\nImeEnumRegisterWord は、第三の引数にマッチするすべての登録済み文字列を列挙する。', '', '2016-08-29 07:02:35', '2016-08-29 07:02:35', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeEscape', '関数', 'ImeEscape 関数は、他の IMM 関数を通じては直接利用可能ではない特定の IME の能力へアプリがアク\r\nセスすることを許可する。これは主に、国特有の機能や IME 内部の機能に対して必要である。', 'LRESULT WINAPI ImeEscape(\r\n    HIMC 　　hIMC,\r\n    UINT 　　uEscape,\r\n    LPVOID  lpData)', 'hIMC --- 入力コンテキストのハンドル。\r\n///\r\nuEscape --- 実行したいエスケープ機能を指定する。\r\n///\r\nlpData --- エスケープに必要なデータを指し示す。', '関数が失敗したら、戻り値はゼロである。さもなければ戻り値は、各エスケープ機能に依存する。', 'ImeEscape 関数は以下のエスケープ機能をサポートする。\r\n\r\n[table:ImeEscape_Table1]\r\n\r\nパラメータの正当性の実証は、強靭性（robustness）のために、各エスケープ機能の内部で行われるべきだ。\r\nuEscape が IME_ESC_QUERY_SUPPORT であるとき、lpData は、IME のエスケープの値を含む変数へのポ\r\nインタである。次は、現在の IME が IME_ESC_GETHELPFILENAME をサポートするかどうかを決定するた\r\nめに使える例である。\r\n\r\n<pre>IME_ESC_GETHELPFILENAME.\r\nDWORD dwEsc = IME_ESC_GETHELPFILENAME;\r\nLRESULT lRet = ImmEscape(hKL, hIMC, IME_ESC_QUERYSUPPORT, (LPVOID)&dwEsc);</pre>', '', '2016-08-29 06:34:01', '2016-08-29 06:34:01', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeGetImeMenuItems', '関数', 'ImeGetImeMenuItems 関数は、IME メニューに登録済みのメニュー項目たちを取得する。', 'DWORD WINAPI ImeGetImeMenuItems(\r\n    HIMC               hIMC,\r\n    DWORD              dwFlags,\r\n    DWORD              dwType,\r\n    LPIMEMENUITEMINFO  lpImeParentMenu,\r\n    LPIMEMENUITEMINFO  lpImeMenu,\r\n    DWORD              dwSize)', 'hIMC --- lpMenuItem は、入力コンテキストに関連するメニュー項目たちを含む。\r\n///\r\ndwFlags --- 以下のビット組み合わせからなる。\r\n\r\n[table:ImeGetImeMenuItems_Table1]\r\n///\r\ndwType --- 以下のビット組み合わせからなる。\r\n\r\n[table:ImeGetImeMenuItems_Table2]\r\n///\r\nlpImeParentMenu --- fType に MFT_SUBMENU があるとき、IMEMENUINFO 構造体へのポインタ。ImeGetImeMenuItems は、このメニュー項目のサブメニュー項目たちを返す。もしこれがNULL ならば、lpImeMenu はトップレベルのメニュー項目たちを含む。\r\n///\r\nlpImeMenu --- メニュー項目たちの内容を受け取るバッファへのポインタ。このバッファは、IMEMENUITEMINFO 構造体の配列である。もしこれが NULL ならば、ImeGetImeMenuItems は、登録済みメニュー項目の個数を返す。\r\n///\r\ndwSize --- IMEMENUITEMINFO 構造体を受け取るバッファのサイズ。', '戻り値は、lpImeMenu の中へセットされたメニュー項目の個数である。もし lpImeMenu が NULL であれば、\r\nImeGetImeMenuItems は指定された hKL に登録済みのメニュー項目の個数を返す。', 'ImeGetImeMenuItems は Windows 98 と Windows 2000 で登場した新しい関数である。', 'IMEMENUITEMINFO', '2016-08-29 07:05:02', '2016-08-29 07:05:02', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeGetRegisterWordStyle', '関数', 'ImeGetRegisterWordStyle 関数は、この IME において利用可能なスタイルを取得する。', 'UINT WINAPI ImeGetRegisterWordStyle(\r\n    UINT        nItem,\r\n    LPSTYLEBUF  lpStyleBuf)', 'nItem --- バッファが所有するスタイルの最大個数。\r\n///\r\nlpStyleBuf --- 埋められるバッファ。', '戻り値は、バッファへコピーされたスタイルの個数である。もし nItems がゼロであれば、戻り値は、この IME\r\nにおいて、利用可能なすべてのスタイルを受け取るのに必要なバッファサイズ（配列要素数）である。', '', '', '2016-08-29 07:01:19', '2016-08-29 07:01:19', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMEINFO', '構造体', 'アクティブIMEに関する情報を含みます。', 'typedef struct {\r\n  DWORD dwPrivateDataSize;\r\n  DWORD fdwProperty;\r\n  DWORD fdwConverstionCaps;\r\n  DWORD fdwSentenceCaps;\r\n  DWORD fdwUICaps;\r\n  DWORD fdwSCSCaps;\r\n  DWORD fdwSelectCaps;\r\n} IMEINFO;', 'dwPrivateDataSize --- 私的なデータのバイト数を含む符号なしの長整数値です。\r\n///\r\nfdwProperty --- アクティブIMEプロパティ値を表す符号なしの長整数値です。IME_PROP_* フラグ群を指定します。\r\n///\r\nfdwConverstionCaps --- アクティブIME変換モード能力値たちを表す符号なしの長整数値です。IME_CMODE_* フラグ群を指定します。IME Conversion Mode Valuesを参照。\r\n///\r\nfdwSentenceCaps --- アクティブIMEセンテンスモードの能力を表す符号なしの長整数値です。IME_SMODE_* フラグ群を指定します。IME Sentence Mode Valuesを参照。\r\n///\r\nfdwUICaps --- アクティブIMEのUI能力を表す符号なしの長整数値です。UI_CAP_* フラグ群を指定します。\r\n///\r\nfdwSCSCaps --- コンポジション文字列の能力を表す符号なしの長整数値です。SCS_CAP_* フラグ群を指定します。IME Composition String Valuesを参照。\r\n///\r\nfdwSelectCaps --- 入力コンテキストを継承するアクティブIMEの能力を表す符号なしの長整数値です。SELECT_CAP_* フラグ群を指定します。', '', '', 'ImeInquire|IME Conversion Mode Values|IME Sentence Mode Values|IME Composition String Values', '2016-08-28 07:43:46', '2016-08-28 07:43:46', '<imm.h> または <immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741226.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMEINFOEX', '構造体', 'IMEINFO構造体を拡張した構造体です。', 'typedef struct tagIMEINFOEX\r\n{\r\n    HKL hkl;\r\n    IMEINFO ImeInfo;\r\n    WCHAR wszUIClass[16];\r\n    ULONG fdwInitConvMode;\r\n    INT fInitOpen;\r\n    INT fLoadFlag;\r\n    DWORD dwProdVersion;\r\n    DWORD dwImeWinVersion;\r\n    WCHAR wszImeDescription[50];\r\n    WCHAR wszImeFile[80];\r\n    struct\r\n    {\r\n        INT fSysWow64Only:1;\r\n        INT fCUASLayer:1;\r\n    };\r\n} IMEINFOEX, *PIMEINFOEX, NEAR *NPIMEINFOEX, FAR *LPIMEINFOEX;', 'hkl --- キーボードレイアウトのハンドルです。\r\n///\r\nImeInfo --- IMEINFO構造体です。\r\n///\r\nwszUIClass --- IME UIクラスの名前です。\r\n///\r\nfdwInitConvMode --- 初期の変換モードです。\r\n///\r\nfInitOpen --- 初期のオープンモードです。\r\n///\r\nfLoadFlag --- 読み込みフラグです。\r\n///\r\ndwProdVersion --- (不明)\r\n///\r\ndwImeWinVersion --- (不明)\r\n///\r\nwszImeDescription --- IMEの説明です。\r\n///\r\nwszImeFile --- IMEファイルの名前です。\r\n///\r\nfSysWow64Only --- (不明)\r\n///\r\nfCUASLayer --- (不明)', '', '', 'IMEINFO', '2024-08-14 00:01:13', '2024-08-14 00:01:13', '<immdev.h>', '', 'katahiromzの分析による。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeInquire', '関数', 'ImeInquire 関数は、IME の初期化を扱う。また、IMEINFO 構造体や IME の UI クラス名も返す。', 'BOOL WINAPI ImeInquire(\r\n    LPIMEINFO lpIMEInfo,\r\n    LPTSTR    lpszWndClass,\r\n    DWORD     dwSystemInfoFlags)', 'lpIMEInfo --- IME 情報構造体へのポインタ。\r\n///\r\nlpszWndClass --- IME によって埋められるべき、ウィンドウクラス名。この名前は IME の UI クラスである。\r\n///\r\ndwSystemInfoFlags --- システムによって与えられるさまざまなシステム情報。以下のフラグが与えられる。\r\n\r\n[table:ImeInquire_Table1]', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'IMEINFO', '2016-08-29 06:26:52', '2016-08-29 06:26:52', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMEMENUITEMINFOA', '構造体', 'アクティブIMEメニュー項目に関する情報を含みます。', 'typedef struct {\r\n    UINT        cbSize;\r\n    UINT        fType;\r\n    UINT        fState;\r\n    UINT        wID;\r\n    HBITMAP     hbmpChecked;\r\n    HBITMAP     hbmpUnchecked;\r\n    DWORD       dwItemData;\r\n    CHAR        szString[IMEMENUITEM_STRING_SIZE];\r\n    HBITMAP     hbmpItem;\r\n} IMEMENUITEMINFOA;', 'cbSize --- この構造体のバイトサイズを表す符号なしの長整数値です。\r\n///\r\nfType --- メニューの種類を表す符号なしの長整数値です。これは次のうち1個の値です。\r\n\r\n[table:IMEMENUITEMINFOA_Table1]\r\n///\r\nfState --- メニュー項目の状態を表す符号なしの長整数値です。これは以下のうち、1個以上の値です。\r\n\r\n[table:IMEMENUITEMINFOA_Table2]\r\n///\r\nwID --- メニュー項目を識別するアプリ定義の値を表す符号なしの長整数値です。\r\n///\r\nhbmpChecked --- ビットマップへのハンドルです。このメンバーがNULLならビットマップは使われません。\r\n///\r\nhbmpUnchecked --- ビットマップへのハンドルです。このメンバーがNULLなら、ビットマップは使われません。\r\n///\r\ndwItemData --- メニュー項目に関連付けられたアプリ定義の値を表す符号なしの長整数値です。\r\n/// \r\nszString --- メニュー項目の内容を表す文字の配列です。これはヌル終端の文字列です。\r\n///\r\nhbmpItem --- 表示するビットマップへのハンドルです。', '', '', 'ImeGetImeMenuItems|IMEMENUITEMINFO|IMEMENUITEMINFOW', '2016-08-28 07:50:52', '2016-08-28 07:50:52', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741227.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMEMENUITEMINFOW', '構造体', 'アクティブIMEメニュー項目に関する情報を含みます。', 'typedef struct {\r\n  UINT    cbSize;\r\n  UINT    fType;\r\n  UINT    fState;\r\n  UINT    wID;\r\n  HBITMAP hbmpChecked;\r\n  HBITMAP hbmpUnchecked;\r\n  DWORD   dwItemData;\r\n  WCHAR   szString[IMEMENUITEM_STRING_SIZE];\r\n  HBITMAP hbmpItem;\r\n} IMEMENUITEMINFOW;', 'cbSize --- この構造体のバイト数を表す符号なしの長整数値です。\r\n///\r\nfType --- メニューの種類を表す符号なしの長整数値です。これは以下の値のうち1個です。\r\n\r\n[table:IMEMENUITEMINFOW_Table1]\r\n///\r\nfState --- メニュー項目の状態を表す符号なしの長整数値です。これは以下の値のうち、1個以上を指定します。\r\n\r\n[table:IMEMENUITEMINFOW_Table2]\r\n///\r\nwID --- メニュー項目を識別するアプリ定義の値を表す符号なしの長整数値です。\r\n///\r\nhbmpChecked --- ビットマップへのハンドルです。このメンバーがNULLなら、ビットマップは使われません。\r\n///\r\nhbmpUnchecked --- ビットマップへのハンドルです。このメンバーがNULLならビットマップは使われません。\r\n///\r\ndwItemData --- メニュー項目に関連付けられたアプリ定義の符号なしの長整数値です。\r\n///\r\nszString --- メニュー項目の内容を表すワイド文字の配列です。これはヌル終端の文字列です。 \r\n///\r\nhbmpItem --- 表示するビットマップへのハンドルです。', '', '', 'ImeGetImeMenuItems|IMEMENUITEMINFO|IMEMENUITEMINFOA', '2016-08-28 08:02:25', '2016-08-28 08:02:25', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741228.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeProcessKey', '関数', 'ImeProcessKey 関数は、IMM を通じて与えられたすべてのキーストロークを前処理し、与えられた入力コン\r\nテキストについてキーが IME に必要であれば TRUE を返す。', 'BOOL WINAPI ImeProcessKey(\r\n    HIMC          hIMC,\r\n    UINT          uVirKey,\r\n    DWORD         lParam,\r\n    CONST LPBYTE  lpbKeyState)', 'hIMC --- 入力コンテキストのハンドル。\r\n///\r\nuVirKey --- 処理すべき仮想キー。\r\n///\r\nlParam --- キーメッセージの lParam。\r\n///\r\nlpbKeyState --- 現在のキーボードの状態を含む 256 バイトの配列を指し示す。IME はこのキー状態の内容を変更すべきではない。', '関数が成功したら、戻り値は TRUE である。さもなければ戻り値は FALSE である。', 'システムはこの関数を呼び出すことで、キーが IME によって扱うか、そうでないかを決定する。もし、アプリ\r\nがキーメッセージを取得する前にこの関数が TRUE を返せば、IME はそのキーを扱うだろう。そのときシステ\r\nムは、ImeToAsciiEx を呼びだすだろう。もしこの関数が FALSE を返せば、システムは、そのキーが IME に\r\nよって扱わないことを認識し、キーメッセージはアプリに送信されるだろう。\r\n\r\nWindows 2000 において、IME_PROP_ACCEPT_WIDE_VKEY をサポートする IME に関しては、\r\nImeProcessKey は、VK_PACKET を通じて SendInput API を使ってインジェクト (inject) された uVirKey の全\r\n部の 32 ビット値を受け取るだろう。uVirKey は、IME が ANSI 版であっても 16 ビット Unicode を上位ワードに\r\n含むだろう。\r\n\r\nIME_PROP_ACCEPT_WIDE_VKEY をサポートしない IME に関しては、Unicode IME の ImeProcessKey \r\nは、上位ワードがゼロの VK_PACKET を受け取るだろう。それでも Unicode IME は、TRUE を返すことができ、\r\nImeToAsciiEx はインジェクトされた Unicode と共に呼び出される。ANSI IME の ImeProcessKey は何も受け取\r\nらないだろう。インジェクトされた Unicode は、ANSI IME が開かれていれば、破棄される。ANSI IME が閉じら\r\nれていれば、インジェクトされた Unicode メッセージは、アプリのキューにすぐに投稿される。', 'ImeToAsciiEx', '2016-08-29 06:38:54', '2016-08-29 06:38:54', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeRegisterWord', '関数', 'ImeRegisterWord 関数は、この IME の辞書へ文字列を登録する。', 'BOOL WINAPI ImeRegisterWord(\r\n    LPCTSTR  lpszReading,\r\n    DWORD    dwStyle,\r\n    LPCTSTR  lpszString)', 'lpszReading --- 登録される文字列の読みの文字列。\r\n///\r\ndwStyle --- 登録される文字列のスタイル。以下の値が与えられる。\r\n\r\n[table:ImeRegisterWord_Table1]\r\n///\r\nlpszString --- 登録される文字列。', '関数が成功すれば、戻り値は TRUE である。さもなければ、戻り値は FALSE である。', '', 'ImeUnregisterWord|ImeEnumRegisterWord', '2016-08-29 06:58:30', '2016-08-29 06:58:30', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeSelect', '関数', 'ImeSelect 関数は、IME のプライベートなコンテキストを初期化・逆初期化する。', 'BOOL WINAPI ImeSelect(\r\n    HIMC hIMC,\r\n    BOOL fSelect)', 'hIMC --- 入力コンテキストのハンドル。\r\n///\r\nfSelect --- 2 つのフラグのいずれかが与えられる。TRUE は、初期化を表し、FALSE は逆初期化を表す (リソースの解放)。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', '', '2016-08-29 06:42:27', '2016-08-29 06:42:27', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeSetActiveContext', '関数', 'ImeSetActiveContext 関数は、現在の IME のアクティブな入力コンテキストを通知する。', 'BOOL WINAPI ImeSetActiveContext(\r\n    HIMC hIMC,\r\n    BOOL fFlag)', 'hIMC --- 入力コンテキストのハンドル。\r\n///\r\nfFlag --- 2 つのフラグが与えられる。TRUE はアクティブにされたことを示し、FALES は非アクティブにされたことを示す。', '関数が成功したら、戻り値は TRUE である。さもなければ戻り値は FALSE である。', 'IME は、新しく選択された入力コンテキストについてこの関数によって通知される。IME は初期化を実行で\r\nきるが、それは必ずしも必要ではない。', '', '2016-08-29 06:37:40', '2016-08-29 06:37:40', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeSetCompositionString', '関数', 'ImeSetCompositionString 関数は、lpComp または lpRead 引数に含まれるデータとともに、IME のコンポジ\r\nション文字列構造体をセットするために、アプリによって使われる。そのとき IME は\r\nWM_IME_COMPOSITION メッセージを生成する。', 'BOOL WINAPI ImeSetCompositionString(\r\n    HIMC     hIMC,\r\n    DWORD    dwIndex,\r\n    LPCVOID  lpComp,\r\n    DWORD    dwCompLen,\r\n    LPCVOID  lpRead,\r\n    DWORD    dwReadLen);', 'hIMC --- 入力コンテキストのハンドル。\r\n///\r\ndwIndex --- 以下の値が dwIndex に与えられる。\r\n\r\n[table:ImeSetCompositionString_Table1]\r\n///\r\nlpComp --- 更新されたコンポジション文字列を含むバッファへのポインタ。文字列の種類は、dwIndexの値によって決定される。\r\n///\r\ndwCompLen --- コンポジションバッファの長さ（バイト単位）。\r\n///\r\nlpRead --- 更新された読みの文字列を含むバッファへのポインタ。 文字列の種類は、dwIndex の値によって決定される。もし dwIndex の値が、SCS_SETRRECONVERTSTRING かSCS_QUERYRECONVERTSTRING であれば、lpRead は、更新された読みの文字列を含む RECONVERTSTRING 構造体へのポインタになるだろう。もし選択中の IME がSCS_CAP_MAKEREAD の値を持っていれば、これは NULL でもよい。\r\n///\r\ndwReadLen --- 読みバッファの長さ（バイト単位）。', '成功ならゼロを返す。', 'Unicode においては、dwCompLen と dwReadLen は、たとえ SCS_SETSTR が指定され、バッファが\r\nUnicode 文字列を含んでいても、バイト数でバッファの長さを指定する。\r\n\r\nSCS_SETRECONVERTSTRING か SCS_QUERYRECONVERTSTRING のいずれかは\r\nSCS_CAP_SETRECONVERTSTRING プロパティを持つ IME に対してのみ使うことができる。このプロパティ\r\nは、ImmGetProperty 関数を使うことで取得できる。', 'WM_IME_COMPOSITION|RECONVERTSTRING', '2016-08-29 06:52:48', '2016-08-29 06:52:48', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeToAsciiEx', '関数', 'ImeToAsciiEx 関数は、引数 hIMC に基づき、IME 変換エンジンを通じて変換結果を生成する。', 'UINT WINAPI ImeToAsciiEx(\r\n    UINT            uVirKey,\r\n    UINT            uScanCode,\r\n    CONST LPBYTE    lpbKeyState,\r\n    LPTRANSMSGLIST  lpTransMsgList,\r\n    UINT            fuState,\r\n    HIMC            hIMC)', 'uVirKey --- 翻訳する仮想キーコードを指定する。プロパティビット IME_PROP_KBD_CHAR_FIRSTが ON であるとき、仮想キーの上位バイトは、エイド（aid）文字列コードである。\r\n\r\nUnicodeにおいては、IME_PROP_KBD_CHAR_FIRST ビットが ON であるとき、uVirKey の上位ワードは、Unicode 文字コードを含む。\r\n///\r\nuScanCode --- 翻訳するキーのハードウェアスキャンコード。\r\n///\r\nlpbKeyState --- 現在のキーボード状態を含む 256 バイトの配列を指し示す。IME はキー状態の内容を変更すべきではない。\r\n///\r\nlpTransMsgList --- 翻訳されたメッセージ結果を受け取るための TRANSMSGLIST バッファを指し示す。これは Windows 95/98 および Windows NT 4.0 IME の文書ではダブルワードバッファとし\r\nて定義されていて、ダブルワードバッファバッファの形式は、\r\n\r\n[翻訳されたメッセージバッファの長さ] [メッセージ 1] [wParam1] [lParam1] {[メッセージ 2] [wParam2] [lParam2] {...{...{...}}}}\r\n\r\nである。\r\n///\r\nfuState --- アクティブなメニューフラグ。\r\n///\r\nhIMC --- 入力コンテキストのハンドル。', '戻り値はメッセージの個数を表す。その個数が翻訳されたメッセージバッファより大きければ、翻訳された\r\nメッセージバッファは充分ではない。システムはそのとき、翻訳メッセージを取得するために、hMsgBuf を\r\nチェックする。', 'Windows 2000 においては、wParam の下位バイトに VK_PACKET を使い、上位ワードには Unicode を\r\n使った、新しい 32 ビットの幅の仮想キーコードが SendInput を使ってインジェクトされうる。\r\nIME_PROP_ACCEPT_WIDE_VKEY をサポートする ANSI IME については、ImeToAsciiEx は、1 文字に\r\n対して 16 ビットまでの ANSI コードを受け取るかもしれない。それは次のようにパックされる。文字は、\r\nVK_PACKET を通じて SendInput API からインジェクトされる。\r\n\r\n[table:ImeToAsciiEx_Table1]', 'TRANSMSGLIST|ImeProcessKey', '2016-08-29 06:56:29', '2016-08-29 06:56:29', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImeUnregisterWord', '関数', 'ImeUnregisterWord 関数は、この IME の辞書から登録済みの文字列を除去する。', 'BOOL WINAPI ImeUnregisterWord(\r\n    LPCTSTR 　lpszReading,\r\n    DWORD　　　dwStyle,\r\n    LPCTSTR 　lpszString)', 'lpszReading --- 登録済みの文字列の読みの文字列。\r\n///\r\ndwStyle --- 登録済みの文字列のスタイル。dwStyle の説明については ImeRegisterWord 関数を参照されたい。\r\n/// \r\nlpszString --- 登録を解除する文字列。', '関数が成功すれば、戻り値は TRUE である。さもなければ、戻り値は FALSE である。', '', 'ImeRegisterWord', '2016-08-29 07:00:36', '2016-08-29 07:00:36', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmActivateLayout', '関数', '指定されたキーボードレイアウトのIMEをアクティブ化します。', 'BOOL WINAPI ImmActivateLayout(HKL hKL)', 'hKL --- キーボードレイアウトのハンドルです。', '成功したらTRUEを返します。', '', '', '2024-08-14 01:10:10', '2024-08-14 01:10:10', '', 'imm32.dll', 'katahiromzによる分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmAssociateContext', '関数', '指定された入力コンテキストを指定されたウィンドウに関連付けます。hIMC パラメータに NULL を指定してこの関数を呼び出すと、ウィンドウと入力コンテキストの関連付けが解除されます（ただし、指定したウィンドウに入力コンテキストが関連付けられていた場合）。通常は、どのウィンドウにも、その作成時に既定の入力コンテキストが自動的に関連付けられます。\r\n\r\nImmAssociateContextEx 関数を使うと、関連付けの種類を指定して関連付けを行うことができます。', 'HIMC ImmAssociateContext(\r\n  HWND hWnd,\r\n  HIMC hIMC   \r\n);', 'hWnd --- 入力コンテキストを関連付けるウィンドウのハンドルを指定します。\r\n///\r\nhIMC --- 入力コンテキストのハンドルを指定します。', '指定したウィンドウにそれまで関連付けられていた入力コンテキストのハンドルが返ります。', '自分で作成した入力コンテキストをウィンドウに関連付けた場合、その後、関連付けを解除してから入力コンテキストを破棄しなければなりません。関連付けの解除を行う方法の 1 つとして、既定の入力コンテキストのハンドルを変数に保存しておき、自分で作成した入力コンテキストが不要になったときにウィンドウに再度既定の入力コンテキストを関連付けるという方法もあります。', 'ImmAssociateContextEx', '2016-08-27 05:27:38', '2016-08-27 05:27:38', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447958.aspx', 'Microsoft', '', '', '', ''),
('ImmAssociateContextEx', '関数', '指定されたウィンドウまたはその子ウィンドウと入力コンテキストとの関連付けの種類を変更して、関連付けを行います。', 'BOOL ImmAssociateContextEx(\r\n  HWND hWnd,    // ウィンドウのハンドル\r\n  HINC hIMC,    // 入力コンテキストのハンドル\r\n  DWORD dwFlags // フラグ\r\n);', 'hWnd --- 入力コンテキストを関連付けるウィンドウのハンドルを指定します。\r\n///\r\nhIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\ndwFlags --- ウィンドウと入力コンテキストの関連付けの種類を指定します。次のいずれかの値を指定できます。 \r\n\r\n[table:ImmAssociateContextEx_Table1]', '関数が成功すると、TRUE が返ります。\r\n 関数が失敗すると、FALSE が返ります。', 'IACE_CHILDREN を指定してこの関数を呼び出すと、指定した入力コンテキストが、hWnd パラメータで指定したウィンドウの子ウィンドウに関連付けられます。この場合に入力コンテキストが関連付けられるのは、hWnd を作成したスレッドの子ウィンドウだけです。また、この関数を呼び出した後に作成した子ウィンドウには、この関連付けは適用されず、既定の入力コンテキストが関連付けられます。\r\nIACE_DEFAULT を指定してこの関数を呼び出すと、指定したウィンドウの既定の入力コンテキストが復元されます。この場合、hIMC パラメータは無視されます。', 'ImmAssociateContext', '2016-08-27 05:29:33', '2016-08-27 05:29:33', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447960.aspx', 'Microsoft', '', '', '', ''),
('ImmConfigureIME', '関数', 'IME の設定用ダイアログボックスを表示します。', 'BOOL ImmConfigureIME(\r\n  HKL hKL,\r\n  HWND hWnd,\r\n  DWORD dwMode, \r\n  LPVOID lpData \r\n);', 'hKL --- 入力ロケール識別子を指定します。\r\n///\r\nhWnd --- ダイアログボックスの親ウィンドウのハンドルを指定します。\r\n///\r\ndwMode --- 表示するダイアログボックスの種類を指定します。次のいずれかの値を指定できます。\r\n\r\n[table:ImmConfigureIME_Table1]\r\n///\r\nlpData --- 補足データへのポインタを指定します。dwMode パラメータに IME_CONFIG_REGISTERWORD を指定した場合、このパラメータに REGISTERWORD 構造体のアドレスを指定しなければなりません。 \r\n\r\ndwMode パラメータに IME_CONFIG_REGISTERWORD 以外の値を指定した場合、このパラメータは無視されます。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', 'ImmConfigureIME 関数はコントロールパネルからも呼び出されます。', 'REGISTERWORD|ImeConfigure', '2016-08-27 05:32:09', '2016-08-27 05:32:09', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447962.aspx', 'Microsoft', '', '', '', ''),
('ImmCreateContext', '関数', '新しい入力コンテキストを作成し、入力コンテキスト用のメモリを確保して、入力コンテキストを初期化します。アプリケーション固有の入力コンテキストを用意するときに、この関数を呼び出します。', 'HIMC ImmCreateContext(void);', '', '関数が成功すると、新しい入力コンテキストのハンドルが返ります。\r\n 関数が失敗すると、NULL が返ります。', '', 'ImmDestroyContext', '2016-08-27 05:34:31', '2016-08-27 05:34:31', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447964.aspx', 'Microsoft', '', '', '', ''),
('ImmCreateIMCC', '関数', 'ImmCreateIMCC 関数は、IMC のメンバーとしての新しいコンポーネントを作成する。', 'HIMCC WINAPI ImmCreateIMCC(DWORD dwSize)', 'dwSize --- 新しい IMC コンポーネントのサイズ。', '関数が成功すれば、戻り値は IMC コンポーネントのハンドル（HIMCC）である。さもなければ、NULL である。', 'この関数で作成された IMC コンポーネントは、ゼロで初期化される。', 'ImmDestroyIMCC', '2016-08-29 06:08:56', '2016-08-29 06:08:56', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmCreateSoftKeyboard', '関数', 'ImmCreateSoftKeyboard 関数は、ソフトキーボードウィンドウの一種を作成する。', 'HWND WINAPI ImmCreateSoftKeyboard(\r\n    UINT uType,\r\n    UINT hOwner,\r\n    int x, int y)', 'uType --- ソフトキーボードの種類を指定する。\r\n\r\n[table:ImmCreateSoftKeyboard_Table1]\r\n///\r\nhOwner --- ソフトキーボードの所有者を指定する。これは UI ウィンドウでなければならない。\r\n///\r\nx --- ソフトキーボードの初期水平位置を指定する。\r\n///\r\ny --- ソフトキーボードの初期垂直位置を指定する。', 'この関数は、ソフトキーボードのウィンドウハンドルを返す。', '', 'ImmDestroySoftKeyboard|ImmShowSoftKeyboard', '2016-08-29 06:18:46', '2016-08-29 06:18:46', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmDestroyContext', '関数', '入力コンテキストを破棄し、それに関連付けられていたすべてのメモリを解放します。', 'BOOL ImmDestroyContext(\r\n  HIMC hIMC\r\n);', 'hIMC --- 破棄する入力コンテキストのハンドルを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', 'アプリケーション内で ImmCreateContext 関数を使って入力コンテキストを作成した場合は、必ずアプリケーションを終了する前にこの関数を呼び出して、作成した入力コンテキストを破棄しなければなりません。', 'ImmCreateContext', '2016-08-27 05:35:37', '2016-08-27 05:35:37', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447966.aspx', 'Microsoft', '', '', '', ''),
('ImmDestroyIMCC', '関数', 'ImmDestroyIMCC 関数は、IMC のメンバーとして作成された IME コンポーネントを破棄するために IME に\r\nよって使われる。', 'HIMCC WINAPI ImmDestroyIMCC(HIMCC hIMCC)', 'hIMCC --- IMC コンポーネントのハンドル。', '関数が成功すれば戻り値は NULL。さもなければ戻り値は、hIMCC に等しい。', '', 'ImmCreateIMCC', '2016-08-29 06:09:54', '2016-08-29 06:09:54', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmDestroySoftKeyboard', '関数', 'ImmDestroySoftKeyboard 関数は、ソフトキーボードウィンドウを破棄する。', 'BOOL WINAPI ImmDestroySoftKeyboard(HWND hSoftKbdWnd)', 'hSoftKbdWnd --- 破棄するソフトキーボードのウィンドウハンドル。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'ImmCreateSoftKeyboard', '2016-08-29 06:20:12', '2016-08-29 06:20:12', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmDisableIME', '関数', 'プロセス内の 1 つのスレッドまたはすべてのスレッドの IME（Input Method Editor）を無効にします。', 'BOOL ImmDisableIME(\r\n  DWORD idThread   // IME を無効にするスレッド\r\n);', 'idThread --- IMEを無効にするスレッドを指定します。このパラメータに 0 を指定すると、現在のスレッドの IME が無効になります。このパラメータに–1 を指定すると、現在のプロセス内のすべてのスレッドの IME が無効になります。', '関数が成功すると、TRUE が返ります。\r\n 関数が失敗すると、FALSE が返ります。', 'この関数は、必ずスレッド内の最初のトップレベルウィンドウが メッセージを受け取る前に呼び出さなければなりません。このため、アプリケーションは、次のいずれかの場所でこの関数を呼び出す必要があります。\r\n \r\n * 関数を呼び出して最初のトップレベルウィンドウを作成する前の任意のタイミング。\r\n * 最初のトップレベルウィンドウの ハンドラ内。', '', '2016-08-27 05:36:55', '2016-08-27 05:36:55', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447967.aspx', 'Microsoft', '', '', '', ''),
('ImmEnumInputContext', '関数', 'idThread パラメータに指定された値に基づいて入力コンテキストを列挙します。', 'BOOL WINAPI ImmEnumInputContext(\r\n  DWORD idThread,\r\n  IMEENUMPROC lpfn,\r\n  LPARAM lParam\r\n);', 'idThread --- スレッド ID を指定します。次のいずれかの値を指定できます。\r\n\r\n[table:ImmEnumInputContext_Table1]\r\n///\r\nlpfn --- 列挙用のコールバック関数へのポインタを指定します。詳細については、EnumInputContext 関数の説明を参照してください。\r\n///\r\nlParam --- アプリケーション定義のデータを指定します。このパラメータは、そのままコールバック関数に渡されます。', '関数が成功すると、TRUE が返ります。関数が失敗すると、FALSE が返ります。', '入力コンテキストが 1 つ列挙されるたびに 1 度ずつコールバック関数が呼び出されます。コールバック関数には、ImmEnumInputContext 関数の lParam パラメータに指定したデータが渡されます。', '', '2016-08-27 05:38:38', '2016-08-27 05:38:38', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447969.aspx', 'Microsoft', '', '', '', ''),
('ImmEnumRegisterWord', '関数', '指定された読み文字列、品詞、および登録文字列を持つすべての登録文字列を列挙します。', 'UINT ImmEnumRegisterWord(\r\n  HKL hKL,\r\n  REGISTERWORDENUMPROC lpfnEnumProc,\r\n  LPCTSTR lpszReading,\r\n  DWORD dwStyle,\r\n  LPCTSTR lpszRegister,\r\n  LPVOID lpData                       \r\n);', 'hKL --- 入力ロケール識別子を指定します。\r\n///\r\nlpfnEnumProc --- コールバック関数へのポインタを指定します。詳細については、EnumRegisterWordProc 関数の説明を参照してください。\r\n///\r\nlpszReading --- 読み文字列へのポインタを指定します。この読み文字列を持つ登録文字列が列挙されます。NULL を指定すると、パラメータ dwStyle と lpszRegister で指定した条件に一致するすべての登録文字列が列挙されます。\r\n///\r\ndwStyle --- 列挙する登録文字列の品詞を指定します。0 を指定すると、パラメータ lpszReading と lpszRegister で指定した条件に一致するすべての登録文字列が列挙されます。\r\n///\r\nlpszRegister --- 登録文字列へのポインタを指定します。この登録文字列と一致する登録文字列が列挙されます。NULL を指定すると、パラメータ lpszReading と dwStyle で指定した条件に一致するすべての登録文字列が列挙されます。\r\n///\r\nlpData --- アプリケーション定義のデータを指定します。このパラメータは、そのままコールバック関数に渡されます。', 'コールバック関数から最後に返された値が返ります。その意味は、アプリケーションで定義されます。登録文字列を列挙できなかった場合は、0 が返ります。', 'dwStyle パラメータに 0 を指定し、パラメータ lpszReading と lpszRegister に NULL を指定すると、IME 辞書に登録されているすべての登録文字列が列挙されます。', 'ImmRegisterWord', '2016-08-27 05:42:59', '2016-08-27 05:42:59', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447971.aspx', 'Microsoft', '', '', '', ''),
('ImmEscape', '関数', '各国語の IME に固有のサブ関数を実行します。主として、各国語特有の機能を実行するのに使われます。', 'LRESULT ImmEscape(\r\n  HKL hKL,\r\n  HIMC hIMC,\r\n  UINT uEscape,\r\n  LPVOID lpData \r\n);', 'hKL --- 入力ロケール識別子を指定します。\r\n///\r\nhIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nuEscape --- サブ関数のインデックスを指定します。エスケープについては、「IME Escapes」を参照してください。\r\n///\r\nlpData --- 指定したサブ関数用のデータを渡します。', 'エラーが発生すると、0 が返ります。それ以外の場合、戻り値は呼び出したサブ関数によって決まります。', '', 'IME Escapes', '2016-08-27 05:44:05', '2016-08-27 05:44:05', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447973.aspx', 'Microsoft', '', '', '', ''),
('ImmFreeLayout', '関数', '指定したHKLに関連付けられたキーボードレイアウトのIMEを解放します。', 'BOOL WINAPI ImmFreeLayout(HKL hKL)', 'hKL --- キーボードレイアウトのハンドルです。', '成功すればTRUEを返します。', 'HKL_SWITCH_TO_NON_IME と HKL_RELEASE_IME は hKL の特別な値です。', '', '2024-08-14 01:37:19', '2024-08-14 01:37:19', '', 'imm32.dll', 'katahiromzによる分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmGenerateMessage', '関数', 'IME は hIMC の hWnd にメッセージを送信するためにImmGenerateMessage 関数を使う。送信されたメッセージは hIMC の hMsgBuf に格納される。', 'BOOL WINAPI\r\nImmGenerateMessage(HIMC hIMC)', 'hIMC --- hMsgBuf を所有する入力コンテキストのハンドル。', '関数が成功すれば戻り値は TRUE である。さもなければ FALSE になる。', 'これは汎用の関数だ。IMM の ImmNotifyIME を通じてコンテキストの更新について通知されるときには\r\nIME はたいていこの関数を使う。この場合、IME がアプリにメッセージを提供する必要があるときでも、アプリ\r\nのメッセージキューにキーストロークはない。IME UI は、UI の見た目だけを更新したいときにこの関数を使う\r\nべきではない。IME が更新された入力コンテキストについて IME に伝えられたときは、IME UI が更新されて\r\nいるべきである。キーストロークがなく、変更をアプリに通知する必要があるときで、IME が入力コンテキストを\r\n変更したときでのみ、この関数を使うことが推奨される。', 'ImmNotifyIME', '2016-08-29 06:04:46', '2016-08-29 06:04:46', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmGetCandidateList', '関数', '指定された候補一覧を指定されたバッファにコピーします。', 'DWORD ImmGetCandidateList(\r\n  HIMC hIMC,\r\n  DWORD dwIndex,\r\n  LPCANDIDATELIST lpCandList,\r\n  DWORD dwBufLen               \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\ndwIndex --- 候補一覧を 0 から始まるインデックスで指定します。\r\n///\r\nlpCandList --- 候補一覧を受け取る 構造体へのポインタを指定します。\r\n///\r\ndwBufLen --- バッファのサイズをバイト単位で指定します。このパラメータに 0 を指定すると、要求した候補一覧全体を受け取るために必要となるバッファサイズが関数から返ります。', '関数が成功すると、指定したバッファにコピーされたデータのバイト数が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'ImmGetCandidateListCount|CANDIDATELIST', '2016-08-27 05:45:34', '2016-08-27 05:45:34', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447975.aspx', 'Microsoft', '', '', '', ''),
('ImmGetCandidateListCount', '関数', '候補一覧のバイト単位でのサイズを取得します。', 'DWORD ImeGetCandidateListCount（\r\n  HIMC hIMC,\r\n  LPDWORD lpdwListCount \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nlpdwListCount --- 候補一覧のサイズを受け取る 32 ビット変数へのポインタを指定します。', '候補一覧全体を受け取るために必要となるバイト数が返ります。', 'アプリケーションでは通常、IMN_OPENCANDIDATE メッセージまたは IMN_CHANGECANDIDATE メッセージに応答してこの関数を呼び出します。', 'ImmGetCandidateList|IMN_OPENCANDIDATE|IMN_CHANGECANDIDATE', '2016-08-27 05:46:31', '2016-08-27 05:46:31', '<imm.h>', 'imm32.dll', '', 'Microsoft', '', '', '', ''),
('ImmGetCandidateWindow', '関数', '候補一覧ウィンドウに関する情報を取得します。', 'BOOL ImmGetCandidateWindow(\r\n  HIMC hIMC,\r\n  DWORD dwBufLen,\r\n  LPCANDIDATEFORM lpCandidate \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\ndwBufLen --- 情報を受け取るバッファのサイズをバイト単位で指定します。\r\n///\r\nlpCandidate --- 候補一覧ウィンドウに関する情報を受け取る 構造体へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'ImmSetCandidateWindow|CANDIDATEFORM', '2016-08-27 05:47:41', '2016-08-27 05:47:41', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447979.aspx', 'Microsoft', '', '', '', ''),
('ImmGetCompositionFont', '関数', '変換ウィンドウでの文字の表示に現在使われている論理フォントに関する情報を取得します。', 'BOOL ImmGetCompositionFont(\r\n  HIMC hIMC,\r\n  LPLOGFONT lplf \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nlplf --- フォント情報を受け取る 構造体へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'ImmSetCompositionFont', '2016-08-27 05:49:42', '2016-08-27 05:49:42', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447981.aspx', 'Microsoft', '', '', '', ''),
('ImmGetCompositionString', '関数', '変換文字列に関する情報を取得します。', 'LONG ImmGetCompositionString(\r\n  HIMC hIMC,\r\n  DWORD dwIndex,\r\n  LPVOID lpBuf,\r\n  DWORD dwBufLen \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\ndwIndex --- 取得する情報のインデックスを指定します。このパラメータには、「IME定数」の「IMEコンポジション文字列の値」の表に示されている値のいずれかを指定できます。GCS_CURSORPOS と GCS_DELTASTART 以外の値を指定した場合は、要求した情報が指定したバッファにコピーされます。カーソル位置と変換開始位置（delta 値）は、戻り値の下位 16 ビットに格納されます。\r\n///\r\nlpBuf --- 要求した情報を受け取るバッファへのポインタを指定します。\r\n///\r\ndwBufLen --- バッファのサイズをバイト単位で指定します。このパラメータに 0 を指定すると、要求した情報をすべて受け取るために必要となるバッファサイズが関数から返ります。', 'バッファにコピーしたデータのバイト数が返ります。dwBufLen パラメータに 0 を指定した場合は、要求した情報をすべて受け取るために必要となるバッファサイズ（ バイト単位）が返ります。エラーが発生すると、次のいずれかのエラー値が返ります。\r\n\r\n[table:ImmGetCompositionString_Table1]', 'アプリケーションでは通常、 メッセージまたは メッセージに応答してこの関数を呼び出します。この関数を使って取得できる情報は、ImmReleaseContext 関数を呼び出すと IMM により削除されます。', 'ImmSetCompositionFont|WM_IME_COMPOSITION|WM_IME_STARTCOMPOSITION', '2016-08-27 05:51:16', '2016-08-27 05:51:16', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447983.aspx', 'Microsoft', '', '', '', ''),
('ImmGetCompositionWindow', '関数', '変換ウィンドウに関する情報を取得します。', 'BOOL ImmGetCompositionWindow(\r\n  HIMC hIMC,\r\n  LPCOMPOSITIONFORM lpCompForm \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nlpCompForm --- 変換ウィンドウに関する情報を受け取る 構造体へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'ImmSetCompositionWindow|COMPOSITIONFORM', '2016-08-27 05:52:54', '2016-08-27 05:52:54', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447984.aspx', 'Microsoft', '', '', '', ''),
('ImmGetContext', '関数', '指定されたウィンドウに関連付けられている入力コンテキストを取得します。', 'HIMC ImmGetContext（\r\n  HWND hWnd \r\n);', 'hWnd --- 関連付けられている入力コンテキストを取得するウィンドウのハンドルを指定します。', '入力コンテキストのハンドルが返ります。', '入力コンテキストが持つ情報にアクセスする場合は、必ずその前にこの関数を呼び出して、現在の入力コンテキストを取得してください。', 'ImmReleaseContext', '2016-08-27 05:53:54', '2016-08-27 05:53:54', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447986.aspx', 'Microsoft', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('ImmGetConversionList', '関数', 'IME 関連のメッセージを一切生成せずに、文字または単語の変換結果一覧を取得します。', 'UINT ImmGetConversionList(\r\n  HKL hKL,\r\n  HIMC hIMC,\r\n  LPCTSTR lpSrc,\r\n  LPCANDIDATELIST lpDst,\r\n  DWORD dwBufLen,\r\n  UINT uFlag              \r\n);', 'hKL --- 入力ロケール識別子を指定します。\r\n///\r\nhIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nlpSrc --- NULL で終わるソース文字列（ 変換対象となる文字列）へのポインタを指定します。\r\n///\r\nlpDst --- 変換結果を受け取る 構造体へのポインタを指定します。\r\n///\r\ndwBufLen --- 変換結果を受け取るバッファのサイズをバイト単位で指定します。このパラメータに 0 を指定すると、要求した変換結果をすべて受け取るために必要となるバッファサイズが関数から返ります。\r\n///\r\nuFlag --- アクションフラグを指定します。このパラメータには、次のいずれかの値を指定できます。\r\n\r\n[table:ImmGetConversionList_Table1]', '指定したバッファにコピーされたデータのバイト数が返ります。dwBufLen パラメータに 0 を指定した場合は、要求した情報を受け取るために必要となるバッファサイズが返ります。', '', 'CANDIDATELIST', '2016-08-27 05:55:35', '2016-08-27 05:55:35', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447988.aspx', 'Microsoft', '', '', '', ''),
('ImmGetConversionStatus', '関数', '現在の変換状態を取得します。', 'BOOL ImmGetConversionStatus(\r\n  HIMC hIMC,\r\n  LPDWORD lpfdwConversion,\r\n  LPDWORD lpfdwSentence \r\n);', 'hIMC --- 対象となる入力コンテキストのハンドルを指定します。\r\n///\r\nlpfdwConversion --- 入力モード値の組み合わせを受け取る 32 ビット変数へのポインタを指定します。詳細については、「IME定数」の「IME変換モードの値」の表を参照してください。\r\n///\r\nlpfdwSentence --- 変換モードの値を受け取る 32 ビット変数へのポインタを指定します。詳細については、「IME定数」の「IMEセンテンスモードの値」の表を参照してください。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '入力モードと変換モードの値は、使っている IME がこれらのモードをサポートしている場合にしか設定されません。', 'ImmSetConversionStatus|IME Conversion Mode Values|IME Sentence Mode Values', '2016-08-27 05:56:53', '2016-08-27 05:56:53', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447990.aspx', 'Microsoft', '', '', '', ''),
('ImmGetDefaultIMEWnd', '関数', 'IME クラスの既定のウィンドウハンドルを取得します。', 'HWND ImmGetDefaultIMEWnd(\r\n  HWND hWnd \r\n);', 'hWnd --- アプリケーションのウィンドウハンドルを指定します。', '関数が成功すると、IME クラスの既定のウィンドウハンドルが返ります。\r\n 関数が失敗すると、NULL が返ります。', 'どのスレッドについても、必ず IME クラスを基にした既定の IME ウィンドウがシステムによって作成されます。アプリケーションは、このウィンドウに対して WM_IME_CONTROL を送信することができます。', 'WM_IME_CONTROL', '2016-08-27 05:57:53', '2016-08-27 05:57:53', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447992.aspx', 'Microsoft', '', '', '', ''),
('ImmGetDescription', '関数', 'IME を説明する文字列を指定されたバッファにコピーします。', 'UINT ImmGetDescription(\r\n  HKL hKL,\r\n  LPTSTR lpszDescription,\r\n  UINT uBufLen             \r\n);', 'hKL --- 入力ロケール識別子を指定します。\r\n///\r\nlpszDescription --- IME の説明文（NULL で終わる文字列）を受け取るバッファへのポインタを指定します。\r\n///\r\nuBufLen --- バッファのサイズを文字数で指定します。このパラメータに 0 を指定すると、説明文全体を受け取るために必要となるバッファサイズ（ ただし最後の NULL 文字は含まない）が関数から返ります。 \r\n\r\nWindows NT/2000：バッファのサイズは、Unicode 文字の文字数となります（1 文字が 2 バイト）。', 'バッファにコピーされた文字の数が返ります。uBufLen パラメータに 0 を指定した場合は、説明文を受け取るのに必要となるバッファサイズ（ 文字数）が返ります。どちらの場合も、最後の NULL 文字は含まれません。', '', '', '2016-08-27 05:59:13', '2016-08-27 05:59:13', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447994.aspx', 'Microsoft', '', '', '', ''),
('ImmGetGuideLine', '関数', 'エラーに関する情報を取得します。この関数により取得した情報は、アプリケーションのユーザーにエラー情報を知らせるために使います。', 'DWORD ImmGetGuideLine(\r\n  HIMC hIMC,\r\n  DWORD dwIndex,\r\n  LPTSTR lpBuf,\r\n  DWORD dwBufLen \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\ndwIndex --- 取得するガイドライン情報の種類を指定します。このパラメータには、次のいずれかの値を指定できます。\r\n\r\n[table:ImmGetGuideLine_Table1]\r\n///\r\nlpBuf --- エラーメッセージの文字列を受け取るバッファへのポインタを指定します。dwIndex パラメータに GGL_STRING も GGL_PRIVATE も指定しない場合は、このパラメータは NULL にしてかまいません。この場合、dwBufLen パラメータには 0 を指定します。\r\n///\r\ndwBufLenlpBuf --- パラメータに指定したポインタが指すバッファのサイズをバイト単位で指定します。このパラメータに 0 を指定すると、エラーメッセージの文字列を受け取るために必要となるバッファサイズ（ ただし最後の NULL 文字は含まない）が関数から返ります。', 'dwIndex パラメータに指定した値に応じて、エラーレベル、エラーインデックス、エラーメッセージ文字列のサイズのいずれかが返ります。dwIndex パラメータに GGL_LEVEL を指定した場合は、次のいずれかの値が返ります。\r\n\r\n[table:ImmGetGuideLine_Table2]\r\n\r\ndwIndex パラメータに GGL_INDEX を指定した場合は、次のいずれかの値が返ります。\r\n\r\n[table:ImmGetGuideLine_Table3]\r\n\r\ndwIndex パラメータに GGL_STRING を指定した場合は、バッファにコピーされた文字列のバイト数が関数から返ります。または、dwBufLen パラメータに 0 を指定した場合は、文字列を受け取るために必要となるバッファサイズが返ります。\r\n\r\ndwIndex パラメータに GGL_PRIVATE を指定した場合は、バッファにコピーされた情報のバイト数が返ります。この場合も、dwBufLen パラメータに 0 を指定した場合は、情報を受け取るために必要となるバッファサイズが返ります。', 'アプリケーションでは通常、IMN_GUIDELINE メッセージを受け取ったときにこの関数を呼び出します。', '', '2016-08-27 06:01:35', '2016-08-27 06:01:35', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc447997.aspx', 'Microsoft', '', '', '', ''),
('ImmGetHotKey', '関数', 'ImmGetHotKey 関数は、IME ホットキーの値を取得する。', 'BOOL WINAPI ImmGetHotKey(\r\n    DWORD  dwHotKeyID,\r\n    LPUINT lpuModifiers,\r\n    LPUINT lpuVKey,\r\n    LPHKL  lphKL)', 'dwHotKeyID --- ホットキー識別子。\r\n///\r\nlpuModifiers --- ホットキーの組み合わせキー。ALT (MOD_ALT)、CTRL (MOD_CONTROL)、 SHIFT (MOD_SHIFT)、左側 (MOD_LEFT)、右側 (MOD_RIGHT)を含む。キーアップフラグ (MOD_ON_KEYUP) はホットキーがキーの上がっているとき有効であることを示す。モディファイアー無視フラグ(MOD_IGNORE_ALL_MODIFIER) は、モディファイアーの組み合わせがホットキーマッチングにおいて無視されることを示す。\r\n///\r\nlpuVKey --- このホットキーの仮想キーコード。\r\n///\r\nlphKL --- IME の HKL。もしこの引数の戻り値が NULL でなければ、ホットキーは、この HKL の IME に切り替えることができる。', '関数が成功すれば、戻り値は TRUE。さもなければ戻り値は FALSE である。', 'この関数はコントロールパネルから呼ばれる。', 'ImmSetHotKey', '2016-08-29 06:14:47', '2016-08-29 06:14:47', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmGetIMCCLockCount', '関数', 'ImmGetIMCCLockCount 関数は、IMCC のロックカウントを取得するのに使われる。', 'DWORD WINAPI ImmGetIMCCLockCount(HIMCC hIMCC)', 'hIMCC --- IMC コンポーネントのハンドル。', '関数が成功すれば、戻り値は IMCC のロックカウントである。さもなければ、戻り値はゼロである。', '', 'ImmLockIMCC|ImmUnlockIMCC', '2016-08-29 06:14:24', '2016-08-29 06:14:24', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmGetIMCCSize', '関数', 'ImmGetIMCCSize 関数は、IMCC のサイズを取得するのに使われる。', 'DWORD WINAPI ImmGetIMCCSize(HIMCC hIMCC)', 'hIMCC --- IMC コンポーネントのハンドル。', 'IMCC のサイズ。', '', 'ImmCreateIMCC', '2016-08-29 06:13:30', '2016-08-29 06:13:30', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmGetIMCLockCount', '関数', 'ImmGetIMCLockCount 関数は、IMC のロックカウントを取得するのに使われる。', 'HIMCC WINAPI ImmGetIMCLockCount(HIMC hIMC)', 'hIMC --- 入力コンテキストのハンドル。', '関数が成功すれば、戻り値は IMC のロックカウントである。さもなければ NULL である。', '', 'ImmLockIMC|ImmInlockIMC', '2016-08-29 06:07:58', '2016-08-29 06:07:58', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmGetIMEFileName', '関数', '指定された入力ロケールに関連付けられている IME のファイル名を取得します。', 'BOOL ImmGetIMEFileName(\r\n  HKL hKL,\r\n  LPTSTR lpszFileName,\r\n  UINT uBufLen          \r\n);', 'hKL --- 入力ロケール識別子を指定します。\r\n///\r\nlpszFileName --- ファイル名を受け取るバッファへのポインタを指定します。\r\n///\r\nuBufLen --- バッファのサイズをバイト単位で指定します。このパラメータに 0 を指定すると、ファイル名を受け取るために必要となるバイト単位のバッファサイズ（ ただし最後の NULL 文字は含まない）が関数から返ります。', 'バッファにコピーされたファイル名のバイト数が返ります。uBufLen パラメータに 0 を指定した場合は、ファイル名を受け取るために必要となるバッファサイズが返ります。どちらの場合も、最後の NULL 文字は含まれません。', 'この関数によって返されるファイル名は、レジストリ内の HKEY_LOCAL_MACHINE をルートとする \\System\\CurrentControlSet\\control\\keyboard layouts\\hKL キーに IME file という値として格納されています。', '', '2016-08-27 06:05:32', '2016-08-27 06:05:32', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448001.aspx', 'Microsoft', '', '', '', ''),
('ImmGetImeMenuItems', '関数', 'IME メニューに登録されているメニュー項目を取得します。', 'DWORD WINAPI ImmGetImeMenuItems(\r\n  HIMC hIMC,\r\n  DWORD dwFlags,\r\n  DWORD dwType,\r\n  LPIMEMENUITEMINFO lpImeParentMenu,\r\n  LPIMEMENUITEMINFO lpImeMenu,\r\n  DWORD dwSize\r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\ndwFlags --- メニュー情報フラグを指定します。定義されている値は次のとおりです。\r\n\r\n[table:ImmGetImeMenuItems_Table1]\r\n///\r\ndwType --- 取得するメニューの種類を指定します。このパラメータには、次の値を組み合わせて指定することができます。 \r\n\r\n[table:ImmGetImeMenuItems_Table2]\r\n///\r\nlpImeParentMenu --- 親メニューへのポインタを指定します。この親メニューのサブメニュー項目に関する情報を受け取るには、ここに指定するポインタが指す 構造体の fType メンバを MFT_SUBMENU に設定しておいてください。このパラメータが NULL になっていると、トップレベルのメニュー項目しか取得できません。\r\n///\r\nlpImeMenu --- メニュー項目の内容を受け取るバッファへのポインタを指定します。このバッファには、複数の 構造体からなる 1 つの配列が格納されます。このパラメータに NULL を指定すると、該当するメニュー項目の数が返ります。\r\n///\r\ndwSize --- IMEMENUITEMINFO 構造体を受け取るバッファのサイズを指定します。', 'lpImeMenu パラメータで指定したバッファにコピーされたメニュー項目の数が返ります。lpImeMenu パラメータに NULL を指定した場合は、登録されているメニュー項目の数が返ります。', '', 'IMEMENUITEMINFO', '2016-08-27 06:07:25', '2016-08-27 06:07:25', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448002.aspx', 'Microsoft', '', '', '', ''),
('ImmGetOpenStatus', '関数', 'IME が開いているかどうかを調べます。', 'BOOL WINAPI ImmGetOpenStatus(\r\n  HIMC hIMC\r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。', 'IME が開いていれば 0 以外の値が返り、それ以外の場合は 0 が返ります。', '', 'ImmSetOpenStatus', '2016-08-27 06:09:34', '2016-08-27 06:09:34', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448004.aspx', 'Microsoft', '', '', '', ''),
('ImmGetProperty', '関数', '指定された入力ロケールに関連付けられている IME のプロパティや機能に関する情報を取得します。', 'BOOL ImmGetProperty(\r\n  HKL hKL,\r\n  DWORD fdwIndex \r\n);', 'hKL --- 入力ロケール識別子を指定します。\r\n///\r\nfdwIndex --- 取得する情報の種類を指定します。次のいずれかの値を指定できます。 \r\n\r\n[table:ImmGetProperty_Table1]', 'dwIndex パラメータに指定した値に応じて、プロパティまたは機能の値が返ります。dwIndex パラメータに IGP_PROPERTY を指定した場合、次の値を組み合わせた戻り値が返ります。\r\n\r\n[table:ImmGetProperty_Table2]\r\n\r\ndwIndex パラメータに IGP_UI を指定した場合、次の値を組み合わせた戻り値が返ります。\r\n\r\n[table:ImmGetProperty_Table3]\r\n\r\ndwIndex パラメータに IGP_SETCOMPSTR を指定した場合、次の値を組み合わせた戻り値が返ります。\r\n\r\n[table:ImmGetProperty_Table4]\r\n\r\ndwIndex パラメータに IGP_SELECT を指定した場合、次の値を組み合わせた戻り値が返ります。\r\n\r\n[table:ImmGetProperty_Table5]\r\n\r\ndwIndex パラメータに IGP_GETIMEVERSION を指定した場合は、次の値のいずれかが返ります。\r\n\r\n[table:ImmGetProperty_Table6]', '', '', '2016-08-27 06:11:37', '2016-08-27 06:11:37', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448006.aspx', 'Microsoft', '', '', '', ''),
('ImmGetRegisterWordStyle', '関数', '指定された入力ロケールに関連付けられている IME がサポートする品詞の一覧を取得します。', 'UINT ImmGetRegisterWordStyle(\r\n  HKL hKL,\r\n  UINT nItem,\r\n  LPSTYLEBUF lpStyleBuf \r\n);', 'hKL --- 入力ロケール識別子を指定します。\r\n/// \r\nnItem --- バッファに格納できる品詞の最大数を指定します。\r\n///\r\nlpStyleBuf --- 品詞情報を受け取る 構造体へのポインタを指定します。', 'バッファにコピーされた品詞の数が返ります。nItems パラメータに 0 を指定した場合は、取得可能なすべての品詞情報を受け取るために必要となるバッファサイズ（ 配列要素数）が返ります。', '', 'STYLEBUF', '2016-08-27 06:16:47', '2016-08-27 06:16:47', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448008.aspx', 'Microsoft', '', '', '', ''),
('ImmGetStatusWindowPos', '関数', 'ステータスウィンドウの位置を取得します。', 'BOOL ImmGetStatusWindowPos(\r\n  HIMC hIMC,\r\n  LPPOINT lpptPos \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nlpptPos --- 位置座標を受け取る 構造体へのポインタを指定します。この構造体には、スクリーン座標系での画面の左上隅に対する相対座標が格納されます。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'ImmSetStatusWindowPos', '2016-08-27 06:17:40', '2016-08-27 06:17:40', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448010.aspx', 'Microsoft', '', '', '', ''),
('ImmGetVirtualKey', '関数', 'IME によって既に処理されたキー入力メッセージに関連付けられていた元の仮想キーコードを回復させます。', 'UINT ImmGetVirtualKey(\r\n  HWND hWnd \r\n);', 'hWnd --- キーメッセージを受け取ったウィンドウのハンドルを指定します。', '元の仮想キーコードが返ります。', 'IME は、キー入力メッセージを処理し終えたら仮想キーコードを VK_PROCESSKEY に設定しますが、ImmGetVirtualKey 関数を呼び出せば元の仮想キーコードを回復させることができます。この関数は、コードが VK_PROCESSKEY になっているキー入力メッセージにしか使えません。', 'WM_KEYDOWN', '2016-08-27 06:18:35', '2016-08-27 06:18:35', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448012.aspx', 'Microsoft', '', '', '', ''),
('ImmInstallIME', '関数', 'IME をシステムにインストールします。', 'HKL ImmInstallIME(\r\n  LPCTSTR lpszIMEFileName,\r\n  LPCTSTR lpszLayoutText \r\n);', 'lpszIMEFileName --- IME の完全パスを格納した NULL で終わる文字列へのポインタを指定します。\r\n///\r\nlpszLayoutText --- IME の名前を格納した NULL で終わる文字列へのポインタを指定します。この名前により、IME のレイアウトテキストも決まります。', 'インストールした IME の入力ロケール識別子が返ります。', 'この関数は、IME セットアッププログラム用に用意されたものです。', 'ImeInquire', '2016-08-27 06:19:33', '2016-08-27 06:19:33', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448014.aspx', 'Microsoft', '', '', '', ''),
('ImmIsIME', '関数', '指定された入力ロケールが IME を持つかどうかを調べます。', 'BOOL ImmIsIME(\r\n  HKL hKL \r\n);', 'hKL --- 入力ロケール識別子を指定します。', '指定した入力ロケールが IME を持っている場合は、0 以外の値が返ります。\r\n 持っていない場合は、0 が返ります。', '', '', '2016-08-27 06:20:33', '2016-08-27 06:20:33', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448016.aspx', 'Microsoft', '', '', '', ''),
('ImmIsUIMessage', '関数', '指定されたメッセージが IME ウィンドウに送られるべきものかどうかを調べてから、そのメッセージを指定されたウィンドウへ送信します。', 'BOOL ImmIsUIMessage(\r\n  HWND hWndIME,\r\n  UINT msg,\r\n  WPARAM wParam,\r\n  LPARAM lParam  \r\n);', 'hWndIME --- IME ウィンドウクラスに属するウィンドウのハンドルを指定します。\r\n///\r\nmsg --- 調べるメッセージを指定します。\r\n///\r\nwParam --- 指定したメッセージ用の 32 ビットのパラメータを指定します。\r\n///\r\nlParam --- 指定したメッセージ用の 32 ビットのパラメータを指定します。', 'メッセージが IME ウィンドウによって処理される場合は、0 以外の値が返ります。\r\nメッセージが IME ウィンドウによって処理されない場合は、0 が返ります。', 'アプリケーションでは通常、IME によって指定された変換文字列や候補一覧を表示するためにこの関数を使います。hWndIME パラメータに NULL を指定すると、この関数は、指定されたメッセージがユーザーインターフェイスメッセージかどうかを調べます。', '', '2016-08-27 06:21:45', '2016-08-27 06:21:45', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448018.aspx', 'Microsoft', '', '', '', ''),
('ImmLockClientImc', '関数', '入力コンテキストをロックする関数です。', 'PCLIENTIMC WINAPI ImmLockClientImc(_In_ HIMC hImc);', 'hImc --- ロックしたい入力コンテキストのハンドル。', 'CLIENTIMC構造体へのポインタ。', 'ロックされた入力コンテキストは、ImmUnlockClientImcでアンロックする必要があります。', 'CLIENTIMC|ImmUnlockClientImc', '2024-08-14 00:23:21', '2024-08-14 00:23:21', '<imm32_undoc.h>', 'imm32.dll', 'katahiromzによる分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmLockIMC', '関数', 'ImmLockIMC 関数は、IMC に対するロックカウントを１だけ増やす。IME が INPUTCONTEXT を参照する\r\n必要があるとき、IME は INPUTCONTEXT 構造体のポインタを取得するためにこの関数を呼び出す。', 'LPINPUTCONTEXT WINAPI ImmLockIMC(HIMC hIMC)', 'hIMC --- 入力コンテキストのハンドル。', '関数が成功すれば、INPUTCONTEXT 構造体へのポインタを返す。さもなければ NULL を返す。', '', 'ImmUnlockIMC|INPUTCONTEXT', '2016-08-29 06:05:47', '2016-08-29 06:05:47', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmLockIMCC', '関数', 'ImmLockIMCC 関数は、IMC のメンバーとして作成された IMC コンポーネントへのポインタを取得するた\r\nめに IME によって使われる。ImmLockIMC は、IMCC に対するロックカウントを１だけ増加させる。', 'LPVOID WINAPI ImmLockIMCC(HIMCC hIMCC)', 'hIMCC --- IMC コンポーネントのハンドル。', '関数が成功すれば、戻り値は、IMC コンポーネントへのポインタ。さもなければ戻り値は NULL である。', '', 'ImmUnlockIMCC', '2016-08-29 06:10:42', '2016-08-29 06:10:42', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmLockImeDpi', '関数', 'HKLを使ってIME DPI (device programming interface)をロックします。', 'PIMEDPI WINAPI ImmLockImeDpi(_In_ HKL hKL);', 'hKL --- キーボードレイアウトのハンドルです。', 'IMEDPI構造体へのポインタ。', 'IMMシステムは、IME DPIの中身にアクセスする前にロックします。ロックが完了した後はImmUnlockImeDpiでアンロックする必要があります。', 'IMEDPI|ImmUnlockImeDpi', '2024-08-13 11:28:30', '2024-08-13 11:28:30', '<imm32_undoc.h>', 'imm32.dll', 'katahiromzによる分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmNotifyIME', '関数', '入力コンテキストの状態の変更に関する情報を IME に知らせます。', 'BOOL ImmNotifyIME(\r\n  HIMC hIMC,\r\n  DWORD dwAction,\r\n  DWORD dwIndex,\r\n  DWORD dwValue   \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\ndwAction --- 通知コードを指定します。このパラメータには、次のいずれかの値を指定できます。\r\n\r\n[table:ImmNotifyIME_Table1]\r\n///\r\ndwIndex --- 候補一覧のインデックスを指定します。dwAction パラメータに NI_COMPOSITIONSTR を指定した場合は、次のいずれかの値を指定します。\r\n\r\n[table:ImmNotifyIME_Table2]\r\n///\r\ndwValuedwAction --- パラメータに指定した値に応じて、候補文字列のインデックスを指定するか、または何も指定しません。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'NotifyIME|NI_CHANGECANDIDATELIST|NI_CLOSECANDIDATE|NI_COMPOSITIONSTR|NI_CONTEXTUPDATED|NI_OPENCANDIDATE|NI_SELECTCANDIDATESTR|NI_SETCANDIDATE_PAGESIZE|NI_SETCANDIDATE_PAGESTART', '2016-08-27 06:25:09', '2016-08-27 06:25:09', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448020.aspx', 'Microsoft', '', '', '', ''),
('ImmProcessKey', '関数', 'キー入力とIMEホットキーを処理する関数です。', 'DWORD WINAPI\r\nImmProcessKey(HWND hWnd, HKL hKL, UINT vKey, LPARAM lParam, DWORD dwHotKeyID)', 'hWnd --- ウィンドウのハンドルです。\r\n///\r\nhKL --- キーボードレイアウトのハンドルです。\r\n///\r\nvKey --- 仮想キーです。\r\n///\r\nlParam --- LPARAM の値です。\r\n///\r\ndwHotKeyID --- ホットキーのIDです。-1のときは無効です。', 'IPHK_... フラグ群を返します。', '', '', '2024-08-14 01:17:55', '2024-08-14 01:17:55', '<imm32_undoc.h>', 'imm32.dll', 'katahiromzによる分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmRegisterClient', '関数', 'imm32.dll読み込み時にuser32.dllから呼び出される関数です。', 'BOOL WINAPI ImmRegisterClient(PSHAREDINFO ptr, HINSTANCE hMod)', 'ptr --- 共有情報。\r\n///\r\nhMod --- imm32.dllのインスタンスのハンドル。', '成功すればTRUEを返します。', 'この関数は、imm32.dllにuser32.dllを登録し、クライアント側で管理されているハンドルにアクセスできるようにします。', '', '2024-08-14 01:26:13', '2024-08-14 01:26:13', '', 'imm32.dll', 'katahiromzによる分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmRegisterWord', '関数', '指定された入力ロケールに関連付けられている IME の辞書に文字列を登録します。', 'BOOL ImmRegisterWord(\r\n  HKL hKL,\r\n  LPCTSR lpszReading,\r\n  DWORD dwStyle,\r\n  LPCTSTR lpszRegister \r\n);', 'hKL --- 入力ロケール識別子を指定します。\n/// \nlpszReading --- 登録する文字列の読み文字列を格納した NULL で終わる文字列へのポインタを指定します。\n///\ndwStyle --- 登録文字列の品詞を指定します。登録文字列が EUDC の範囲内にあることを示すには、IME_REGWORD_STYLE_EUDC を指定します。指定した IME によって管理されている、その IME にプライベートな品詞を指定する場合は、IME_REGWORD_STYLE_USER_FIRST から IME_REGWORD_STYLE_USER_LAST までの予約範囲内の値を指定します。\n///\nlpszRegister --- 登録文字列を格納した NULL で終わる文字列へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'ImmUnregisterWord', '2016-08-27 06:27:43', '2016-08-27 06:27:43', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448022.aspx', 'Microsoft', '', '', '', ''),
('ImmReleaseContext', '関数', '入力コンテキストを解放し、コンテキスト内の関連メモリのロックを解除します。アプリケーションで ImmGetContext 関数を呼び出したら、必ず対応する ImmReleaseContext 関数を呼び出さなければなりません。', 'BOOL ImmReleaseContext(\r\n  HWND hWnd,\r\n  HIMC hIMC   \r\n);', 'hWnd --- 入力コンテキストを取得するために ImmGetContext 関数を呼び出したときに指定したウィンドウハンドルを指定します。\r\n///\r\nhIMC --- 入力コンテキストのハンドルを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'ImmGetContext', '2016-08-27 06:28:48', '2016-08-27 06:28:48', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448025.aspx', 'Microsoft', '', '', '', ''),
('ImmReSizeIMCC', '関数', 'ImmReSizeIMCC 関数は、コンポーネントのサイズを変更する。', 'HIMCC WINAPI ImmReSizeIMCC(\r\n    HIMCC hIMCC,\r\n    DWORD dwSize)', 'hIMCC --- IMC コンポーネントのハンドル。\r\n///\r\ndwSize --- IMC コンポーネントの新しいサイズ。', '関数が成功すれば、戻り値は HIMCC の新しい値である。さもなければ戻り値は NULL である。', '', 'ImmCreateIMCC', '2016-08-29 06:12:40', '2016-08-29 06:12:40', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmSetCandidateWindow', '関数', '候補一覧ウィンドウに関する情報を設定します。', 'BOOL ImmSetCandidateWindow(\r\n  HIMC hIMC,\r\n  LPCANDIDATEFORM lpCandidate \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nlpCandidate --- 候補一覧ウィンドウに関する情報を格納した 構造体へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', 'ImmSetCandidateWindow 関数を呼び出すと、IMN_SETCANDIDATEPOS メッセージがアプリケーションへ送信されます。', 'ImmGetCandidateWindow|CANDIDATEFORM|IMN_SETCANDIDATEPOS', '2016-08-27 06:29:57', '2016-08-27 06:29:57', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448027.aspx', 'Microsoft', '', '', '', ''),
('ImmSetCompositionFont', '関数', '変換ウィンドウに表示する文字に使う論理フォントを設定します。', 'BOOL ImmSetCompositionFont(\r\n  HIMC hIMC,\r\n  LPLOGFONT lplf \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nlplf --- 設定するフォントに関する情報を格納した LOGFONT 構造体へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '変換ウィンドウを使わないアプリケーションの場合でも、文字が正しく表示されることを保証するためには、必ず適切なフォントを設定しなければなりません。このことは、仮想ライティングを行う場合に特に当てはまります。\r\nこの関数を呼び出すと、アプリケーションに IMN_SETCOMPOSITIONFONT メッセージが送信されます。', 'ImmGetCompositionFont|IMN_SETCOMPOSITIONFONT', '2016-08-27 06:31:05', '2016-08-27 06:31:05', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448029.aspx', 'Microsoft', '', '', '', ''),
('ImmSetCompositionString', '関数', '変換文字列および読み文字列の文字、属性、または文節を設定します。', 'BOOL ImmSetCompositionString(\r\n  HIMC hIMC,\r\n  DWORD dwIndex,\r\n  LPCVOID lpComp,\r\n  DWORD dwCompLen,\r\n  LPCVOID lpRead,\r\n  DWORD dwReadLen  \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\ndwIndex --- 設定する情報の種類を指定します。次のいずれかの値を指定できます。\r\n\r\n[table:ImmSetCompositionString_Table1]\r\n///\r\nlpComp --- 変換文字列に対して設定する情報を格納したバッファへのポインタを指定します。このパラメータに渡す情報の種類は、dwIndex パラメータで指定します。\r\n///\r\ndwCompLen --- 変換文字列用の情報バッファのサイズ（ バイト単位）を指定します。\r\n///\r\nlpRead --- 読み文字列に対して設定する情報を格納したバッファへのポインタを指定します。このパラメータに渡す情報の種類は、dwIndex パラメータで指定します。\r\n///\r\ndwReadLen --- 読み文字列用の情報バッファのサイズ（ バイト単位）を指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '属性を変更する場合、同一文節内の文字はすべて同じ属性にしなければなりません。変換済み文字の属性は、ATTR_CONVERTED または ATTR_TARGET_CONVERTED、未変換文字の属性は ATTR_INPUT または ATTR_TARGET_NOTCONVERTED になります。\r\n 文節情報を変更する場合、変更できるのは対象文節（ 文節カーソルが位置する文節）だけで、1 度に 1 つの境界位置しか変更できません。対象文節の属性は、ATTR_TARGET_CONVERTED または ATTR_TARGET_NOTCONVERTED になります。\r\nIME は、指定された変更を完了したら、アプリケーションに WM_IME_COMPOSITION メッセージを送信して変更が完了したことを知らせます。\r\n\r\nWindows 98 および Windows 2000：SCS_*CONVERTSTRING という値を使って再変換を行うことができます。この値は、SCS_CAP_SETRECONVERTSTRING プロパティを持つ IME にしか使えません。この値を使う場合は、まず、SCS_QUERYRECONVERTSTRING を指定して ImmSetCompositionString 関数を呼び出し、再変換が可能になるように IME に RECONVERTSTRING 構造体を調整させます。次に、SCS_SETRECONVERTSTRING を指定して ImmSetCompositionString 関数を呼び出し、IME に新しい変換文字列を生成させます。以上を行うと、パラメータ lpComp と lpRead のポインタは、更新後の変換文字列と読み文字列を格納した RECONVERTSTRING 構造体を指しています。lpRead パラメータが使えるのは、選択している IME で SCS_CAP_MAKEREAD がセットされている場合だけです。lpRead パラメータには NULL を指定してもかまいません。', 'ImmGetCompositionString|WM_IME_COMPOSITION|RECONVERTSTRING', '2016-08-27 06:33:15', '2016-08-27 06:33:15', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448031.aspx', 'Microsoft', '', '', '', ''),
('ImmSetCompositionWindow', '関数', '変換ウィンドウの位置を設定します。', 'BOOL ImmSetCompositionWindow(\r\n  HIMC hIMC,\r\n  LPCOMPOSITIONFORM lpCompForm \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nlpCompForm --- 変換ウィンドウの新しい位置およびその他の関連情報を格納した COMPOSITIONFORM 構造体へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'ImmGetCompositionWindow|COMPOSITIONFORM|IMN_SETCOMPOSITIONWINDOW', '2016-08-27 06:34:38', '2016-08-27 06:34:38', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448033.aspx', 'Microsoft', '', '', '', ''),
('ImmSetConversionStatus', '関数', '現在の変換状態を設定します。', 'BOOL ImmSetConversionStatus(\r\n  HIMC hIMC,\r\n  DWORD fdwConversion,\r\n  DWORD fdwSentence     \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nfdwConversion --- 入力モードの値を指定します。詳細については、「IME定数」の「IME変換モードの値」の表を参照してください。\r\n///\r\nfdwSentence --- 変換モードの値を指定します。詳細については、「IME定数」の「IMEセンテンスモードの値」の表を参照してください。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', 'この関数を呼び出すと、アプリケーションに IMN_SETCONVERSIONSTATUS メッセージが送信されます。', 'ImmGetConversionStatus|IME Conversion Mode Values|IME Sentence Mode Values|IMN_SETCONVERSIONMODE|IMN_SETSENTENCEMODE', '2016-08-27 06:35:52', '2016-08-27 06:35:52', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448035.aspx', 'Microsoft', '', '', '', ''),
('ImmSetHotKey', '関数', 'ImmSetHotKey 関数は、IME ホットキーの値をセットする。', 'BOOL WINAPI ImmSetHotKey(\r\n    DWORD dwHotKeyID,\r\n    UINT  uModifiers,\r\n    UINT  uVKey,\r\n    HKL   hKL)', 'dwHotKeyID --- ホットキーの識別子。\r\n///\r\nuModifiers --- ホットキーの組み合わせキー。ALT (MOD_ALT)、CTRL (MOD_CONTROL)、 SHIFT (MOD_SHIFT)、左側 (MOD_LEFT)、右側 (MOD_RIGHT)を含む。キーアップフラグ (MOD_ON_KEYUP) はホットキーがキーの上がっているとき有効であることを示す。モディファイアー無視フラグ(MOD_IGNORE_ALL_MODIFIER) は、モディファイアーの組み合わせが\r\nホットキーマッチングにおいて無視されることを示す。\r\n///\r\nuVKey --- このホットキーの仮想キーコード。\r\n///\r\nhKL --- IME の HKL。この引数が指定されると、ホットキーはこの HKL の IME に切り替えることができる。', '関数が成功すれば、戻り値は TRUE。さもなければ戻り値は FALSE である。', 'この関数は、コントロールパネルから呼ばれる。特定のキーボードの側を指定しないキーについては\r\nuModifiers は両側（MOD_LEFT | MODE_RIGHT）を指定すべきだ。', 'ImmGetHotKey', '2016-08-29 06:17:32', '2016-08-29 06:17:32', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmSetOpenStatus', '関数', 'IME を開いたり閉じたりします。', 'BOOL ImmSetOpenStatus(\r\n  HIMC hIMC,\r\n  BOOL fOpen\r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nfOpen --- ブール値のフラグを指定します。TRUE を指定すると IME が開かれ、FALSE を指定すると IME が閉じられます。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', 'この関数を呼び出すと、アプリケーションに IMN_SETOPENSTATUS メッセージが送信されます。', 'ImmGetOpenStatus|IMN_SETOPENSTATUS', '2016-08-27 06:36:55', '2016-08-27 06:36:55', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448037.aspx', 'Microsoft', '', '', '', ''),
('ImmSetStatusWindowPos', '関数', 'ステータスウィンドウの位置を設定します。', 'BOOL ImmSetStatusWindowPos(\r\n  HIMC hIMC,\r\n  LPPOINT lpptPos \r\n);', 'hIMC --- 入力コンテキストのハンドルを指定します。\r\n///\r\nlpptPos --- ステータスウィンドウの新しい位置の情報を格納した 構造体へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', 'ImmSetStatusWindowPos 関数を呼び出すと、アプリケーションに IMN_SETSTATUSWINDOWPOS メッセージが送信されます。', 'ImmGetStatusWindowPos|IMN_SETSTATUSWINDOWPOS', '2016-08-27 06:37:53', '2016-08-27 06:37:53', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448039.aspx', 'Microsoft', '', '', '', ''),
('ImmShowSoftKeyboard', '関数', 'ImmShowSoftKeyboard 関数は、与えられたソフトキーボードを表示するか、または隠す。', 'BOOL WINAPI ImmShowSoftKeyboard(\r\n    HWND hSoftKbdWnd,\r\n    int nCmdShow)', 'hSoftKbdWnd --- ソフトキーボードのウィンドウハンドル。\r\n///\r\nnCmdShow --- ウィンドウの状態を表す。以下の値が与えられる。\r\n\r\n[table:ImmShowSoftKeyboard_Table1]', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'ImmCreateSoftKeyboard', '2016-08-29 06:21:26', '2016-08-29 06:21:26', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmSimulateHotKey', '関数', '指定された IME ホットキーをシミュレートし、指定されたウィンドウでユーザーがあたかもそのホットキーを押したかのような応答をします。', 'BOOL ImmSimulateHotKey(\r\n  HWND hWnd,\r\n  DWORD dwHotKeyID \r\n);', 'hWnd --- ウィンドウのハンドルを指定します。\r\n///\r\ndwHotKeyIDIME --- ホットキーの識別子を指定します。このパラメータには、「IME定数」の「IMEホットキー識別子」の表に示されている値のいずれかを指定できます。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'IME Hot Key Identifiers', '2016-08-27 06:38:53', '2016-08-27 06:38:53', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448041.aspx', 'Microsoft', '', '', '', ''),
('ImmUnlockClientImc', '関数', '入力コンテキストをアンロックする関数です。', 'VOID WINAPI ImmUnlockClientImc(_Inout_ PCLIENTIMC pClientImc);', 'pClientImc --- ロックされた入力コンテキストへのポインタ。', '戻り値はありません。', '', 'CLIENTIMC|ImmLockClientImc', '2024-08-14 00:27:46', '2024-08-14 00:27:46', '<imm32_undoc.h>', 'imm32.dll', 'katahiromzによる分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmUnlockIMC', '関数', 'ImmUnlockIMC 関数は、IMC に対するロックカウントを１だけ減らす。', 'BOOL WINAPI ImmUnlockIMC(HIMC hIMC)', 'hIMC --- 入力コンテキストのハンドル。', 'ロックカウントがゼロになったら、戻り値は FALSE である。さもなければ戻り値は TRUE である。', '', 'ImmLockIMC', '2016-08-29 06:06:48', '2016-08-29 06:06:48', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmUnlockIMCC', '関数', 'ImmUnlockIMC 関数は、IMCC に対するロックカウントを１だけ減少させる。', 'BOOL WINAPI ImmUnlockIMCC(HIMCC hIMCC)', 'hIMCC --- IMC コンポーネントのハンドル。', 'もしロックカウントがゼロになれば、戻り値は FALSE である。さもなければ戻り値は TRUE である。', '', 'ImmLockIMCC', '2016-08-29 06:11:29', '2016-08-29 06:11:29', '<immdev.h>', 'imm32.dll', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmUnlockImeDpi', '関数', 'IME DPI (device programming interface)をアンロックします。', 'VOID WINAPI ImmUnlockImeDpi(_Inout_ PIMEDPI pImeDpi);', 'pImeDpi --- アンロックしたい IMEDPI 構造体へのポインタです。', '戻り値はありません。', 'ImmLockImeDpi でロックした IME DPI は ImmUnlockImeDpi でアンロックする必要があります。', 'IMEDPI|ImmLockImeDpi', '2024-08-13 11:33:18', '2024-08-13 11:33:18', '<imm32_undoc.h>', 'imm32.dll', 'katahiromz による分析。', 'Katayama Hirofumi MZ', '', '', '', ''),
('ImmUnregisterWord', '関数', '指定された入力ロケールに関連付けられている IME の辞書から指定された登録文字列を削除します。', 'BOOL ImmUnregisterWord(\r\n  HKL hKL,\r\n  LPCTSTR lpszReading,\r\n  DWORD dwStyle,\r\n  LPCTSTR lpszUnregister\r\n);', 'hKL --- 入力ロケール識別子を指定します。\r\n///\r\nlpszReading --- 削除する登録文字列の読み文字列を格納した NULL で終わる文字列へのポインタを指定します。\r\n///\r\ndwStyle --- 削除する登録文字列の品詞を指定します。削除する登録文字列が EUDC の範囲内にある登録文字列であることを示すには、IME_REGWORD_STYLE_EUDC を指定します。指定した IME によって管理されている、その IME にプライベートな品詞を指定する場合は、IME_REGWORD_STYLE_USER_FIRST から IME_REGWORD_STYLE_USER_LAST までの予約範囲内の値を指定します。\r\n///\r\nlpszUnregister --- 削除する登録文字列を格納した NULL で終わる文字列へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n 関数が失敗すると、0 が返ります。', '', 'ImmRegisterWord', '2016-08-27 06:40:05', '2016-08-27 06:40:05', '<imm.h>', 'imm32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc448043.aspx', 'Microsoft', '', '', '', ''),
('IMN_CHANGECANDIDATE', '通知コード', 'IMEが候補ウィンドウの内容を変更しようとしていることをアプリに通知します。アプリはこのコマンドを以下に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じて受け取ります。', 'IMN_CHANGECANDIDATE', 'wParam --- IMN_CHANGECANDIDATEにセットします。\r\n///\r\nlParam --- 候補リスト フラグ。それぞれのビットは、一つの候補リストに対応します。ビット0は最初のリスト、ビット1は二番目のリスト、と続きます。もし指定されたビットが1なら、対応する候補ウィンドウは、変更されようとしています。', '戻り値はありません。', 'アプリは、候補をアプリ自体が表示しているなら、処理すべきです。\r\n\r\nIMEウィンドウは、このコマンドを処理するときに候補ウィンドウの見た目を変更します。アプリはImmGetCandidateListCountと ImmGetCandidateListによってシステムウィンドウに関する情報を受け取ることができます。', 'WM_IME_NOTIFY|ImmGetCandidateListCount|ImmGetCandidateList', '2016-08-27 12:09:45', '2016-08-27 12:09:45', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318593.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_CLOSECANDIDATE', '通知コード', 'IMEが候補ウィンドウを閉じようとしているとき、アプリに通知します。アプリは、以下のパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_CLOSECANDIDATE', 'wParam --- IMN_CLOSECANDIDATEにセットします。\r\n///\r\nlParam --- 候補リストフラグ。それぞれのビットは、候補リストに対応します。ビット0は最初のリストに、ビット1は二番目のリストに対応します。もし指定したビットが1なら、対応する候補ウィンドウは、閉じられようとしています。', '戻り値はありません。', 'アプリは、アプリ自身が候補を表示しているのなら、このコマンドを処理すべきです。\r\n\r\n既定ではIMEは、このコマンドを処理したときに候補ウィンドウを破棄します。', 'WM_IME_NOTIFY', '2016-08-27 12:14:10', '2016-08-27 12:14:10', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318595.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_CLOSESTATUSWINDOW', '通知コード', 'IMEが状態ウィンドウを閉じようとしているときにアプリに通知します。アプリは下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_CLOSESTATUSWINDOW', 'wParam --- IMN_CLOSESTATUSWINDOWにセットします。\r\n///\r\nlParam --- 使われません。', '戻り値はありません。', 'アプリは、アプリ自体がIMEに対して状態ウィンドウを表示するなら、アプリはこのコマンドを処理すべきです。\r\n\r\nIMEウィンドウは、このコマンドを処理したときに状態ウィンドウを閉じます。', 'WM_IME_NOTIFY', '2016-08-28 01:45:15', '2016-08-28 01:45:15', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318597.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_GUIDELINE', '通知コード', 'IMEがエラーメッセージやその他の情報を表示しようとしているとき、アプリに通知します。アプリは、下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じて、このコマンドを受け取ります。', 'IMN_GUIDELINE', 'wParam --- IMN_GUIDELINEにセットします。\r\n///\r\nlParam --- 使われません。', '戻り値はありません。', 'アプリは、IMEからのエラーメッセージや情報を受け取るために、ImmGetGuideLine関数を呼ぶ区とにより、このコマンドを処理します。\r\n\r\nIMEウィンドウは、状態ウィンドウにおいてエラーメッセージや情報文字列を表示します。', 'WM_IME_NOTIFY|ImmGetGuideLine', '2016-08-28 01:49:02', '2016-08-28 01:49:02', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318599.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_OPENCANDIDATE', '通知コード', 'IMEが候補ウィンドウを開こうとしているとき、アプリに通知します。アプリは、以下に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_OPENCANDIDATE', 'wParam --- IMN_OPENCANDIDATEにセットします。\r\n///\r\nlParam --- 候補リストフラグ。それぞれのビットは、一つの候補リストに対応します。ビット0は最初のリストに、ビット1は二番目のリストに対応します。もし指定したビットが1なら、対応する候補ウィンドウは、開かれようとしています。', '戻り値はありません。', 'アプリは、アプリ自体が候補を表示するなら、このコマンドを処理すべきです。アプリは、ImmGetCandidateList関数を使うことにより、表示すべき候補のリストを受け取ることができます。\r\n\r\n既定では、IMEウィンドウは、このコマンドを処理したときに、候補ウィンドウを作成します。', 'WM_IME_NOTIFY|ImmGetCandidateList', '2016-08-28 01:53:34', '2016-08-28 01:53:34', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318600.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_OPENSTATUSWINDOW', '通知コード', 'IMEが状態ウィンドウを作成しようとしているとき、アプリに通知します。アプリは、下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_OPENSTATUSWINDOW', 'wParam --- IMN_OPENSTATUSWINDOWにセットします。\r\n///\r\nlParam --- 使われません。', '戻り値はありません。', 'アプリは、アプリ自体がIMEに対する状態ウィンドウを表示するためにこのコマンドを処理します。\r\n\r\nIMEウィンドウは、このコマンドを処理して入力コンテキストの中へウィンドウで表示すべき文字列たちをセットするときに、状態ウィンドウを作成します。アプリは、ImmGetConversionStatus関数を使って状態ウィンドウに関する情報を取得できます。', 'WM_IME_NOTIFY|ImmGetConversionStatus', '2016-08-28 01:57:44', '2016-08-28 01:57:44', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318603.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_SETCANDIDATEPOS', '通知コード', '候補処理が終わり、IMEが候補ウィンドウを移動しようとしているとき、アプリに通知します。アプリは、下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_SETCANDIDATEPOS', 'wParam --- IMN_SETCANDIDATEPOSにセットします。\r\n///\r\nlParam --- 候補リストフラグ。それぞれのビットは、一つの候補リストに対応します。ビット0は最初のリストに、ビット1は二番目のリストに対応します。もし指定したビットが1なら、対応する候補ウィンドウは移動されようとしています。', '戻り値はありません。', 'アプリ自体が候補ウィンドウを表示するアプリはこのコマンドを処理すべきです。\r\n\r\nIMEウィンドウは、このコマンドを処理したときに、候補ウィンドウを移動します。', 'WM_IME_NOTIFY', '2016-08-28 02:01:20', '2016-08-28 02:01:20', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318605.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_SETCOMPOSITIONFONT', '通知コード', '入力コンテキストのフォントが更新されたときにアプリに通知します。アプリは下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_SETCOMPOSITIONFONT', 'wParam --- IMN_SETCOMPOSITIONFONTにセットします。\r\n///\r\nlParam --- 使われません。', '戻り値はありません。', 'アプリは、ImmGetCompositionFont関数を使ってフォントに関する情報を受け取ることができます。さらに、IMEウィンドウはコンポジション文字列を描画するために、このフォントを使います。', 'WM_IME_NOTIFY', '2016-08-28 02:05:13', '2016-08-28 02:05:13', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318608.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_SETCOMPOSITIONWINDOW', '通知コード', 'コンポジションウィンドウのスタイルまたは位置が更新されるときに、アプリに通知します。アプリは、下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_SETCOMPOSITIONWINDOW', 'wParam --- IMN_SETCOMPOSITIONWINDOWにセットします。\r\n///\r\nlParam --- 使われません。', '戻り値はありません。', 'アプリは、IMC_GETCOMPOSITIONWINDOWコマンドを使って、コンポジションフォームに関する情報を取得できます。', 'WM_IME_NOTIFY', '2016-08-28 02:07:42', '2016-08-28 02:07:42', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318610.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_SETCONVERSIONMODE', '通知コード', '入力コンテキストの変換モードが更新されるときにアプリに通知します。アプリは下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_SETCONVERSIONMODE', 'wParam --- IMN_SETCONVERSIONMODEにセットします。\r\n///\r\nlParam --- 使われません。', '戻り値はありません。', 'アプリは、ImmGetConversionStatus 関数を使って、変換モードに関する情報を取得できます。', 'WM_IME_NOTIFY', '2016-08-28 02:09:45', '2016-08-28 02:09:45', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318613.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_SETOPENSTATUS', '通知コード', '入力コンテキストの開閉状態が更新されるときにアプリに通知します。アプリは下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_SETOPENSTATUS', 'wParam --- IMN_SETOPENSTATUSにセットします。\r\n///\r\nlParam --- 使われません。', '戻り値はありません。', 'アプリは、ImmGetOpenStatus関数を使って開閉状態に関する情報を取得できます。', 'WM_IME_NOTIFY', '2016-08-28 02:11:48', '2016-08-28 02:11:48', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318614.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_SETSENTENCEMODE', '通知コード', '入力コンテキストのセンテンスモードが更新されるときに、アプリに通知します。アプリは、下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_SETSENTENCEMODE', 'wParam --- IMN_SETSENTENCEMODEにセットします。\r\n///\r\nlParam --- 使われません。', '戻り値はありません。', 'アプリは、ImmGetConversionStatus関数を使ってセンテンスモードに関する情報を取得できます。', 'WM_IME_NOTIFY|ImmGetConversionStatus', '2016-08-28 02:13:45', '2016-08-28 02:13:45', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318617.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMN_SETSTATUSWINDOWPOS', '通知コード', '入力コンテキストにおける状態ウィンドウの位置が更新されるときに、アプリに通知します。アプリは下記に示されるパラメーター設定でWM_IME_NOTIFYメッセージを通じてこのコマンドを受け取ります。', 'IMN_SETSTATUSWINDOWPOS', 'wParam --- IMN_SETSTATUSWINDOWPOSにセットします。\r\n///\r\nlParam --- 使われません。', '戻り値はありません。', 'アプリは、IMC_GETSTATUSWINDOWPOSコマンドを使って状態ウィンドウの位置に関する情報を取得できます。', 'WM_IME_NOTIFY', '2016-08-28 02:15:48', '2016-08-28 02:15:48', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318618.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMR_CANDIDATEWINDOW', '通知コード', '選択中のIMEが候補ウィンドウに関する情報が必要であるときに、アプリに通知します。アプリは下記に示されるパラメーター設定でWM_IME_REQUESTメッセージを通じてこのコマンドを受け取ります。', 'LRESULT IMR_CANDIDATEWINDOW', 'wParam --- IMR_CANDIDATEWINDOWにセットします。\r\n///\r\nlParam --- CANDIDATEFORM構造体を含むバッファーへのポインタを指定します。dwIndexメンバーは、参照される候補ウィンドウへのインデックスです。', 'アプリがCANDIDATEFORM構造体を埋めたら、非ゼロの値を返します。その他の場合、ゼロを返します。', 'このコマンドは、WM_IME_SETCONTEXTメッセージハンドラーにおいて、ISC_SHOWUICANDIDATEWINDOWフラグをクリアしたウィンドウへ、IMEによって送信されます。', 'WM_IME_REQUEST|CANDIDATEFORM|WM_IME_SETCONTEXT', '2016-08-28 02:20:30', '2016-08-28 02:20:30', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318621.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMR_COMPOSITIONFONT', '通知コード', '選択済みのIMEがコンポジションウィンドウで使われるフォントに関する情報が必要なときに、アプリに通知します。アプリは下記に示されるパラメーター設定でWM_IME_REQUESTメッセージを通じてこのコマンドを受け取ります。', 'LRESULT IMR_COMPOSITIONFONT', 'wParam --- IMR_COMPOSITIONFONTにセットします。\r\n///\r\nlParam --- LOGFONT構造体を含むバッファーへのポインタを指定します。アプリは現在のコンポジションウィンドウに対する値を埋めます。', 'アプリがLOGFONT構造体を埋めたら、非ゼロを返します。その他の場合、ゼロを返します。', 'WM_IME_SETCONTEXTメッセージハンドラーにおいてISC_SHOWUICOMPOSITIONWINDOWをクリアしたウィンドウに対して、このコマンドがIMEによって送信されます。', 'WM_IME_REQUEST|WM_IME_SETCONTEXT', '2016-08-28 02:25:10', '2016-08-28 02:25:10', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318623.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMR_COMPOSITIONWINDOW', '通知コード', 'IMEがコンポジションウィンドウに関する情報が必要なときに、アプリに通知します。アプリは下記に示されるパラメーター設定でWM_IME_REQUESTメッセージを通じて、このコマンドを受け取ります。', 'LRESULT IMR_COMPOSITIONWINDOW', 'wParam --- IMR_COMPOSITIONWINDOWにセットします。\r\n///\r\nlParam --- COMPOSITIONFORM構造体を含むバッファーへのポインタを指定します。', 'アプリがCOMPOSITIONFORM構造体を埋めたら、非ゼロの値を返します。その他の場合、ゼロを返します。', 'WM_IME_SETCONTEXTメッセージハンドラーにおいてISC_SHOWUICOMPOSITIONWINDOWフラグをクリアしたウィンドウに対して、IMEによってこのコマンドが送信されます。', 'WM_IME_REQUEST|COMPOSITIONFORM|WM_IME_SETCONTEXT', '2016-08-28 02:28:22', '2016-08-28 02:28:22', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318626.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMR_CONFIRMRECONVERTSTRING', '通知コード', 'IMEが RECONVERTSTRING 構造体を変更する必要があるときに、アプリに通知します。アプリは、下記に示されるパラメーター設定でWM_IME_REQUESTメッセージを通じてこのコマンドを受け取ります。', 'LRESULT IMR_CONFIRMRECONVERTSTRING', 'wParam --- IMR_CONFIRMRECONVERTSTRINGにセットします。\r\n///\r\nlParam --- IMEからのRECONVERTSTRING 構造体へのポインタを指定します。詳しくは解説をご覧ください。', '変更されたRECONVERTSTRING 構造体をアプリが受け入れたとき、非ゼロの値を返します。その他の場合、コマンドはゼロを返し、IMEは元のRECONVERTSTRING 構造体を使います。', 'アプリはIMR_RECONVERTSTRINGコマンドを受け取ったときに、RECONVERTSTRING 構造体を埋めます。\r\n\r\nアプリがIMR_RECONVERTSTRINGを取り扱った後で、IMEはRECONVERTSTRING 構造体を補正するかもしれません。IMEは、RECONVERTSTRING 構造体への変更を確認するためにIMR_CONFIRMRECONVERTSTRINGを送信します。もしアプリが、IMR_CONFIRMRECONVERTSTRINGに対してTRUEを返したら、IMEはIMR_CONFIRMRECONVERTSTRINGに対するRECONVERTSTRING 構造体に基づいて新しいコンポジション文字列を生成します。もしアプリがIMR_CONFIRMRECONVERTSTRINGに対してFALSEを返したら、IMEは、アプリによってIMR_RECONVERTSTRINGコマンドで指定された元のRECONVERTSTRING構造体に基づいて新しいコンポジション文字列を生成します。', 'WM_IME_REQUEST|RECONVERTSTRING', '2016-08-28 02:37:46', '2016-08-28 02:37:46', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318629.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMR_DOCUMENTFEED', '通知コード', '選択済みのIMEがアプリからの変換後の文字列を必要としているときに、アプリに通知します。アプリは、下記に示されるパラメーター設定でWM_IME_REQUESTメッセージを通じてこのコマンドを受け取ります。', 'LRESULT IMR_DOCUMENTFEED', 'wParam --- IMR_DOCUMENTFEEDにセットします。\r\n///\r\nlParam --- RECONVERTSTRING 構造体を含むバッファーへのポインタを指定します。', '現在の再変換文字列構造体を返します。もしlParamがNULLにセットされたら、アプリは構造体を格納するのに必要なバッファサイズを返します。コマンドが失敗したら、ゼロを返します。', 'IMEは、より高い精度の変換のために、変換文字列をキャッシュします。IMEは以下の状況で変換済みの文字列を失います。\r\n\r\n * アプリに対するキャレット位置が、カーソルキーなどのキーによって移動した。\r\n * アプリに対するキャレット位置がマウスによって移動した。\r\n * 新しい文書が開かれた。\r\n\r\nIMR_DOCUMENTFEEDコマンドを使うと、IMEはキャッシュされた文字列をいつでもリフレッシュできます。このコマンドの使用は、変換精度を向上します。', 'WM_IME_REQUEST|RECONVERTSTRING', '2016-08-28 02:45:35', '2016-08-28 02:45:35', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318632.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMR_QUERYCHARPOSITION', '通知コード', '選択済みのIMEがコンポジション文字列における文字の座標に関する情報を必要としているときに、アプリに通知します。アプリは、下記に示されるパラメーター設定でWM_IME_REQUESTメッセージを通じてこのコマンドを受け取ります。', 'LRESULT IMR_QUERYCHARPOSITION', 'wParam --- IMR_QUERYCHARPOSITIONにセットします。\r\n///\r\nlParam --- コンポジションウィンドウにおける文字の位置を含むIMECHARPOSITION構造体へのポインタを指定します。', 'アプリがIMECHARPOSITION構造体を埋めたら、非ゼロの値を返します。その他の場合、ゼロを返します。', 'アプリ自体が、IMEに頼らずにコンポジション文字列を描画するアプリは、IMECHARPOSITION構造体のすべてのメンバーを埋める責任があります。さもなければ、アプリ自体がIME UIウィンドウを所有するとき、アプリはDefWindowProcかImmIsUIMessage にコマンドを渡すべきです。', 'WM_IME_REQUEST|IMECHARPOSITION|DefWindowProc|ImmIsUIMessage', '2016-08-28 02:50:45', '2016-08-28 02:50:45', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318634.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('IMR_RECONVERTSTRING', '通知コード', '選択済みのIMEが、再変換用の文字列を必要としているときに、アプリに通知します。アプリは下記に示されるパラメーター設定でWM_IME_REQUESTメッセージを通じてこのコマンドを受け取ります。', 'LRESULT IMR_RECONVERTSTRING', 'wParam --- IMR_RECONVERTSTRINGにセットします。\r\n///\r\nlParam --- RECONVERTSTRING 構造体と文字列たちを含むバッファーへのポインタを指定します。', '現在の再変換文字列構造体を返します。もしlParamがNULLなら、アプリは構造体を保持するのに必要なバッファーサイズを返します。それが失敗したら、コマンドはゼロを返します。', '', 'WM_IME_REQUEST|RECONVERTSTRING', '2016-08-28 02:53:27', '2016-08-28 02:53:27', '<imm.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318637.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Indicator Manager for IME', '', 'Windows 98 と Windows 2000 で定義されたメッセージ集合を使えば、IME は、システムタスクバー上のシス\r\nテムペンアイコンに対するアイコンとツールチップを変更できる。\r\n\r\n * インディケータウィンドウ\r\n * インディケータメッセージたち', '', '', '', '', 'Indicator Window|Indicator Messages', '2016-09-10 10:49:49', '2016-09-10 10:49:49', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Indicator Messages', '', 'IME は、異なるタスクを行うために、以下のメッセージをインディケータウィンドウに送信できる。\r\n\r\n * INDICM_SETIMEICON\r\n * INDICM_SETIMETOOLTIPS\r\n * INDICM_REMOVEDEFAULTMENUITEMS', '', '', '', '', 'Indicator Window|INDICM_SETIMEICON|INDICM_SETIMETOOLTIPS|INDICM_REMOVEDEFAULTMENUITEMS', '2016-09-10 10:51:46', '2016-09-10 10:51:46', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Indicator Window', '', 'IME は、FindWindow 関数を INDICATOR_CLASS と共に使って、ウィンドウハンドルを取得できる。', '', '', '', 'タスクバー管理の内部設計の要求のため、IME は INDICM_xxx メッセージに対して PostMessage を使わねばならない。', 'PostMessage', '2016-09-10 10:50:40', '2016-09-10 10:50:40', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('INDICM_REMOVEDEFAULTMENUITEMS', 'メッセージ', 'このメッセージは、IME がシステムペンアイコンの既定のメニュー項目たちを除去したいときに、インディ\r\nケータウィンドウへ送信される。', 'INDICM_REMOVEDEFAULTMENUITEMS\r\nwValue = wParam;\r\nhKL = lParam;', 'wValue --- wValue は次のビットたちの組み合わせである。\r\n\r\n[table:INDICM_REMOVEDEFAULTMENUITEMS_Table1]\r\n\r\nもし wValue がゼロであれば、すべての既定のメニュー項目たちが復元される。\r\n///\r\nhKL --- 送信元の IME である。', '非ゼロの値は失敗を表す。さもなければゼロが返される。', 'タスクバー管理の内部設計の要件のため、IME は INDICM_xxx メッセージに対して PostMessage を使わ\r\nなければならない。', 'PostMessage', '2016-08-29 06:24:48', '2016-08-29 06:24:48', '', '', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('INDICM_SETIMEICON', 'メッセージ', 'このメッセージは、IME がシステムペンアイコンに対するアイコンを変更したいときに、インディケータウィンド\r\nウに送信される。このメッセージは、フォーカスウィンドウの選択中の hKL が送信元の IME と同じであるときに、\r\n受け入れられる。', 'INDICM_SETIMEICON\r\nnIconIndex = wParam;\r\nhKL = lParam;', 'nIconIdex --- IME ファイルのアイコンリソースのインデックス。もしこの値が(-1)であれば、インディケータはシステムによって提供されたオリジナルのアイコンを復元する。\r\n///\r\nhKL --- 送信元の IME である。', '非ゼロの値は失敗を表す。さもなければゼロが返される。', 'タスクバー管理の内部設計の要件のため、IME は、INDICM_xxx メッセージに対して PostMessage を使わ\r\nなければならない。', 'PostMessage', '2016-08-29 06:22:44', '2016-08-29 06:22:44', '', '', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('INDICM_SETIMETOOLTIPS', 'メッセージ', 'このメッセージは、IME がシステムペンアイコンのツールチップ文字列を変更したいときに、インディケータ\r\nウィンドウへ送信される。このメッセージは、フォーカスウィンドウの選択中の hKL が送信元 IME と同じである\r\nときに、受け入れられる。', 'INDICM_SETIMETOOLTIPS\r\nhAtom = wParam;\r\nhKL = lParam;', 'hAtom --- ツールチップ文字列に対するグローバル ATOM の値。もしこの値が(-1)であれば、インディケータは、システムによって提供されたオリジナルのチップを復元する。\r\n///\r\nhKL --- 送信元の IME である。', '非ゼロの値は失敗を表す。さもなければゼロが返される。', 'タスクバー管理の内部設計の要件のため、IME は INDICM_xxx メッセージに対して PostMessage を使わ\r\nなければならない。グローバル ATOM は、GlobalAddAtom か GlobalFindAtom で取得しなければならない。', 'PostMessage', '2016-08-29 06:23:40', '2016-08-29 06:23:40', '', '', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Input Method Editor Constants', '', '以下の定数がIMEの関数とメッセージで使われる。\r\n\r\n「IME変換モードの値」は、ImmGetConversionStatusとImmSetConversionStatus関数と共に使われる値に対する参照を提供する。\r\n\r\n「IMEコンポジション文字列の値」は、ImmGetCompositionString 関数とWM_IME_COMPOSITION メッセージと共に使われる値に対する参照を提供する。\r\n\r\n「IMEホットキー識別子」は、ImmSimulateHotKey 関数と共に使われる識別子に対する参照を提供する。\r\n\r\n「IMEセンテンスモードの値」は、ImmGetConversionStatusとImmSetConversionStatus 関数と共に使われる値に対する参照を提供する。\r\n\r\n「IMEエスケープ」は、ImmEscape関数と共に使われる値に対する参照を提供する。', '', '', '', '', 'IME Conversion Mode Values|IME Composition String Values|IME Hot Key Identifiers|IME Sentence Mode Values|IME Escapes', '2016-09-03 04:13:49', '2016-09-03 04:13:49', '', '', 'https://msdn.microsoft.com/ja-jp/vstudio/ee490952', 'Katayama Hirofumi MZ', '', '', '', ''),
('INPUTCONTEXT', '構造体', '入力コンテキストの情報を含みます。', 'typedef struct {\r\n  HWND            hWnd;\r\n  BOOL            fOpen;\r\n  POINT           ptStatusWndPos;\r\n  POINT           ptSoftKbdPos;\r\n  DWORD           fdwConversion;\r\n  DWORD           fdwSentence;\r\n  union {\r\n    LOGFONTA A;\r\n    LOGFONTW W;\r\n  } lfFont;\r\n  COMPOSITIONFORM cfCompForm;\r\n  CANDIDATEFORM   cfCandForm[4];\r\n  HIMCC           hCompStr;\r\n  HIMCC           hCandInfo;\r\n  HIMCC           hGuideLine;\r\n  HIMCC           hPrivate;\r\n  DWORD           dwNumMsgBuf;\r\n  HIMCC           hMsgBuf;\r\n  DWORD           fdwInit;\r\n  DWORD           dwReserve[3];\r\n} INPUTCONTEXT;', 'hWnd --- 入力コンテキストを使うウィンドウへのハンドルです。\r\n///\r\nfOpen --- IMEの開閉状態を表すBOOL型の値です。TRUEならIMEは開かれています。その他の場合、IMEは閉じられています。\r\n///\r\nptStatusWndPos --- 状態ウィンドウの位置を表すPOINT構造体です。\r\n/// \r\nptSoftKbdPos --- ソフトキーボードの位置を表すPOINT構造体です。\r\n///\r\nfdwConversion --- IMEコンポジションエンジンによって使われる変換モードを表す符号なしの長整数値です。\r\n///\r\nfdwSentence --- IMEコンポジションエンジンによって使われるセンテンスモードを表す符号なしの長整数値です。\r\n///\r\nlfFont --- IMEコンポジションエンジンによって使われるLOGFONT構造体です。\r\n\r\n[table:INPUTCONTEXT_Table1]\r\n///\r\ncfCompForm --- コンポジションウィンドウを作成するためのIMEのUIによって使われるCOMPOSITIONFORM構造体です。\r\n/// \r\ncfCandForm --- 候補ウィンドウを作成するためにIME UIによって使われるCANDIDATEFORM構造体です。この入力方式コンテキストは4個の候補フォームをサポートしています。\r\n///\r\nhCompStr --- COMPOSITIONSTRING構造体へのハンドルです。\r\n///\r\nhCandInfo --- CANDIDATEINFOとCANDIDATELIST構造体へのハンドルです。\r\n///\r\nhGuideLine --- GUIDELINE構造体を含むバッファーへのハンドルです。\r\n///\r\nhPrivate --- 私的データ領域のためにIMEが使用するバッファーへのハンドルです。\r\n///\r\ndwNumMsgBuf --- hMsgBufに格納されるメッセージの個数を表す符号なしの長整数値です。\r\n///\r\nhMsgBuf --- メッセージを格納するバッファーへのハンドルです。\r\n///\r\nfdwInit --- 初期化フラグを表す符号なしの長整数値です。\r\n///\r\ndwReserve --- 予約済み。ゼロでなければなりません。', '', '', 'COMPOSITIONFORM|CANDIDATEFORM|COMPOSITIONSTRING|CANDIDATEINFO|CANDIDATELIST|GUIDELINE', '2016-08-29 03:04:36', '2016-08-29 03:04:36', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741229.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('InSendMessage', '関数', '別のスレッド（同じプロセスまたは別のプロセス）からSendMessage関数の呼び出しによって送信されたメッセージを現在のウィンドウプロシージャーが処理しているかどうか決定します。\r\n\r\nどのようにメッセージが送信されたかに関する追加的な情報を取得するには、InSendMessageEx関数をお使い下さい。', 'BOOL WINAPI InSendMessage(void);', 'パラメーターはありません。', 'もし、ウィンドウプロシージャーが、他のスレッドからSendMessage関数を使って送信されたメッセージを処理しているなら、戻り値は非ゼロです。\r\n\r\nもしウィンドウプロシージャーが、他のスレッドからSendMessage関数を使って送信されていないメッセージを処理しているなら、戻り値はゼロです。', '', 'InSendMessageEx|SendMessage', '2016-08-28 03:18:12', '2016-08-28 03:18:12', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644941.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Key Status', '', 'キーボードメッセージを処理する間、アプリは現在のメッセージを生成した状態に加えて別のキーの状態を確認する必要があるかもしれない。例えば、ユーザーがSHIFT+ENDを押されると、テキストのブロックを選択することを許すようなワープロアプリは、ENDキーのキーストロークメッセージを受け取ったときにSHIFTキーの状態をチェックしなければならない。アプリは現在のメッセージが生成されたときの仮想キーの状態を確認するためにGetKeyState関数を使うことができる。GetAsyncKeyStateは、仮想キーの現在の状態を取得するために使うことができる。\r\n\r\nキーボードレイアウトは、名前のリストを管理している。単一の文字を生成するキーの名前は、キーによって生成された文字と同じである。文字ではないキーの名前は、TABやENTERのように、文字列として格納される。アプリは、どんなキーの名前もGetKeyNameText関数を呼ぶことでデバイスドライバーから取得することができる。', '', '', '', '', '', '2016-09-15 02:44:04', '2016-09-15 02:44:04', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Keyboard Focus and Activation', '', 'システムは、キーボードメッセージたちを、キーボードフォーカスを持つウィンドウを作成した前面のスレッドメッセージキューにポストする。キーボードフォーカスは、ウィンドウの一時的なプロパティである。システムは、ユーザーの指示に応じて、次々とウィンドウから別のウィンドウへと、キーボードフォーカスをずらすことによってディスプレイ上のすべてのウィンドウの間でキーボードを共有する。キーボードフォーカスを持っているウィンドウはフォーカスが別のウィンドウに代わるまで、（ウィンドウを作成したスレッドのメッセージキューから）すべてのキーボードメッセージを受け取る。\r\n\r\nスレッドはどのウィンドウが現在キーボードフォーカスを持っているか確かめるために、GetFocus関数を呼ぶことができる。スレッドはSetFocus関数を呼ぶことでキーボードフォーカスをウィンドウの一つに与える。キーボードフォーカスが別のウィンドウへ変化するとき、システムはWM_KILLFOCUSメッセージをフォーカスを失うウィンドウに送信し、そしてWM_SETFOCUSをフォーカスを得るウィンドウに送信する。\r\n\r\nキーボードフォーカスの概念は、アクティブウィンドウのそれと関連している。アクティブウィンドウは、ユーザーが現在働いているトップレベルのウィンドウである。キーボードフォーカスのあるウィンドウは、アクティブウィンドウか、アクティブウィンドウの子ウィンドウのどちらかである。ユーザーがアクティブウィンドウを識別することを助けるために、システムはアクティブウィンドウをZオーダーの最前面に置き、タイトルバーと境界線をハイライトする。\r\n\r\nユーザーはトップレベルのウィンドウをクリックしたり、ALT+TABやATL+ESCキーを使ったり、タスクリストから選んだりすることでアクティブ化できる。スレッドは、トップレベルのウィンドウをSetActiveWindow関数を使うことでアクティブ化できる。\r\nGetActiveWindow関数を使うことでスレッドが作成したトップレベルのウィンドウがアクティブかどうか確認できる。\r\n\r\nあるウィンドウが非アクティブ化され、他がアクティブ化されたら、システムはWM_ACTIVATEメッセージを送信する。wParamパラメータの下位ワードは、もしウィンドウが非アクティブ化されたならゼロで、アクティブ化されたら非ゼロである。もし既定のウィンドウプロシージャーがWM_ACTIVATEメッセージを受け取ったとき、そのプロシージャーはアクティブウィンドウへキーボードフォーカスをセットする。\r\n\r\nキーボードとマウス入力イベントたちをアプリから届くことをブロックするには、BlockInputを使う。注意、BlockInput関数は非同期キーボード入力状態テーブルには影響しない。これは、入力がブロックされている間にSendInput関数を呼ぶことは、非同期キーボード入力状態テーブルを変更することを意味する。', '', '', '', '', '', '2016-09-14 09:58:19', '2016-09-14 09:58:19', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('Keyboard Input Model', '', 'システムは、現在のキーボードに対して適切なキーボードデバイスドライバーをインストールすることにより、アプリたちにデバイス非依存なキーボードサポートを提供する。システムは、ユーザーまたはアプリによって現在選択済みの、言語に依存したキーボードレイアウトを使って、言語非依存なキーボードサポートを提供する。キーボードデバイスドライバーは、キーボードからスキャンコードを受け取る。それは、キーボードレイアウトに送信され、メッセージたちに変換され、あなたのアプリにおいて適切なウィンドウにポストされる。\r\n\r\nキーボードについて適切なキーに割り当てられるのは、スキャンコードと呼ばれる一意な値であり、キーボードのキーに対するデバイス依存の識別子である。キーボードは、ユーザーが１つのキーを打ち込んだとき、２つのスキャンコードを生成する。１つはユーザーがキーを押したとき、もう１つはユーザーがキーを離したときである。\r\n\r\nキーボードデバイスドライバーは、スキャンコードを解釈し、仮想キーコードと呼ばれる、システムによって定義されたデバイス非依存な値（キーの目的を識別する）に翻訳する。スキャンコードの翻訳の後で、キーボードレイアウトは、スキャンコード、仮想キーコード、キーストロークに関するその他の情報を含むメッセージを作成する。そしてそのメッセージをシステムメッセージキューに置く。システムはそのメッセージをシステムメッセージキューから取り除き、適切なスレッドのメッセージキューにポストする。最後に、スレッドのメッセージループはそのメッセージを取り除き、処理のための適切なウィンドウプロシージャに渡す。次の図はキーボード入力モデルを表す。', '', '', '', '', '', '2016-09-13 02:44:28', '2016-09-13 02:44:28', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Keyboard Keys for Browsing and Other Functions', '', 'Windowsはブラウジング、メディア機能、アプリ起動、電源管理などの特殊なキーをもったキーボードのためのサポートを提供する。WM_APPCOMMANDはそれらのおまけのキーボードのキーをサポートする。加えて、ShellProc関数はおまけのキーボードのキーをサポートするために改変される。\r\n\r\nコンポーネントアプリの中の子ウィンドウがそれらのおまけのキーボードのキーに対するコマンドを直接、実装することができるとは考えられない。だからそれらのキーの１つが押されたときに、DefWindowProcは、WM_APPCOMMANDメッセージをウィンドウに送信することになる。DefWindowProcはまた、WM_APPCOMMANDメッセージをその親ウィンドウに泡のように浮き上がらせる。これはマウスの右ボタンでコンテキストメニューが行使され、右ボタンクリックでDefWindowProcがWM_CONTEXTMENUメッセージを送信し、そのメッセージをその親ウィンドウに泡のように浮き上がらせるのと似ている。さらに、もしDefWindowProcがトップレベルのウィンドウに対するWM_APPCOMMANDメッセージを受け取ったら、それはHSHELL_APPCOMMANDコードを持った１つのシェルフックを呼ぶだろう。\r\n\r\nWindowsはまた、インテリマウスエクスプローラをサポートする。それは５つのボタンを持ったマウスだ。２つのおまけのボタンは「前に戻る」「次に進む」ブラウザーナビゲーションをサポートする。詳しくはXBUTTONを参照せよ。', '', '', '', '', '', '2016-09-16 13:14:35', '2016-09-16 13:14:35', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Keystroke and Character Translations', '', 'システムは、様々なキーストロークメッセージによって提供された、スキャンコード、文字コード、仮想キーコードを翻訳する、いくつかの特殊な目的の関数を持っている。それらの関数は、MapVirtualKey、ToAscii、ToUnicode、VkKeyScanなどである。\r\n\r\n加えて、リッチエディット3.0はHexToUnicode IMEをサポートする。それはホットキーを使ってユーザーに十六進数文字とUnicode文字の間で変換することを許可する。これは、リッチエディット3.0がアプリに含まれていれば、アプリはHexToUnicode IMEの機能を継承するだろうということである。', '', '', '', '', '', '2016-09-15 02:52:16', '2016-09-15 02:52:16', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Keystroke Message Flags', '', 'キーストロークメッセージのlParamパラメータは、メッセージを生成したキーストロークに関する追加的な情報を含む。この情報は、リピートカウント、スキャンコード、拡張キーフラグ、コンテキストコード、直前のキー状態、そしてトランジション状態フラグを含む。次の図は、lParamパラメータのフラグたちと値たちの位置を示す。\r\n\r\nアプリは、以下の値をキーストロークフラグを操作するために使うことができる。\r\n\r\n[table:Keystroke Message Flags_Table1]', '', '', '', '', '', '2016-09-14 10:27:43', '2016-09-14 10:27:43', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Keystroke Messages', '', 'キーを押すことは、キーボードフォーカスを持ったウィンドウにアタッチされたスレッドメッセージキューにWM_KEYDOWNやWM_SYSKEYDOWNメッセージが置かれることを引き起こす。キーを離すことはWM_KEYUPやWM_SYSKEYUPメッセージがキューに置かれることを引き起こす。\r\n\r\nキーを離すことやキーを押すことは、たいてい対となるが、ユーザーが長い間押されると、キーボードの自動リピート機能により、システムは複数のWM_KEYDOWNやWM_SYSKEYDOWNメッセージたちの列を生成する。その後、ユーザーがキーを離したとき、単一のWM_KEYUPやWM_SYSKEYUPメッセージを生成する。\r\n\r\nこのセクションは、以下のトピックをカバーする。\r\n\r\n * システムと非システムのキーストローク\r\n * 仮想キーコードの説明\r\n * キーストロークメッセージのフラグたち', '', '', '', '', '', '2016-09-14 10:04:42', '2016-09-14 10:04:42', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('LANGIDFROMLCID', 'マクロ', 'ロケール識別子から言語識別子を取得します。', 'WORD LANGIDFROMLCID(\r\n   LCID lcid\r\n);', 'lcid --- ロケール識別子。ロケール識別子を作成するのにMAKELCIDマクロを使うか、次の定義済みの値のいずれかを使用できます。\r\n\r\n * LOCALE_INVARIANT \r\n * LOCALE_SYSTEM_DEFAULT \r\n * LOCALE_USER_DEFAULT \r\n\r\nWindows Vista: 次のカスタムロケール識別子もサポートされます。\r\n\r\n * LOCALE_CUSTOM_DEFAULT \r\n * LOCALE_CUSTOM_UI_DEFAULT \r\n * LOCALE_CUSTOM_UNSPECIFIED', '言語識別子を返します。', '', 'MAKELANGID|MAKELCID|PRIMARYLANGID|SUBLANGID', '2016-09-18 05:32:14', '2016-09-18 05:32:14', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd318689.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Languages, Locales, and Keyboard Layouts', '', '「言語（language）」または「主言語（primary language）」とは、英語、フランス語、日本語などの自然言語である。「サブ言語（sublanguage）」とは、特定の地理的な地域で話される自然言語のバリエーションであり、例えば英語のサブ言語はイギリス連合王国とアメリカ合衆国である。アプリはこれらの値を「言語識別子」として一意に言語とサブ言語を識別するために使う。\r\n\r\nアプリは処理される入出力の言語をセットするために、たいていロケールを使う。キーボードに対してロケールをセットすることは、例えば、キーボードによって生成される文字の値に影響する。ディスプレイやプリンタに対してロケールをセットすることは、表示または印刷されるグリフ（字形）に影響する。アプリは、キーボードにロケールを読み込み、キーボードレイアウトを使うことで、キーボードにロケールをセットできる。アプリは、選択済みのロケールをサポートするフォントを選択することで、ディスプレイやプリンタにロケールをセットできる。\r\n\r\nキーボードレイアウトは、キーボードにおける物理的なキー位置を指定するだけでなく、キーを押すことで生成される文字の値をも決める。それぞれのレイアウトは、現在の入力言語を識別し、それぞれのキーとキーの組み合わせによって生成される文字の値を決める。\r\n\r\n１つのキーボードレイアウトは、レイアウトと言語を識別する１つのハンドルに対応している。ハンドルの下位ワードは、言語識別子だ。上位ワードはデバイスハンドルで、物理レイアウトか、既定の物理レイアウトを表すゼロを指定する。ユーザーは物理レイアウトにどんな入力言語を関連付けることができる。例えば、フランスでよく働き、英語を話すユーザーは、キーボードの物理レイアウトを変更することなく、キーボードの入力言語をフランス語にセットできる。これはユーザーは使いやすい英語レイアウトでフランス語のテキストを入力できることを意味する。\r\n\r\nアプリは、一般に直接入力言語を操作することを想定していない。代わりにユーザーは言語とレイアウトの組み合わせをセットアップし、それらを切り替える。ユーザーが別の言語でマークされたテキストをクリックしたとき、アプリはその言語に対するユーザーの既定のレイアウトをアクティブ化するためにActivateKeyboardLayout関数を呼ぶ。もしユーザーがアクティブリストにない言語のテキストを編集すると、アプリはその言語に基づいたレイアウトを取得するためにLoadKeyboardLayout関数を呼ぶことができる。\r\n\r\nActivateKeyboardLayout関数は現在のタスクに対して入力言語をセットできる。hklパラメータは、キーボードレイアウトのハンドルかゼロ拡張の言語識別子のいずれかである。キーボードレイアウトのハンドルは、LoadKeyboardLayoutかGetKeyboardLayoutList関数から取得できる。HKL_NEXTとHKL_PREVの値は、次の、または前のキーボードを選択するために使える。\r\n\r\nGetKeyboardLayoutName関数は、呼び出し側のスレッドに対するアクティブなキーボードレイアウトの名前を取得する。アプリがLoadKeyboardLayout関数を使ってアクティブなレイアウトを作成したら、GetKeyboardLayoutNameは、レイアウトを作成するのに使った同じ文字列を取得する。さもなければ、文字列は、アクティブなレイアウトのロケールに対応するプライマリーな言語識別子である。これはこの関数がプライマリー言語が同じなら異なるレイアウトを区別する必要がないことを意味する。よってこの関数は入力言語に関する特定の言語を返さない。しかしながらGetKeyboardLayout関数は、入力言語を確認するために使える。\r\n\r\nLoadKeyboardLayout関数は、キーボードレイアウトを読み込み、ユーザーにレイアウトを利用可能にする。アプリはKLF_ACTIVATEの値を使って現在のスレッドに対してレイアウトをすぐにアクティブにすることができる。アプリはKLF_ACTIVATEの値を指定しないレイアウトたちの並べ替えのために、KLF_REORDERの値を使うことができる。アプリは選択済みのユーザーの設定がもしあれば、それを保証するためのキーボードレイアウトを読み込むときに、常にKLF_SUBSTITUTE_OKの値を使うことができる。\r\n\r\n多言語サポートのために、LoadKeyboardLayout関数は、KLF_REPLACELANGとKLF_NOTELLSHELLフラグを提供する。KLF_REPLACELANGフラグは関数に言語を変更することなく、既存のキーボードレイアウトを置き換えるよう指図する。KLF_REPLACELANGを指定することなく同じ言語識別子を使った既存のレイアウトを置き換えようとするとエラーになる。KLF_NOTELLSHELLフラグはシェルに、キーボードレイアウトの追加・置き換えを通知することを防止する。これはアプリが、連続した複数のレイアウトを追加するのに役立つ。このフラグは最後の呼び出し以外で使うことができる。\r\n\r\nUnloadKeyboardLaytout関数は、システムが既定の入力言語をアンロード（unload）できない制限がある。これはシェルやファイルシステムで使われる文字セットを使って常にテキストを入力するための１つのレイアウトがあることを保証する。', '', '', '', '', '', '2016-09-16 14:00:42', '2016-09-16 14:00:42', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_add_after', '関数', 'ある要素の直後に要素を追加します。', 'inline void list_add_after( struct list *elem, struct list *to_add );', 'elem --- この要素の直後に追加されます。\r\n///\r\nto_add --- 追加する要素を指定します。', '', '<pre>__WINE_SERVER_LIST_INLINE void list_add_after( struct list *elem, struct list *to_add )\r\n{\r\n    to_add->next = elem->next;\r\n    to_add->prev = elem;\r\n    elem->next->prev = to_add;\r\n    elem->next = to_add;\r\n}</pre>', 'struct list|list_add_before', '2016-09-08 12:10:34', '2016-09-08 12:10:34', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_add_before', '関数', 'ある要素の直前に別の要素を追加します。', 'inline void list_add_before( struct list *elem, struct list *to_add );', 'elem --- この要素の直前に追加されます。\r\n///\r\nto_add --- 追加する要素を指定します。', '', '<pre>__WINE_SERVER_LIST_INLINE void list_add_before( struct list *elem, struct list *to_add )\r\n{\r\n    to_add->next = elem;\r\n    to_add->prev = elem->prev;\r\n    elem->prev->next = to_add;\r\n    elem->prev = to_add;\r\n}</pre>', 'struct list|list_add_after', '2016-09-08 12:12:13', '2016-09-08 12:12:13', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_add_head', '関数', '線形リストの先頭に要素を追加します。', 'inline void list_add_head( struct list *list, struct list *elem );', 'list --- リストへのポインタ。\r\n///\r\nelem --- 追加する要素へのポインタ。', '', '<pre>__WINE_SERVER_LIST_INLINE void list_add_head( struct list *list, struct list *elem )\r\n{\r\n    list_add_after( list, elem );\r\n}</pre>', 'struct list|list_add_tail', '2016-09-08 12:07:09', '2016-09-08 12:07:09', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_add_tail', '関数', '線形リストの終端に要素を追加します。', 'inline void list_add_tail( struct list *list, struct list *elem );', 'list --- リストへのポインタ。 \r\n///\r\nelem --- 追加するノードへのポインタ。', '', '<pre>__WINE_SERVER_LIST_INLINE void list_add_tail( struct list *list, struct list *elem )\r\n{\r\n    list_add_before( list, elem );\r\n}</pre>', 'struct list|list_add_head', '2016-09-08 12:08:32', '2016-09-08 12:08:32', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_count', '関数', '指定した線形リストの要素を数えます。', 'inline unsigned int list_count( const struct list *list );', 'list --- 線形リストを指定します。', '指定したリストの要素の個数を返します。', '<pre>__WINE_SERVER_LIST_INLINE unsigned int list_count( const struct list *list )\r\n{\r\n    unsigned count = 0;\r\n    const struct list *ptr;\r\n    for (ptr = list->next; ptr != list; ptr = ptr->next) count++;\r\n    return count;\r\n}</pre>', 'struct list|list_empty', '2016-09-08 12:26:42', '2016-09-08 12:26:42', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_empty', '関数', '指定した線形リストが空かどうかを返します。', 'inline int list_empty( const struct list *list );', 'list --- 線形リストへのポインタ。', '空であれば非ゼロを返します。空でなければゼロを返します。', '<pre>__WINE_SERVER_LIST_INLINE int list_empty( const struct list *list )\r\n{\r\n    return list->next == list;\r\n}</pre>', 'struct list|list_count', '2016-09-08 12:25:35', '2016-09-08 12:25:35', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LIST_ENTRY', 'マクロ', '指定したリスト要素を含むオブジェクトへのポインタを取得します。', 'type *object = LIST_ENTRY(elem, type, field)', 'elem --- struct list型のリスト要素へのポインタ。\r\n///\r\ntype --- 取得するオブジェクトの型。\r\n///\r\nfield --- オブジェクト構造体の中のstruct list型のメンバー名。', 'type型のオブジェクトへのポインタを返します。', '<pre>#ifdef _WIN64\r\n#define LIST_ENTRY(elem, type, field) \\\r\n    ((type *)((char *)(elem) - (unsigned long long)(&((type *)0)->field)))\r\n#else\r\n#define LIST_ENTRY(elem, type, field) \\\r\n    ((type *)((char *)(elem) - (unsigned long)(&((type *)0)->field)))\r\n#endif</pre>', 'struct list', '2016-09-08 12:50:27', '2016-09-08 12:50:27', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LIST_FOR_EACH', 'マクロ', '線形リストを通して繰り返します。', 'struct list *cursor;\r\nLIST_FOR_EACH(cursor, &my_list)\r\n{\r\n    ...\r\n}', 'cursor --- ループ変数としての、struct listへのポインタ。\r\n///\r\nlist --- struct list型の線形リストへのポインタ。', '', '<pre>#define LIST_FOR_EACH(cursor,list) \\\r\n    for ((cursor) = (list)->next; (cursor) != (list); (cursor) = (cursor)->next)</pre>', 'struct list|LIST_FOR_EACH_ENTRY|LIST_FOR_EACH_SAFE', '2016-09-08 12:40:23', '2016-09-08 12:40:23', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LIST_FOR_EACH_ENTRY', 'マクロ', 'リストエントリーを使って線形リストを通じて繰り返します。', 'type *elem;\r\nLIST_FOR_EACH_ENTRY(elem, list, type, field)\r\n{\r\n    ...\r\n}', 'elem --- ループ変数としての、オブジェクトへのポインタ。\r\n///\r\nlist --- struct list型の線形リストへのポインタ。\r\n///\r\ntype --- オブジェクトの型。\r\n///\r\nfield --- オブジェクト構造体における、struct list型のメンバー名。', '', '<pre>#define LIST_FOR_EACH_ENTRY(elem, list, type, field) \\\r\n    for ((elem) = LIST_ENTRY((list)->next, type, field); \\\r\n         &(elem)->field != (list); \\\r\n         (elem) = LIST_ENTRY((elem)->field.next, type, field))</pre>', 'struct list|LIST_FOR_EACH|LIST_FOR_EACH_ENTRY_SAFE', '2016-09-10 02:16:58', '2016-09-10 02:16:58', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LIST_FOR_EACH_ENTRY_REV', 'マクロ', 'リストエントリーを使って線形リストを逆順に通して繰り返します。', 'type *elem;\r\nLIST_FOR_EACH_ENTRY_REV(elem, list, type, field)\r\n{\r\n    ...\r\n}', 'elem --- ループ変数としての、オブジェクトへのポインタ。\r\n///\r\nlist --- struct list型のリストへのポインタ。\r\n///\r\ntype --- オブジェクトの型。\r\n///\r\nfield --- オブジェクト構造体における、struct list型のメンバー名。', '', '<pre>#define LIST_FOR_EACH_ENTRY_REV(elem, list, type, field) \\\r\n    for ((elem) = LIST_ENTRY((list)->prev, type, field); \\\r\n         &(elem)->field != (list); \\\r\n         (elem) = LIST_ENTRY((elem)->field.prev, type, field))</pre>', 'struct list|LIST_FOR_EACH_ENTRY_SAFE_REV', '2016-09-10 02:41:56', '2016-09-10 02:41:56', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LIST_FOR_EACH_ENTRY_SAFE', 'マクロ', '除去に対して安全に、リストエントリーを使って線形リストを通して繰り返します。', 'type *cursor, *cursor2;\r\nLIST_FOR_EACH_ENTRY_SAFE(cursor, cursor2, list, type, field)\r\n{\r\n    ...\r\n}', 'cursor --- ループ変数としての、オブジェクトへのポインタ。ループの中でこれを除去できます。\r\n///\r\ncursor2 --- 別のループ変数としての、オブジェクトへのポインタ。これはcursorの次の要素です。\r\n///\r\nlist --- struct list型のリストへのポインタ。\r\n///\r\ntype --- オブジェクトの型。\r\n///\r\nfield --- オブジェクト構造体における、struct list型のメンバー名。', '', '<pre>#define LIST_FOR_EACH_ENTRY_SAFE(cursor, cursor2, list, type, field) \\\r\n    for ((cursor) = LIST_ENTRY((list)->next, type, field), \\\r\n         (cursor2) = LIST_ENTRY((cursor)->field.next, type, field); \\\r\n         &(cursor)->field != (list); \\\r\n         (cursor) = (cursor2), \\\r\n         (cursor2) = LIST_ENTRY((cursor)->field.next, type, field))</pre>', 'struct list|LIST_FOR_EACH_ENTRY', '2016-09-10 02:21:22', '2016-09-10 02:21:22', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LIST_FOR_EACH_ENTRY_SAFE_REV', 'マクロ', '除去に対して安全に、リストエントリーを使って線形リストを通じて逆順に繰り返します。', 'type *cursor, *cursor2;\r\nLIST_FOR_EACH_ENTRY_SAFE_REV(cursor, cursor2, list, type, field)\r\n{\r\n    ...\r\n}', 'cursor --- ループ変数としての、オブジェクトへのポインタ。これをループ内で除去できます。\r\n///\r\ncursor2 --- 別のループ変数としての、オブジェクトへのポインタ。\r\n///\r\nlist --- struct list型のリストへのポインタ。\r\n///\r\ntype --- オブジェクトへのポインタ。\r\n///\r\nfield --- オブジェクト構造体における、struct list型のメンバー名。', '', '<pre>#define LIST_FOR_EACH_ENTRY_SAFE_REV(cursor, cursor2, list, type, field) \\\r\n    for ((cursor) = LIST_ENTRY((list)->prev, type, field), \\\r\n         (cursor2) = LIST_ENTRY((cursor)->field.prev, type, field); \\\r\n         &(cursor)->field != (list); \\\r\n         (cursor) = (cursor2), \\\r\n         (cursor2) = LIST_ENTRY((cursor)->field.prev, type, field))</pre>', 'struct list|LIST_FOR_EACH_ENTRY_REV', '2016-09-10 02:24:43', '2016-09-10 02:24:43', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LIST_FOR_EACH_REV', 'マクロ', '線形リストを逆順に通して繰り返します。', 'struct list *cursor;\r\nLIST_FOR_EACH_REV(cursor, list)\r\n{\r\n    ...\r\n}', 'cursor --- ループ変数としての、要素へのポインタ。\r\n///\r\nlist --- struct list型のリストへのポインタ。', '', '<pre>#define LIST_FOR_EACH_REV(cursor,list) \\\r\n    for ((cursor) = (list)->prev; (cursor) != (list); (cursor) = (cursor)->prev)</pre>', 'struct list|LIST_FOR_EACH|LIST_FOR_EACH_ENTRY_REV|LIST_FOR_EACH_SAFE_REV', '2016-09-10 02:37:52', '2016-09-10 02:37:52', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LIST_FOR_EACH_SAFE', 'マクロ', '除去に対して安全に、線形リストを通して繰り返します。', 'struct list *cursor, *cursor2;\r\nLIST_FOR_EACH_SAFE(cursor, cursor2, list)\r\n{\r\n    ...\r\n}', 'cursor --- struct listへのポインタとしてのループ変数。ループ内でこれを除去できます。\r\n///\r\ncursor2 --- 別のループ変数である、struct listへのポインタ。cursorの次の要素になります。\r\n///\r\nlist --- struct list型のリストへのポインタ。', '', '<pre>#define LIST_FOR_EACH_SAFE(cursor, cursor2, list) \\\r\n    for ((cursor) = (list)->next, (cursor2) = (cursor)->next; \\\r\n         (cursor) != (list); \\\r\n         (cursor) = (cursor2), (cursor2) = (cursor)->next)</pre>', 'struct list|LIST_FOR_EACH_SAFE_REV|LIST_FOR_EACH_ENTRY_SAFE', '2016-09-08 12:42:53', '2016-09-08 12:42:53', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LIST_FOR_EACH_SAFE_REV', 'マクロ', '除去に対して安全に、線形リストを逆順に通して繰り返します。', 'struct list *cursor, *cursor2;\r\nLIST_FOR_EACH_SAFE_REV(cursor, cursor2, list)\r\n{\r\n    ...\r\n}', 'cursor --- ループ変数として、リスト要素へのポインタ。ループ内でこれを除去できます。\r\n///\r\ncursor2 --- 別のループ変数としての、リスト要素へのポインタ。\r\n///\r\nlist --- struct list型のリストへのポインタ。', '', '<pre>#define LIST_FOR_EACH_SAFE_REV(cursor, cursor2, list) \\\r\n    for ((cursor) = (list)->prev, (cursor2) = (cursor)->prev; \\\r\n         (cursor) != (list); \\\r\n         (cursor) = (cursor2), (cursor2) = (cursor)->prev)</pre>', 'struct list|LIST_FOR_EACH_SAFE|LIST_FOR_EACH_REV', '2016-09-10 02:31:03', '2016-09-10 02:31:03', '<wine/list>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_head', '関数', '線形リストの先頭ノードを返します。', 'inline struct list *list_head( const struct list *list );', 'list --- struct list型のリストへのポインタ。', '先頭ノード、またはNULLを返します。', '<pre>__WINE_SERVER_LIST_INLINE struct list *list_head( const struct list *list )\r\n{\r\n    return list_next( list, list );\r\n}</pre>', 'struct list|list_tail', '2016-09-08 12:22:53', '2016-09-08 12:22:53', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_init', '関数', '線形リストを初期化します。', 'inline void list_init( struct list *list );\r\nstatic struct list list = LIST_INIT(list);', 'list --- 線形リスト。', '', '<pre>__WINE_SERVER_LIST_INLINE void list_init( struct list *list )\r\n{\r\n    list->next = list->prev = list;\r\n}</pre>\r\n\r\n<pre>#define LIST_INIT(list)  { &(list), &(list) }</pre>', 'struct list', '2016-09-08 12:04:38', '2016-09-08 12:04:38', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_next', '関数', '次の要素を取得します。', 'inline struct list *list_next( const struct list *list, const struct list *elem );', 'list --- リストへのポインタ。\r\n///\r\nelem --- 要素。', 'elemの次の要素、またはNULLを返します。', '<pre>__WINE_SERVER_LIST_INLINE struct list *list_next( const struct list *list, const struct list *elem )\r\n{\r\n    struct list *ret = elem->next;\r\n    if (elem->next == list) ret = NULL;\r\n    return ret;\r\n}</pre>', 'struct list|list_prev', '2016-09-08 12:19:52', '2016-09-08 12:19:52', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_prev', '関数', '前の要素を取得します。', 'inline struct list *list_prev( const struct list *list, const struct list *elem );', 'list --- リストへのポインタ。\r\n///\r\nelem --- 要素。', 'elemの前の要素、またはNULLを返します。', '<pre>__WINE_SERVER_LIST_INLINE struct list *list_prev( const struct list *list, const struct list *elem )\r\n{\r\n    struct list *ret = elem->prev;\r\n    if (elem->prev == list) ret = NULL;\r\n    return ret;\r\n}</pre>', 'struct list|list_next', '2016-09-08 12:21:16', '2016-09-08 12:21:16', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_remove', '関数', '線形リストから要素を取り除きます。', 'inline void list_remove( struct list *elem );', 'elem --- 取り除く要素。', '', '<pre>__WINE_SERVER_LIST_INLINE void list_remove( struct list *elem )\r\n{\r\n    elem->next->prev = elem->prev;\r\n    elem->prev->next = elem->next;\r\n}</pre>', 'struct list|list_add_head|list_add_tail|list_add_before|list_add_after', '2016-09-08 12:16:57', '2016-09-08 12:16:57', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('list_tail', '関数', '線形リストの終端ノードを返します。', 'inline struct list *list_tail( const struct list *list );', 'list --- struct list型のリストへのポインタ。', '終端ノード、またはNULLを返します。', '<pre>__WINE_SERVER_LIST_INLINE struct list *list_tail( const struct list *list )\r\n{\r\n    return list_prev( list, list );\r\n}</pre>', 'struct list|list_head', '2016-09-08 12:24:00', '2016-09-08 12:24:00', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('LoadKeyboardLayout', '関数', '新しい入力ロケール識別子（旧名キーボードレイアウト）をシステムにロードします。入力ロケール識別子は一度に複数ロードすることができますが、アクティブ化できるのは 1 つだけです。複数の入力ロケール識別子をロードすると、切り替えを迅速に行うことができます。', 'HKL LoadKeyboardLayout(\r\n  LPCTSTR pwszKLID,  // ロードする入力ロケール識別子の名前\r\n  UINT Flags         // 入力ロケール識別子フラグ\r\n);', 'pwszKLID --- ロードする入力ロケール識別子（旧名キーボードレイアウト）の名前を表すバッファへのポインタを指定します。この名前は、16 進値の言語識別子（下位ワード）とデバイス識別子（上位ワード）で構成される文字列です。たとえば、米語の言語識別子は 0x0409 なので、基本の米語レイアウトの名前は \"00000409\" になります。米語レイアウトの変形（Dvorak レイアウトなど）では、名前は \"00010409\"、\"00020409\" などになります。\r\n///\r\nFlags --- 入力ロケール識別子をどのようにロードするかを指定します。このパラメータには次の値のいずれかを指定します。\r\n\r\n[table:LoadKeyboardLayout_Table1]', '関数が成功すると、要求された名前と合致するロケールの入力ロケール識別子（旧名キーボードレイアウトハンドル）が返ります。合致するロケールが存在しない場合、NULL が返ります。拡張エラー情報を取得するには、GetLastError 関数を使います。', '入力ロケール識別子には音声入力コンバータ、IME、またはその他のあらゆる入力形式が含まれており、キーボードレイアウトよりも広い概念を持ちます。\r\n\r\nアプリケーションは既定の入力ロケール識別子か、またはある言語に対する IME をロードすることができ、通常これらをロードします。入力ロケール識別子や IME のロードは、言語識別子の文字列バージョンを指定して行います。特定のロケールまたは IME をロードする必要がある場合、アプリケーションはレジストリを読み取り、LoadKeyboardLayout 関数に渡す特定の入力ロケール識別子を探します。この場合、あるロケールに対して既定の入力ロケール識別子をアクティブ化するように要求すると、最初に合致した入力ロケール識別子がアクティブ化されます。特定の IME をアクティブ化するには、GetKeyboardLayout 関数、GetKeyboardLayoutList 関数または LoadKeyboardLayout 関数から返された、明示的な入力ロケール識別子を使います。\r\n\r\nWindows 95/98：すでにロードされている入力ロケール識別子と同じ言語の入力ロケール識別子を、KLF_REPLACELANG フラグをセットしないでロードする場合、呼び出しは失敗します。ロードされたロケールで、与えられた言語に関連付けられるロケールは 1 つだけです（複数の IME をロードして同じ言語と関連付けることはできます）。', 'ActivateKeyboardLayout|GetKeyboardLayoutName|UnloadKeyboardLayout|GetKeyboardLayout', '2016-09-11 08:26:14', '2016-09-11 08:26:14', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc410864.aspx', 'Microsoft', '', '', '', ''),
('MAKELANGID', 'マクロ', '主言語識別子とサブ言語識別子から言語識別子を作成します。', 'WORD MAKELANGID(\r\n   USHORT usPrimaryLanguage,\r\n   USHORT usSubLanguage\r\n);', 'usPrimaryLanguage --- 主言語識別子。この識別子は、定義済みの言語か、ユーザー定義の主言語を指定できます。ユーザー定義の言語の識別子は、0x0200から0x03FFまでの範囲です。他の値はOSの使用のため予約済みです。詳しくは「言語識別子と文字列」を参照して下さい. \r\n///\r\nusSubLanguage --- サブ言語識別子。このパラメータは、定義済みのサブ言語識別子か、ユーザー定義のサブ言語を指定できます。\r\nユーザー定義のサブ言語の識別子は、0x20から0x3Fまでの範囲です。その他の値はOSの使用のため、予約済みです。詳しくは、「言語識別子と文字列」を参照して下さい。', '言語識別子を返します。', '次の表は、特殊な意味を持ったusPrimaryLanguageとusSubLanguageの組み合わせを示します。\r\n\r\n[table:MAKELANGID_Table1]', 'PRIMARYLANGID|SUBLANGID', '2016-09-18 05:26:28', '2016-09-18 05:26:28', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd373908.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('MAKELCID', 'マクロ', '言語識別子と並べ替え順識別子から、ロケール識別子を作成します。', 'DWORD MAKELCID(\r\n   WORD wLanguageID,\r\n   WORD wSortID\r\n);', 'wLanguageID --- 言語識別子。この識別子は、主言語識別子とサブ言語識別子の組み合わせであり、たいていMAKELANGIDマクロを使って作成されます。\r\n///\r\nwSortID --- 並べ替え順識別子。', 'ロケール識別子を返します。', '', 'LANGIDFROMLCID|MAKELANGID|SORTIDFROMLCID', '2016-09-18 05:36:47', '2016-09-18 05:36:47', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd319052.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Message Deadlocks', '', '別のスレッドにメッセージを送信するためにSendMessage関数を呼ぶスレッドは、ウィンドウプロシージャがメッセージの戻り値を受け取るまで実行を継続できない。もしメッセージを受け取るスレッドがメッセージ処理の間、制御を明け渡すなら、メッセージ送信中のスレッドは実行を継続できない。なぜならSendMessageが戻るのを待っているからだ。もしメッセージを受け取るスレッドが送り手と同じキューに取り付けてあるなら、アプリのデッドロック（deadlock）を引き起こしうる。（Note that journal hooks attach threads to the same queue.）\r\n\r\nメッセージを受け取るスレッドは明示的に制御を明け渡す必要はない。以下に挙げた関数の呼び出しは、暗黙的な制御の明け渡しを引き起こす。\r\n\r\n * DialogBox\r\n * DialogBoxIndirect\r\n * DialogBoxIndirectParam\r\n * DialogBoxParam\r\n * GetMessage\r\n * MessageBox\r\n * PeekMessage\r\n * SendMessage\r\n\r\nアプリで潜在的なデッドロックを避けるために、SendNotifyMessageやSendMessageTimeout関数を使うことを考慮せよ。さもなければウィンドウプロシージャは、InSendMessageやInSendMessageEx関数を呼び出すことで別のスレッドから送信されたメッセージを受け取ったか確かめることができる。メッセージを処理する間、前記のリストに挙がっている関数のいずれかを呼び出す前に、ウィンドウプロシージャは、InSendMessageかInSendMessageEx関数を最初に呼ぶべきだ。もしこの関数がTRUEを返したなら、ウィンドウプロシージャは、スレッドの制御の受け渡しを行う関数呼び出しの前にReplyMessage関数を呼び出さなければならない。', '', '', '', '', 'GetMessage|MessageBox|PeekMessage|SendMessage|InSendMessage|InSendMessageEx|ReplyMessage|SendNotifyMessage|SendMessageTimeout', '2016-09-04 09:13:56', '2016-09-04 09:13:56', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Sending Messages', 'Broadcasting Messages'),
('Message Filtering', '', 'アプリは、GetMessageかPeekMessageでメッセージフィルターを指定して、メッセージキューから取得する特定のメッセージたちを選ぶことができる（他のメッセージを無視して）。フィルターは、メッセージ識別子の範囲（最初と最後の識別子で指定する）かウィンドウハンドル、またはその両方である。GetMessageとPeekMessageは、キューから取り出すメッセージを選択するために、メッセージフィルターを使う。メッセージフィルタリングは、アプリがキューにおいて後から到着したメッセージをメッセージキューから検索しなければならないときに便利である。また、ポストされたメッセージたちを処理する前に、入力（ハードウェア）メッセージたちを処理しなければならないときにも便利である。\r\n\r\nWM_KEYFIRSTとWM_KEYLASTは、すべてのキーボードメッセージを取得するためのフィルター値として使える。WM_MOUSEFIRSTとWM_MOUSELASTは、すべてのマウスメッセージを取り出すのに使える。\r\n\r\nメッセージをフィルタリングするどんなアプリも、メッセージフィルターを満たすメッセージがポストされうることを保証しなければならない。例えば、アプリが、キーボード入力を受け付けないウィンドウでWM_CHARメッセージをフィルタリングしたなら、GetMessage関数は戻らない。これはアプリを事実上ハングさせる。', '', '', '', '', 'GetMessage|PeekMessage|WM_CHAR', '2016-09-04 02:35:26', '2016-09-04 02:35:26', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Window Procedure', 'Posting and Sending Messages'),
('Message Handling', '', 'アプリは、アプリのスレッドたちのメッセージキューにポストされたメッセージを取り除き、処理しなければならない。シングルスレッドのアプリは通常、メッセージを取り除き、適切なウィンドウプロシージャに送信するためにWinMain関数においてメッセージループを使う。マルチスレッドのアプリは、ウィンドウを作成したそれぞれのスレッドにメッセージループを含むことができる。このセクションではどのようにメッセージループが働くかを説明し、ウィンドウプロシージャの役割を説明する。\r\n\r\n * メッセージループ\r\n * ウィンドウプロシージャ', '', '', '', '', 'Message Loop|Window Procedure', '2016-09-04 01:43:01', '2016-09-04 01:43:01', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Nonqueued Messages', 'Message Loop'),
('Message Loop', '', '単純なメッセージループは、３つの関数の呼び出しからなる。もしエラーがあればGetMessageは-1を返すので、特殊なテストが必要であるから注意しよう。\r\n\r\n<pre>MSG msg;\r\nBOOL bRet;\r\nwhile( (bRet = GetMessage( &msg, NULL, 0, 0 )) != 0)\r\n{ \r\n    if (bRet == -1)\r\n    {\r\n        // handle the error and possibly exit\r\n    }\r\n    else\r\n    {\r\n        TranslateMessage(&msg); \r\n        DispatchMessage(&msg); \r\n    }\r\n}</pre>\r\n\r\nGetMessage関数は、キューからメッセージを取得し、MSG構造体へコピーする。それはWM_QUITメッセージに遭遇しない限り、非ゼロの値を返す。WM_QUITの場合、FALSEを返し、ループを終了する。シングルスレッドのアプリの場合、メッセージループの終了はたいてい、アプリを閉じる最初のステップである。アプリはPostQuitMessage関数によりループを終了することができる。それは、アプリのメインウィンドウのウィンドウプロシージャにおけるWM_DESTROYメッセージへの反応としてである。\r\n\r\nもし、GetMessageの二番目のパラメータとしてウィンドウハンドルが指定されたら、指定されたウィンドウのメッセージのみが取得される。GetMessageはキューのメッセージたちを特定の範囲でフィルタリングすることができる。詳しくはメッセージのフィルタリングを参照せよ。\r\n\r\nスレッドのメッセージループは、スレッドがキーボードからの文字入力を受け取るなら、TranslateMessageを含まなければならない。システムはユーザーあｇキーを押すたびに、仮想キーメッセージ（WM_KEYDOWNとWM_KEYUP）を生成する。仮想キーメッセージは押されたキーを識別する仮想キーコードを含む（文字コードではない）。文字コードを取得するために、メッセージループはTranslateMessageを含まなければならない。TranslateMessageは、仮想キーメッセージを文字メッセージ（WM_CHAR）に変換し、アプリのメッセージキューに戻す。文字メッセージは、メッセージキューの反復によって取り除かれ、ウィンドウプロシージャに発送される。\r\n\r\nDispatchMessage関数は、MSG構造体で指定されたウィンドウハンドルに関連付けられたウィンドウプロシージャにメッセージを送信する。もしウィンドウハンドルがHWND_TOPMOSTなら、DispatchMessageは、すべてのトップレベルのウィンドウのウィンドウプロシージャにメッセージを送信する。もしウィンドウハンドルがNULLなら、このメッセージについては何もしない。\r\n\r\nアプリのメインスレッドが、アプリの初期化と1個以上のウィンドウの作成をした後、メッセージループを開始する。それが開始した後、メッセージループはスレッドのメッセージキューからメッセージを取得し、それを適切なウィンドウへ発送し続ける。メッセージループが終わるのは、GetMessage関数がメッセージキューからWM_QUITメッセージを取り除いたときだ。\r\n\r\nアプリが複数のウィンドウを持っていたとしても、一つのメッセージキューに対して一つだけのメッセージループが必要だ。DispatchMessageは常に適切なウィンドウにメッセージを配送する。これができるのは、キューの各メッセージがウィンドウハンドルを含むMSG構造体であるからだ。\r\n\r\nプログラマは、いくつかの方法でメッセージキューを改変できる。例えば、キューからメッセージをウィンドウに配送せずに、取得することができる。これはアプリがウィンドウを指定せずにメッセージをポストするのに便利である。またほかのメッセージがキューに留めておきながら、特定のメッセージを検索するためにGetMessageを使うことができる。これは一時的にメッセージキューの通常のFIFO順を飛び越えなければならないときに便利だ。\r\n\r\nアクセラレータキーを使うアプリは、キーボードメッセージをコマンドメッセージに変換しなければならない。これをするために、アプリのメッセージキューはTranslateAccelerator関数への呼び出しを含まなければならない。アクセラレータキーの詳細についてはキーボードアクセラレータを参照せよ。\r\n\r\nもしスレッドがモードレスダイアログを使うなら、メッセージループはダイアログがキーボード入力を受け取ることができるようにIsDialogMessage関数を含まなければならない。', '', '', '', '', 'GetMessage|TranslateMessage|DispatchMessage|MSG|WM_KEYDOWN|WM_KEYUP|IsDialogMessage|TranslateAccelerator', '2016-09-04 02:04:48', '2016-09-04 02:04:48', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Message Handling', 'Window Procedure'),
('Message Routing', '', 'システムは、ウィンドウプロシージャにメッセージを輸送するのに２つの手段を使う：一時的にメッセージを格納するためのメッセージキューと呼ばれる、システム定義のメモリーオブジェクトであるFIFOキューにポストすること。もう一つは、ウィンドウプロシージャに直接メッセージを送信することである。\r\n\r\nメッセージキューにポストされたメッセージは、「キューされたメッセージ」と呼ばれる。それらは主に、マウスやキーボードからのユーザー入力の結果として、例えばWM_MOUSEMOVE、WM_LBUTTONDOWN、WM_KEYDOWN、WM_CHARメッセージである。ほかのキューされたメッセージは、タイマー、描画、終了メッセージである：WM_TIMER、WM_PAINT、WM_QUIT。ウィンドウプロシージャに直接送信される他のほとんどのメッセージは、「キューされなかったメッセージ」と呼ばれる。\r\n\r\n * キューされたメッセージ\r\n * キューされなかったメッセージ', '', '', '', '', 'Queued Messages|Nonqueued Messages|WM_KEYDOWN|WM_CHAR', '2016-09-04 01:03:16', '2016-09-04 01:03:16', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Application-Defined Messages', 'Queued Messages'),
('Message Types', '', 'このセクションは、２種類のメッセージを説明する。\r\n\r\n * システム定義のメッセージ\r\n * アプリ定義のメッセージ', '', '', '', '', 'System-Defined Messages|Application-Defined Messages', '2016-09-04 00:20:32', '2016-09-04 00:20:32', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Windows Messages', 'System-Defined Messages'),
('Named Objects', '', 'IME は、ローカルシステムにおいて、複数のプロセスからアクセスされる様々な名前付きオブジェクトを作成したいかもしれない。そのようなオブジェクトは、ファイル、ミューテックス、イベントを含むかもしれない。プロセスは、対話的にログオンしている別のユーザに属するので、（セキュリティ属性へのポインタとして NULL を指定して、IME がオブジェクトを作成したときにシステムによって作成された）既定のセキュリティ属性は、すべてのプロセスにとって適切ではないかもしれない。\r\n\r\nWindows NT では、IME の最初のクライアントプロセスは、Winlogon プロセスかもしれない。Winlogon プロセスとは、ユーザがシステムにログオンするプロセスである。Winlogon プロセスは、ログオンセッションの間、システムアカウントに属するのだが、それがシステムがシャットダウンするまで生きていて、既定のセキュリティ属性で IME によって作成された名前付きオブジェクトは、ログオンセッションの間、他のログオンしたユーザに属する他のプロセスを通じてはアクセスできない。\r\n\r\n名前付きオブジェクトに対して適切に設定されたセキュリティ属性を作成するサンプル IME ソースコードは、Microsoft Platform DDK で提供されている。サンプルコードを使えば、IME を書く人は、ローカルシステム上の IME のすべてのクライアントプロセスからアクセスされる、様々な名前付きオブジェクトを作成できる。サンプルコードによって割り当てられるセキュリティ属性は、プロセスごとである。IME は、取り付け時にセキュリティ属性を初期化、または取り外し時にセキュリティ属性を解放するために、名前付きオブジェクトをしばしば作成したいかもしれない。名前付きオブジェクトを作成しない IME は、しばしば、名前付きオブジェクトの作成の直前に、セキュリティ属性を初期化したいかもしれないし、オブジェクトが作成された直後にセキュリティ属性を解放したいかもしれない。', '', '', '', '', '', '2016-09-10 11:00:53', '2016-09-10 11:00:53', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('NI_CHANGECANDIDATELIST', 'アクション', 'アプリは現在選択中の候補リストを変更する。', '', 'dwIndex --- 選択する候補リストのインデックス。\r\n///\r\ndwValue --- 使われない。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'NotifyIME', '2016-08-29 06:46:39', '2016-08-29 06:46:39', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('NI_CLOSECANDIDATE', 'アクション', 'アプリは IME に候補リストを閉じさせる。もし IME\r\nが候補リストを閉じたら、IME は\r\nWM_IME_NOTIFY （サブ関数は\r\nIMN_CLOSECANDIDATE）メッセージを送信す\r\nる。', '', 'dwIndex --- 閉じる候補リストのインデックス。\r\n///\r\ndwValue --- 使われない。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'NotifyIME', '2016-08-29 06:45:07', '2016-08-29 06:45:07', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('NI_COMPOSITIONSTR', 'アクション', 'アプリはコンポジション文字列を変更する。このア\r\nクションは、コンポジション文字列が入力コンテキ\r\nストに存在するときのみ有効である。', '', 'dwIndex --- 以下の値が dwIndex に与えられ\r\nる：\r\n\r\n[table:NI_COMPOSITIONSTR_Table1]\r\n///\r\ndwValue --- 使われない。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'NotifyIME', '2016-08-29 06:50:02', '2016-08-29 06:50:02', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('NI_CONTEXTUPDATED', 'アクション', 'アプリかシステムが入力コンテキストを更新する。', '', 'dwIndex --- dwValue の値がIMC_SETCONVERSIONMODEのとき、dwIndex は前の変換モードである。dwValue の値が\r\nIMC_SETSENTENCEMODE のとき、 dwIndex は前のセンテンスモードである。その他の dwValueについては dwIndex は使用されな\r\nい。\r\n///\r\ndwValue --- WM_IME_CONTROL メッセージで使われる以下の値のうちの一つ：\r\n\r\n * IMC_SETCANDIDATEPOS\r\n * IMC_SETCOMPOSITIONFONT\r\n * IMC_SETCOMPOSITIONWINDOW\r\n * IMC_SETCONVERSIONMODE\r\n * IMC_SETSENTENCEMODE\r\n * IMC_SETOPENSTATUS', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'NotifyIME', '2016-08-29 06:48:58', '2016-08-29 06:48:58', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('NI_OPENCANDIDATE', 'アクション', 'アプリは IME に候補リストを開かせる。もし IME が\r\n候補リストを開いたら、IME は WM_IME_NOTIFY\r\n（サブ関数は IMN_OPENCANDIDATE）メッセー\r\nジを送信する。', '', 'dwIndex --- 開く候補リストのインデックス。\r\n///\r\ndwValue --- 使われない。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'NotifyIME', '2016-08-29 06:44:05', '2016-08-29 06:44:05', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('NI_SELECTCANDIDATESTR', 'アクション', 'アプリは候補の一つを選択する。', '', 'dwIndex --- 選択する候補リストのインデックス。\r\n///\r\ndwValue --- 選択する候補リスト中の候補文字列のインデックス。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'NotifyIME', '2016-08-29 06:45:55', '2016-08-29 06:45:55', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('NI_SETCANDIDATE_PAGESIZE', 'アクション', 'アプリは、候補リストのページサイズを変更する。', '', 'dwIndex --- 変更する候補リストのインデックス。\r\n///\r\ndwValue --- 新しいページサイズ。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'NotifyIME', '2016-08-29 06:47:54', '2016-08-29 06:47:54', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('NI_SETCANDIDATE_PAGESTART', 'アクション', 'アプリは候補リストのページ開始インデックスを変\r\n更する。', '', 'dwIndex --- 変更する候補リストのインデックス。\r\n///\r\ndwValue --- 新しいページ開始インデックス。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'NotifyIME', '2016-08-29 06:47:17', '2016-08-29 06:47:17', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Nonqueued Messages', '', 'キューされなかったメッセージは、システムメッセージキューやスレッドメッセージキューを飛び越えて送信先ウィンドウプロシージャにすぐに送信される。システムはウィンドウに影響するイベントを通知するためにキューされなかったメッセージを送信する。例えば、ユーザーが新しいアプリウィンドウをアクティブ化したとき、システムはウィンドウにWM_ACTIVATE、WM_SETFOCUS、WM_SETCURSORなどの一連のメッセージたちを送信する。これらのメッセージはウィンドウがアクティブ化されたことや、キーボード入力がウィンドウに向かっていることや、マウスカーソルがウィンドウの境界線内部に移動したことなどをウィンドウに伝える。キューされなかったメッセージたちは、アプリが特定のシステム関数を呼んだときに引き起こされることがある。例えば、アプリがウィンドウを移動するためにSetWindowPos関数を使った後で、システムはWM_WINDOWPOSCHANGEDメッセージを送信する\r\n\r\nキューされなかったメッセージを送信する関数は、BroadcastSystemMessage、SendMessage、SendMessageTimeout、SendNotifyMessageである。', '', '', '', '', 'BroadcastSystemMessage|BroadcastSystemMessageEx|SendMessage|SendMessageTimeout|SendNotifyMessage', '2016-09-04 01:39:22', '2016-09-04 01:39:22', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Queued Messages', 'Message Handling'),
('Nonsystem Character Messages', '', 'ウィンドウプロシージャは、次の文字メッセージを受け取ることができる：WM_CHAR、WM_DEADCHAR、WM_SYSCHAR、WM_SYSDEADCHAR、そしてWM_UNICHAR。TranslateMessage関数はWM_KEYDOWNメッセージを処理したときにWM_CHARかWM_DEADCHARメッセージを生成する。同じようにWM_SYSKEYDOWNメッセージを処理したときに、WM_SYSCHARまたはWM_SYSDEADCHARメッセージを生成する。\r\n\r\nキーボード入力を処理するアプリは、たいていWM_CHARとWM_UNICHAR以外のすべてのメッセージを無視し、DefWindowProc関数に渡す。注意するが、WM_CHARは16ビットUnicode（UTF-16）であり、WM_UNICHARはUTF-32である。システムは、WM_SYSCHARとWM_SYSDEADCHARメッセージを、メニューのニーモニックを実装するために使う。\r\n\r\nすべての文字メッセージのwParamパラメータは、押された文字キーの文字コードを持つ。文字コードの値は、メッセージを受け取るウィンドウのウィンドウクラスに依存する。もし、ウィンドウクラスを登録するのに、UnicodeのRegisterClassが使われたら、システムはそのクラスのすべてのウィンドウにUnicode文字を提供する。さもなければ、システムはASCII文字コードを提供する。詳しくはUnicodeと文字セットを参照せよ。\r\n\r\n文字メッセージのlParamパラメータの中身は、文字メッセージの生成の前のキー押しメッセージのlParamパラメータの中身と同じである。詳しくはキーストロークメッセージのフラグたちを参照せよ。', '', '', '', '', '', '2016-09-15 02:35:07', '2016-09-15 02:35:07', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Normal Reconversion', '', '有能な変換結果に対しては、アプリは、情報文字列をつけた RECONVERTSTRING 構造体を提供すべきである。この場合、コンポジション文字列は、文字列全体ではなく、ターゲットの文字列と同じである。IME は全体の文字列を参照することでコンポジション文字列を変換でき、変換結果によりターゲットの文節をセットする。', '', '', '', '', 'RECONVERTSTRING', '2016-09-10 10:40:02', '2016-09-10 10:40:02', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('NotifyIME', '関数', 'NotifyIME 関数は、与えられた引数に従って IME の状態を変更する。', 'BOOL WINAPI NotifyIME(\r\n    HIMC  hIMC,\r\n    DWORD dwAction,\r\n    DWORD dwIndex,\r\n    DWORD dwValue)', 'hIMC --- 入力コンテキストのハンドル。\r\n///\r\ndwAction --- 以下は、アプリが引数 dwAction に指定できるコンテキスト項目である。\r\n\r\n * NI_OPENCANDIDATE\r\n * NI_CLOSECANDIDATE\r\n * NI_SELECTCANDIDATESTR\r\n * NI_CHANGECANDIDATELIST\r\n * NI_SETCANDIDATE_PAGESTART\r\n * NI_SETCANDIDATE_PAGESIZE\r\n * NI_CONTEXTUPDATED\r\n * NI_COMPOSITIONSTR\r\n///\r\ndwIndex --- uAction に依存する。\r\n///\r\ndwValue --- uAction に依存する。', '関数が成功すれば、戻り値は TRUE である。さもなければ戻り値は FALSE である。', '', 'ImmNotifyIME|NI_OPENCANDIDATE|NI_CLOSECANDIDATE|NI_SELECTCANDIDATESTR|NI_CHANGECANDIDATELIST|NI_SETCANDIDATE_PAGESTART|NI_SETCANDIDATE_PAGESIZE|NI_CONTEXTUPDATED|NI_COMPOSITIONSTR', '2016-08-29 06:40:47', '2016-08-29 06:40:47', '', 'IME', 'Win32 Multilingual IME Application Programming Interface Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('OemKeyScan', '関数', '0～0x0FF の OEM ASCII コードを、OEM スキャンコードとシフト状態へ変換します。この関数は、キーボード入力をシミュレートすることによって、あるプログラムが他のプログラムへ OEM テキストを送信できるようにします。', 'DWORD OemKeyScan(\r\n  WORD wOemChar   // OEM 文字の ASCII 値\r\n);', 'wOemChar［入力］ --- OEM 文字の ASCII 値を指定します。', '指定された OEM 文字のスキャンコードが下位ワードに、シフト状態が上位ワードに返ります。後者は、次のビットの組み合わせになります。\r\n\r\n[table:OemKeyScan_Table1]\r\n\r\n現在のキーボードレイアウトで、その文字を 1 回のキーストロークで生成できないときは、-1 が返ります。', 'この関数は、Ctrl+Alt、またはデッドキーを必要とする文字の変換をサポートしていません。この関数が変換しない文字をコピーするには、Alt+ 数値キーによるコード入力の方法で入力をシミュレートしなければなりません。このとき、NumLock キーを OFF にしなければなりません。デッドキーの名前はそのとおり（ たとえば「\'」）に出力されます。（ 英語以外の言語ではアクセントやウムラウトなどの文字飾りを使うことがあります。たとえば、最初に「\'」、次に「a」を押すと、アクサンテギュ付きの a を入力できるキーボードと OS があります。このような場合、「\'」をデッドキーと呼びます。）\r\n\r\nデッドキーを必要とするアクセント付きの文字など、現在のキーボードレイアウトで 1 回のキーストロークで入力できない文字の変換については、この関数はサポートしていません。この関数が変換しない文字は、Alt+ 数値キーによるコード入力方法でシミュレートできることがあります。このとき、NumLock キーを ON にしなければなりません。\r\n\r\nこの関数は、VkKeyScan 関数を使って実装されています。', 'VkKeyScan', '2016-09-11 08:28:40', '2016-09-11 08:28:40', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc410926.aspx', 'Microsoft', '', '', '', ''),
('Overview of IMM/IME', '', 'Windows 95 と NT 4.0 以降では、IME （Input Method Editor；入力方式エディタ） という入力用のソフトが、古い Windows 3.1 極東エディションの IME とは異なり、DLL 形式で提供される。それぞれの IME が多言語キーワードレイアウトの一つとして実行される。古い Windows 3.1 IME と比較して、新しい Win32 IMM（多言語入力方式マネージャ）と IME（入力方式エディタ）のアーキテクチャは以下の利点がある：\r\n\r\n * 多言語環境のコンポーネントとして走り、\r\n * それぞれのアプリのタスクごとに複数のインプットコンテキスト (Input Context)が提供され、\r\n * それぞれのアプリのスレッドごとに一つのアクティブな IME が保たれ、\r\n * （メッセージ順を壊すことなく）メッセージループを通じて、アプリに情報を提供し、\r\n * IME を意識したアプリかそうでないかに関わらず、強いサポートを提供する。\r\n\r\nこれらの利点を完全に役立たせるために、アプリは新しい Win32 IMM/IME アプリインターフェイスをサポートする必要がある。\r\n\r\nWindows 95 と Windows NT 4.0 の 存在する IME との最大限の互換性を保つために、Windows 98 とWindows 2000 は設計において主な変更を行っていない。しかしながら、よりよいシステム統合とより賢い IMEをサポートするために、新しい特徴が追加されている。', '', '', '', 'IME 開発者は、<imm.h>のスーパーセットである、DDK の<immdev.h>を使わなければならない。', '', '2016-09-10 10:09:26', '2016-09-10 10:09:26', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('PeekMessage', '関数', '着信した送信済みメッセージをディスパッチ（送出）し、スレッドのメッセージキューにポスト済みメッセージが存在するかどうかをチェックし、存在する場合は、指定された構造体にそのメッセージを格納します。', 'BOOL PeekMessage(\r\n  LPMSG lpMsg,         // メッセージ情報\r\n  HWND hWnd,           // ウィンドウのハンドル\r\n  UINT wMsgFilterMin,  // 最初のメッセージ\r\n  UINT wMsgFilterMax,  // 最後のメッセージ\r\n  UINT wRemoveMsg      // 削除オプション\r\n);', 'lpMsg --- 1 個の 構造体へのポインタを指定します。関数から制御が返ると、この構造体に、メッセージ情報が格納されます。\r\n///\r\nhWnd --- メッセージの取得に使う（取得元）ウィンドウのハンドルを指定します。\r\n///\r\nwMsgFilterMin --- 取得対象のメッセージの最小値を整数で指定します。\r\n///\r\nwMsgFilterMax --- 取得対象のメッセージの最大値を整数で指定します。\r\n///\r\nwRemoveMsg --- メッセージの処理方法を指定します。次の値のいずれかを指定します。 \r\n\r\n[table:PeekMessage_Table1]\r\n\r\nオプションで、PM_NOYIELD フラグを、PM_NOREMOVE と PM_REMOVE のどちらかのフラグに組み合わせて使うこともできます。PM_NOYIELD フラグを指定すると、呼び出し側がアイドル状態になるのを待っているスレッドが存在する場合、システムがそのスレッドを解放することを防止できます（ 関数を参照してください）。 \r\n\r\n既定では、PeekMessage 関数はすべてのメッセージタイプを処理します。特定のメッセージタイプだけを処理するよう指定するには、次の値のいずれかまたは任意の組み合わせを指定してください。\r\n\r\n[table:PeekMessage_Table2]', 'メッセージを取得した場合、0 以外の値が返ります。\r\n\r\nメッセージを取得しなかった場合、0 が返ります。', 'PeekMessage 関数は、hWnd パラメータで指定したウィンドウと、IsChild function 関数で子と判断されるウィンドウのいずれかに関連付けられているメッセージのうち、wMsgFilterMin と wMsgFilterMax の各パラメータで指定されたメッセージ範囲に該当するものだけを取得します。hWnd パラメータで NULL を指定した場合、PeekMessage 関数を呼び出した現在のスレッドに所属する任意のウィンドウに関連付けられているメッセージを取得します（PeekMessage 関数は、ほかのスレッドに所属するウィンドウに関連付けられているメッセージは取得しません）。hWnd パラメータで -1 を指定すると、PeekMessage 関数は、PostThreadMessage 関数がポストした、hWnd パラメータで NULL を指定しているメッセージを取得します。wMsgFilterMin と wMsgFilterMax の両方のパラメータで 0 を指定すると、PeekMessage は利用可能なすべてのメッセージを返します（メッセージのフィルタリングを行いません）。wMsgFilterMin と wMsgFilterMax の各パラメータでどのような値を指定した場合でも、PeekMessage は必ず WM_QUIT メッセージを取得することに注意してください。\r\n\r\nwMsgFilterMin パラメータで WM_KEYFIRST 定数、wMsgFilterMax パラメータで WM_KEYLAST 定数を指定すると、キーボード入力に関係するメッセージだけを取得できます。同様に、それぞれ WM_MOUSEFIRST 定数と WM_MOUSELAST 定数を指定すると、マウスに関係するメッセージだけを取得できます。\r\n\r\nPeekMessage 関数を呼び出すと、呼び出し側スレッドが所有しているウィンドウへ送信されたメッセージのうち、保留されていたものを取得できます。SendMessage、SendMessageCallback、SendMessageTimeout、SendNotifyMessage の各関数を使って送信されたメッセージが、これに該当します。システムは、内部イベントを処理することもあります。メッセージは、次の順序で処理されます。\r\n\r\n * 送信済みメッセージ\r\n * ポスト済みメッセージ\r\n * 入力（ハードウェア）メッセージとシステムの内部イベント\r\n * 送信済みメッセージ（再度）\r\n * WM_PAINT メッセージ\r\n * WM_TIMER メッセージ\r\n\r\nポスト済みメッセージより先に入力メッセージを取得するには、wMsgFilterMin と wMsgFilterMax の各パラメータを使ってください。メッセージの値の一覧については、MSDN ライブラリの［検索］タブで「4.6 Event Notification Interface」と「WM_APP」を参照してください。\r\n\r\nPeekMessage 関数は通常、メッセージキューから WM_PAINT メッセージを削除しません。WM_PAINT メッセージは、処理が終わるまではキュー内にとどまります。ただし、WM_PAINT メッセージの更新領域が NULL の場合、PeekMessage 関数はその WM_PAINT メッセージを削除します。', 'GetMessage|IsChild|MSG|WaitMessage|PeekMessage', '2016-08-28 05:13:29', '2016-08-28 05:13:29', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc410948.aspx', 'Microsoft', '', '', '', ''),
('Posting and Sending Messages', '', 'どんなアプリもメッセージをポストし、送信できる。システムのように、アプリはメッセージをメッセージキューにコピーすることにより、メッセージをポストし、ウィンドウプロシージャへ引数としてメッセージデータを渡すことでメッセージを送信できる。メッセージをポストするためにはPostMessage関数を使う。アプリは、SendMessage、BroadcastSystemMessage、SendMessageCallback、SendMessageTimeout、SendNotifyMessage、SendDlgItemMessage関数を使うことでメッセージを送信できる。\r\n\r\n * メッセージのポスト\r\n * メッセージの送信', '', '', '', '', 'Posting Messages|Sending Messages|PostMessage|SendMessage|BroadcastSystemMessage|SendMessageCallback|SendMessageTimeout|SendNotifyMessage', '2016-09-04 02:43:10', '2016-09-04 02:43:10', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Message Filtering', 'Posting Messages'),
('Posting Messages', '', 'アプリは、タスクを実行するために、メッセージをポストすることにより特定のウィンドウに通知する。PostMessageはメッセージに対してMSG構造体を作り、メッセージキューにメッセージをコピーする。アプリのメッセージループは最後にメッセージを取り出し、適切なウィンドウプロシージャにそれを配送する。\r\n\r\nアプリは、ウィンドウを指定せずにメッセージをポストできる。もしPostMessageを呼ぶときにウィンドウハンドルにNULLを指定したら、メッセージは現在のスレッドに関連付けられたキューにポストされる。ウィンドウハンドルが指定されなかったので、アプリは、メッセージループにおいてそのメッセージを処理しなければならない。これは特定のウィンドウではなく、すべてのアプリに適用されるメッセージを作成する方法の一つである。\r\n\r\n時々あなたはすべてのトップレベルのウィンドウにメッセージをポストしたいと考えるかもしれない。アプリはhwndパラメータにHWND_TOPMOSTを指定してPostMessageを呼び出すことで、すべてのトップレベルのウィンドウにメッセージをポストできる。\r\n\r\nありふれたプログラムの間違いは、PostMessage関数が常にメッセージをポストできると思い込むことだ。これはメッセージキューがいっぱいのとき嘘である。アプリはメッセージがポストされたかされていないかを確認するためにPostMessage関数の戻り値をチェックすべきである。', '', '', '', '', 'MSG', '2016-09-04 07:44:32', '2016-09-04 07:44:32', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Posting and Sending Messages', 'Sending Messages'),
('PostMessage', '関数', '指定されたウィンドウを作成したスレッドに関連付けられているメッセージキューに、1 つのメッセージをポストします（書き込みます）。対応するスレッドがメッセージを処理するのを待たずに制御を返します。\r\n\r\n任意のスレッドに関連付けられているメッセージキューに 1 つのメッセージをポストするには、PostThreadMessage 関数を使ってください。', 'BOOL PostMessage(\r\n  HWND hWnd,      // ポスト先ウィンドウのハンドル\r\n  UINT Msg,       // メッセージ\r\n  WPARAM wParam,  // メッセージの最初のパラメータ\r\n  LPARAM lParam   // メッセージの 2 番目のパラメータ\r\n);', 'hWnd --- 1 つのウィンドウのハンドルを指定します。このウィンドウのウィンドウプロシージャは、ポストされたメッセージを受信します。次の値には、特別な意味があります。 \r\n\r\n[table:PostMessage_Table1]\r\n///\r\nMsg --- ポストするべきメッセージを指定します。\r\n///\r\nwParam --- メッセージ特有の追加情報を指定します。\r\n///\r\nlParam --- メッセージ特有の追加情報を指定します。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、 関数を使います。', 'GetMessage または PeekMessage 関数を呼び出すと、1 つのメッセージキューの中のメッセージを取得できます。\r\n\r\nHWND_BROADCAST フラグを使って通信を行う必要がある複数のアプリケーションは、アプリケーション間通信の専用メッセージを取得する目的では、RegisterWindowMessage 関数を呼び出すべきです。\r\n\r\n非同期メッセージ関数（PostMessage、SendNotifyMessage、SendMessageCallback の各関数）を使って、WM_USER 未満のメッセージ（メッセージの値が 0x8000 未満）を送信する場合は、メッセージのパラメータでポインタを使うことはできません。もしポインタを使っている場合、その操作は失敗します。PostMessage 関数は、受信側スレッドがそのメッセージを処理する前に制御を返します。そのため、受信側スレッドがメッセージの処理を開始する前に、送信側スレッドは、ポインタが指すメモリを解放してしまいます。メッセージの値の一覧については、MSDN ライブラリの「WM_APP」を参照してください。\r\n\r\nPostMessage 関数を使って メッセージをポストすることは避けてください。代わりに、PostQuitMessage 関数を使ってください。\r\n\r\nWindows 2000：1 つのメッセージキューに一度に存在できるポスト済みメッセージの数は、既定では最大 10,000 個です。この上限は、十分大きい値にしておくべきです。もしアプリケーションがこの上限を超えてしまう場合、それほど多くのシステムリソースを消費することがないよう、そのアプリケーションを設計し直すべきです。代わりに、この上限を変更するには、次のレジストリエントリを変更してください（このレジストリエントリが登録されていない場合、［編集］－［値の追加］を選択し、データ型として REG_DWORD を指定し、10 進数を入力してください）。\r\n\r\n<pre>\r\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\USERPostMessageLimit.</pre>\r\n\r\nこのレジストリエントリで指定できる最小の値は、4,000 です。レジストリエディタを使って値を入力する際は、カンマ（,）なしで入力してください。', 'GetMessage|PeekMessage|PostQuitMessage|PostThreadMessage|RegisterWindowMessage|SendMessageCallback|SendNotifyMessage', '2016-08-28 05:17:07', '2016-08-28 05:17:07', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc410952.aspx', 'Microsoft', '', '', '', ''),
('PostThreadMessage', '関数', '指定されたスレッドのメッセージキューに 1 つのメッセージをポストします。この関数は、スレッドがメッセージを処理するのを待たず、即座に制御を返します。', 'BOOL PostThreadMessage(\r\n  DWORD idThread, // スレッドの識別子\r\n  UINT Msg,       // メッセージ\r\n  WPARAM wParam,  // メッセージの最初のパラメータ\r\n  LPARAM lParam   // メッセージの 2 番目のパラメータ\r\n);', 'idThread --- スレッドの識別子を指定します。この関数は、このスレッドのメッセージキューへメッセージをポストします。 \r\n指定されたスレッドがメッセージキューを備えていない場合、この関数は失敗します。スレッドが Win32 のユーザー関数または GDI 関数のいずれかを最初に呼び出した時点で、システムはそのスレッドのメッセージキューを作成します。詳細については、この関数の「解説」を参照してください。 \r\n\r\nWindows 2000：このスレッドは、呼び出し側と同じデスクトップ、または共通の LUID（Locally Unique Identifiier；ローカル一意識別子）を持つプロセスに所属していなければなりません。それ以外の場合、この関数は失敗し、ERROR_INVALID_THREAD_ID を返します。 \r\n///\r\nMsg --- ポストするべきメッセージのタイプを指定します。\r\n///\r\nwParam --- メッセージ特有の追加情報を指定します。\r\n///\r\nlParam --- メッセージ特有の追加情報を指定します。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、 関数を使います。idThread パラメータで指定したスレッドの識別子が無効だった場合、または idThread パラメータで指定したスレッドがメッセージキューを備えていなかった場合、GetLastError 関数は ERROR_INVALID_THREAD_ID を返します。', 'メッセージのポスト先であるスレッドで、あらかじめメッセージキューを作成しておかなければなりません。それ以外の場合、PostThreadMessage 関数は失敗します。この状況に対処するには、次の方法のいずれかを使ってください。\r\n\r\n * PostThreadMessage 関数を呼び出します。この関数が失敗した場合、 関数を呼び出し、もう一度 PostThreadMessage 関数を呼び出します。PostThreadMessage 関数が成功するまで、この作業を繰り返します。\r\n * 1 個のイベントオブジェクトを作成し、次にポスト先のスレッドを作成します。PostThreadMessage 関数を実行する前に、 関数を使って、そのイベントがシグナル状態になるのを待ちます。その後、ポスト先のスレッドで、PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE) を呼び出し、このスレッド用のメッセージキューを強制的に作成します。最後に、このスレッドがポスト済みメッセージを受信する準備ができたことを知らせるために、イベントをセットします（シグナル状態にします）。\r\n\r\nメッセージをポストした後、ポスト先のスレッドは GetMessage または PeekMessage 関数を使ってそのメッセージを取得します。このとき、返された 構造体の hwnd メンバは NULL になります。\r\n\r\nPostThreadMessage 関数を使って送信したメッセージは、どのウィンドウにも関連付けられていません。DispatchMessage 関数は、このようなメッセージをディスパッチできません。したがって、受信側のスレッドがモーダルループを実行している場合（MessageBox または DialogBox 関数はモーダルループを実行します）、そのメッセージは失われます。モーダルループを実行している際に、これらのスレッドメッセージを横取り（インターセプト）するには、スレッド特有のフックを使います。\r\n\r\nWindows 2000：1 つのメッセージキューに一度に存在できるポスト済みメッセージの数は、既定では最大 10,000 個です。この上限は、十分大きい値にしておくべきです。もしアプリケーションがこの上限を超えてしまう場合、それほど多くのシステムリソースを消費することがないよう、そのアプリケーションを設計し直すべきです。代わりに、この上限を変更するには、次のレジストリエントリを変更してください（このレジストリエントリが登録されていない場合、［編集］－［値の追加］を選択し、データ型として REG_DWORD を指定し、10 進数を入力してください）。\r\n\r\n<pre>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\USERPostMessageLimit.</pre>\r\n\r\nこのレジストリエントリで指定できる最小の値は、4,000 です。レジストリエディタを使って値を入力する際は、カンマ（,）なしで入力してください。', 'GetMessage|GetWindowThreadProcessId|MSG|PeekMessage|PostMessage', '2016-08-28 05:20:09', '2016-08-28 05:20:09', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc410979.aspx', 'Microsoft', '', '', '', ''),
('Previous Key-State Flag', '', '直前のキー状態フラグは、キーストロークメッセージを生成したキーが、直前に上がっているか、下がっているかどうかを表す。キーが直前に下がっていればそれは1である。キーが直前に上がっていればゼロである。このフラグは、キーボードの自動リピート機能によって生成されたキーストロークメッセーを識別するために使うことができる。このフラグは、自動リピート機能によって生成されたWM_KEYDOWNとWM_SYSKEYDOWNキーストロークメッセージたちについては、1である。WM_KEYUPとWM_SYSKEYUPについてはこの値は常にゼロである。', '', '', '', '', '', '2016-09-14 10:47:56', '2016-09-14 10:47:56', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('PRIMARYLANGID', 'マクロ', '言語識別子から主言語識別子を抽出します。', 'WORD PRIMARYLANGID(\r\n   WORD lgid\r\n);', 'lgid --- 言語識別子。この値は主言語識別子とサブ言語識別子の組み合わせであり、たいていMAKELANGIDマクロを使って作成されます。', '主言語識別子を返します。これは定義済みの主言語識別子か、ユーザー定義のサブ言語識別子です。詳しくは、MAKELANGIDをご覧下さい。', '', 'LANGIDFROMLCID|MAKELANGID|SUBLANGID', '2016-09-18 05:41:29', '2016-09-18 05:41:29', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd319102.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Query Messages', '', 'あなたは、あなたが所有するカスタムメッセージを作成でき、それらをアプリとシステムにおけるその他のコンポーネントたちの間の活動を組織するために使うことができる。これはもしあなた自身が、インストール可能なドライバーやシステムレベルのデバイスドライバーを作ったときに便利である。あなたのカスタムメッセージはドライバーとドライバーを使うアプリの間で情報をやり取りするのに使うことができる。\r\n\r\n与えられたアクションを実行する許可を与える受取人を登録するのに、問い合わせメッセージを使う。あなたはdwFlagsパラメータにBSF_QUERYの値をセットしたBroadcastSystemMessageを呼ぶことで、あなた自身の問い合わせメッセージを生成できる。問い合わせメッセージのそれぞれの受取人は、次の受取人にメッセージを送信するために、TRUEを関数の戻り値として返さなければならない。もしある受取人がBROADCAST_QUERY_DENYを戻り値として返せば、放映はすぐに終了し、関数はゼロを返す。', '', '', '', '', 'BroadcastSystemMessage', '2016-09-04 09:37:43', '2016-09-04 09:37:43', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Broadcasting Messages', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('Queued Messages', '', 'システムは、一度に何個のウィンドウも表示できる。マウスとキーボード入力を適切なウィンドウに輸送するために、システムはメッセージキューを使う。\r\n\r\nシステムは、一つのシステムメッセージキューと、各GUIスレッドに対してスレッド固有のメッセージキューを管理する。非GUIスレッドに対するメッセージキュー作成のオーバーヘッドを避けるために、すべてのスレッドは、初期状態ではメッセージキューなしに作成される。システムは、スレッドが特定のユーザー関数の一つの最初の呼び出しを行ったときのみ、スレッド固有のメッセージキューを作成する。GUI関数の呼び出しは、メッセージキューの作成にならない。\r\n\r\nユーザーがマウスを動かしたり、マウスボタンをクリックしたり、あるいはキーボードをタイプしたときはいつでも、マウスまたはキーボードのデバイスドライバーは入力をメッセージたちに変換し、それをシステムメッセージキューに格納する。システムはシステムメッセージキューからメッセージたちを送信先ウィンドウを決めて１度に１つずつ取り除き、それらを送信先ウィンドウを作成したスレッドのメッセージキューにポストする。スレッドのメッセージキューはスレッドによって作成されたウィンドウに対するすべてのマウス及びキーボードメッセージを受け取る。スレッドはキューからメッセージを取り除き、処理のため、システムに適切なウィンドウプロシージャに送信するようにシステムを指図する。\r\n\r\nWM_PAINT、WM_TIMER、WM_QUITメッセージの例外があるが、システムは常にメッセージキューの最後にメッセージをポストする。これはウィンドウが入力メッセージを適切なFIFOシーケンスで受け取ることを保証する。しかしながら、WM_PAINT、WM_TIMER、WM_QUITメッセージは、キューに保持されて、キューが他のメッセージを持たないときのみ、ウィンドウプロシージャに転送される。加えて、同じウィンドウに対する複数のWM_PAINTメッセージはクライアント領域の無効な領域を一つの領域に統合して一つのWM_PAINTメッセージに結合される。WM_PAINTの結合は、クライアント領域の中身を再描画しなければならない回数を削減する。\r\n\r\nシステムはMSG構造体を埋め、それをメッセージキューにコピーする形でメッセージをスレッドのメッセージキューにポストする。MSGの情報は、対象のウィンドウハンドル、メッセージ識別子、２つのメッセージパラメータ、メッセージがポストされた時間、マウスカーソルの位置を含む。スレッドは、スレッド自身のメッセージキュー、またはほかのスレッドのキューにPostMessage、またはPostThreadMessage関数を使ってメッセージをポストできる。\r\n\r\nアプリはGetMessage関数を使ってアプリのキューからメッセージを取り除くことができる。メッセージをキューから取り除かずにメッセージを検査するために、アプリはPeekMessage関数を使うことができる。この関数はMSGをメッセージに関する情報で埋める。\r\n\r\nキューからメッセージを取り除いた後で、アプリはメッセージ処理の目的でシステムにウィンドウプロシージャにメッセージを送信するようにシステムに指図するためにDispatchMessage関数を使うことができる。DispatchMessageは、MSGへのポインタを直前のGetMessageやPeekMessage関数の呼び出しによって埋める。DispatchMesssageは、ウィンドウハンドル、メッセージ識別子、そして２つのメッセージパラメータをウィンドウプロシージャに渡すが、ポストされたメッセージの時間やマウスカーソルの位置は渡さない。アプリはメッセージを処理している間にこの情報をGetMessageTimeやGetMessagePosで取得できる。\r\n\r\nスレッドはメッセージキューにメッセージがないときにほかのスレッドに制御を引き起こすため、WaitMessage関数を使うことができる。この関数はスレッドを一時停止し、新しいメッセージがスレッドのメッセージキューに格納されるまで戻らない。\r\n\r\n現在のスレッドのメッセージキューに値を関連付けるために、SetMessageExtraInfo関数を呼ぶことができる。GetMessageかPeekMessage関数によって取得した最後のメッセージに関連付けられた値を取得するためにGetMessageExtraInfo関数を呼ぶことができる。', '', '', '', '', 'MSG|PostMessage|PostThreadMessage|GetMessage|PeekMessage|DispatchMessage|GetMessageTime|GetMessagePos|GetMessageExtraInfo|SetMessageExtraInfo', '2016-09-04 01:32:16', '2016-09-04 01:32:16', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Message Routing', 'Nonqueued Messages'),
('Reconversion', '', '再変換は、Windows 98 と Windows 2000 で登場した IME の新しい機能である。それは、アプリの文書にすでに挿入された文字列を再変換する能力を提供する。特に文字列が何であれ、IME は文字列を認識するよう指示され、読みや入力情報に変換し、そして候補リストを表示する。\r\n\r\n新しく、強化された賢い IME は、完全な文の認識や解釈の機能がある。IME が文字列について、よりよい情報を提供されたら（完全な文や文の区切り）、それはより良い変換パフォーマンスと正確性を遂行できる。例えば、再変換されると仮定した、完全な文を供給することで、IME は、最初に読みや入力情報がなくても、文字列を再変換できる。\r\n\r\n以前は、確定の後に編集することは困難であった。未確定の文字列が持つ情報（読み、句、音素）が失われるからだ。再変換は、それらの情報を取り戻そうとし、確定の後の編集が確定の前と同じように簡単になる。ユーザは、候補から別の同音語を選択でき、句の区切りを変更でき、IME に再び分析させることなどができる。\r\n\r\nRECONVERTSTRING 構造体は、すべての文を格納でき、 dwStartOffset と dwLen によって再変換される文字列を指し示すことができる。もし dwStartOffset がゼロで、dwLen が文字列の長さであれば、文字列全体が IME によって再変換される。\r\n\r\n * 単純な再変換\r\n * 普通の再変換\r\n * 強化された再変換', '', '', '', '', 'Simple Reconversion|Normal Reconversion|Enhanced Reconversion|RECONVERTSTRING', '2016-09-10 10:38:19', '2016-09-10 10:38:19', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('RECONVERTSTRING', '構造体', 'IME の再変換のための文字列たちを定義する。それは再変換のための\r\n文字列たちを含むメモリブロックにおいて最初の項目である。', 'typedef struct {\r\n    DWOPD dwSize;\r\n    DWORD dwVersion;\r\n    DWORD dwStrLen;\r\n    DWORD dwStrOffset;\r\n    DWORD dwCompStrLen;\r\n    DWORD dwCompStrOffset;\r\n    DWORD dwTargetStrLen;\r\n    DWORD dwTargetStrOffset;\r\n} RECONVERTSTRING;', 'dwSize --- この構造体のメモリーブロックのサイズ。\r\n///\r\ndwVersion --- システムで予約済み。ゼロでなければならない。\r\n///\r\ndwStrLen --- コンポジション文字列を含む文字列の長さ。\r\n///\r\ndwStrOffset --- この構造体の開始位置からのオフセット。再変換単語を含む文字列はここに格納される。\r\n///\r\ndwCompStrLen --- コンポジション文字列になる文字列の長さ。\r\n///\r\ndwCompStrOffset --- コンポジション文字列になる文字列のオフセット。\r\n///\r\ndwTargetStrLen --- コンポジション文字列においてターゲットの文節に関連する文字列の長さ。\r\n///\r\ndwTargetStrOffset --- コンポジション文字列においてターゲットの文節に関連する文字列のオフセット。', '', 'RECONVERTSTRING 構造体は、Windows 98 と Windows 2000 で新しく登場した。dwCompStrOffset と\r\ndwTargetOffset メンバーは、 dwStrOffset の相対的な位置となる。Windows NT Unicode については、\r\ndwStrLen、 dwCompStrLen、そして dwTargetStrLen は TCHAR の個数で、dwStrOffset、 dwCompStrOffset、 \r\nそして dwTargetStrOffset はバイトオフセットである。\r\n\r\nSCS_SETRECONVERTSTRING と SCS_QUERYRECONVERTSTRING をつけて\r\nImmSetCompositionString を呼ぶことによって、アプリが再変換プロセスを開始したら、アプリは、コンポジショ\r\nン文字列バッファと同様にこの構造体に対する必要なメモリーを確保する責任がある。IME は後になってこの\r\nメモリを使うべきではない。もし IME がプロセスを開始したら、IME は構造体とコンポジション文字列バッファ\r\nのために必要なメモリーを確保すべきである。', 'ImmSetCompositionString', '2016-09-10 04:16:23', '2016-09-10 04:16:23', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('RegisterHotKey', '関数', 'システムワイド（ システム全体に適用される）のホットキーを定義します。', 'BOOL RegisterHotKey(\r\n  HWND hWnd,         // ウィンドウのハンドル\r\n  int id,            // ホットキーの識別子\r\n  UINT fsModifiers,  // キー修飾子フラグ\r\n  UINT vk            // 仮想キーコード\r\n);', 'hWnd［入力］ --- ホットキーによって生成された WM_HOTKEY メッセージを受け取るウインドウのハンドルを指定します。このパラメータに NULL を指定したときは、WM_HOTKEY メッセージは呼び出し側のスレッドのメッセージキューにポストされるので、そのメッセージループで処理しなければなりません。\r\n///\r\nid［入力］ --- ホットキーの識別子を指定します。現在のスレッド内の他のホットキーは、同じ識別子を使うべきではありません。アプリケーションは、0x0000～0xBFFF の範囲の値を指定しなければなりません。共有ダイナミックリンクライブラリ（DLL）は、0xC000～0xFFFF（ 関数が返す範囲）の値を指定しなくてはなりません。他の共有 DLL との競合を避けるために、各 DLL は GlobalAddAtom 関数を使ってホットキーの識別子を取得するべきです。\r\n///\r\nfsModifiers［入力］ --- WM_HOTKEY メッセージを生成するために、nVirtKey パラメータで指定されたキーとともに押されるキーを指定します。次の値の任意の組み合わせを指定します。\r\n\r\n[table:RegisterHotKey_Table1]\r\n///\r\nvk［入力］ --- ホットキーの仮想キーコードを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、 関数を使います。', 'あるキーが押されると、システムはすべてのホットキーの中からそれに一致するものを探します。一致するものが見つかると、システムはそのホットキーを登録したスレッドのメッセージキューに WM_HOTKEY メッセージをポストします。このメッセージは、キューの先頭にポストされ、メッセージループの次の反復で削除されます。\r\n\r\nこの関数は、他のスレッドが生成したウィンドウにホットキーを関連付けることはできません。\r\n\r\nホットキーに割り当てようとしたキーストロークが、他のホットキーによって既に登録されている場合、RegisterHotKey 関数は失敗します。\r\n\r\nhWnd パラメータで指定されたウィンドウが、id パラメータで指定したのと同じ ID を持つホットキーを既に登録していた場合、fsModifiers パラメータと vk パラメータの値は、新しいものに置き換えられます。', 'Virtual-Key Codes|UnregisterHotKey', '2016-09-11 08:31:50', '2016-09-11 08:31:50', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411006.aspx', 'Microsoft', '', '', '', ''),
('REGISTERWORDA', '構造体', '登録する読み情報または単語を含みます。', 'typedef struct {\r\n  LPSTR lpReading;\r\n  LPSTR lpWord;\r\n} REGISTERWORDA;', 'lpReading --- 登録する単語の読み情報を表す文字列へのポインタです。もし読み情報が必要なければNULLにセットできます。\r\n///\r\nlpWord --- 登録する単語を表す文字列へのポインタです。単語が必要なければNULLにセットできます。', '', '', 'REGISTERWORD|REGISTERWORDW', '2016-08-29 03:09:26', '2016-08-29 03:09:26', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741232.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('REGISTERWORDW', '構造体', '読み情報または登録する単語を含みます。', 'typedef struct {\r\n  LPWSTR lpReading;\r\n  LPWSTR lpWord;\r\n} REGISTERWORDW;', 'lpReading --- 登録する単語の読み情報を表す文字列へのポインタです。もし読み情報が必要なければ、NULLにセットできます。\r\n///\r\nlpWord --- 登録する単語を表す文字列へのポインタです。もし単語が必要なければNULLにセットできます。', '', '', 'REGISTERWORD|REGISTERWORDA', '2016-08-29 03:11:28', '2016-08-29 03:11:28', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741233.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Repeat Count', '', 'キーストロークメッセージが1個以上のキーストロークを表しているかどうか確かめるために、リピートカウントをチェックすることができる。システムは、アプリがそれを処理するよりも早く、キーボードがWM_KEYDOWNかWM_SYSKEYDOWNを生成したときにそのカウントを１つ増加させる。これはユーザーがキーを十分長く押したときに、キーボードの自動リピート機能によって、引き起こされる。システムメッセージキューが、結果としてのキー押しメッセージたちで埋め尽くされる代わりに、システムは１つのキー押しメッセージに統合し、リピートカウントを増加させる。キーを離すことは、自動リピート機能を開始しないので、WM_KEYUPとWM_SYSKEYUPメッセージのリピートカウントは常に1にセットされる。', '', '', '', '', '', '2016-09-14 10:35:44', '2016-09-14 10:35:44', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('ReplyMessage', '関数', 'SendMessage 関数を呼び出した関数に制御を戻すことなく、その SendMessage 関数が送信してきたメッセージへ応答します。', 'BOOL ReplyMessage(\r\n  LRESULT lResult   // メッセージ特有の応答\r\n);', 'lResult --- メッセージ処理の結果を指定します。送信されてきたメッセージに基づいて、選択可能な値が決まります。', '呼び出し側スレッドが、ほかのスレッドまたはプロセスが送信してきたメッセージを処理していた場合、0 以外の値が返ります。\r\n\r\n呼び出し側スレッドが、ほかのスレッドまたはプロセスが送信しててきたメッセージを処理していなかった場合、0 が返ります。', 'この関数を呼び出すと、メッセージを受信したスレッドが制御を返した場合と同様、SendMessage 関数を呼び出したスレッドは動作を続けることができます。ReplayMessage 関数を呼び出したスレッドも、動作を続けます。\r\n\r\nSendMessage 関数を使わずにメッセージを送信した場合や、同じスレッドからメッセージを送信した場合、ReplyMessage 関数は何もしません。', 'InSendMessage|SendMessage', '2016-08-28 05:21:26', '2016-08-28 05:21:26', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411016.aspx', 'Microsoft', '', '', '', ''),
('Scan Code', '', 'スキャンコードは、ユーザーがキーを押したときに、キーボードハードウェアが生成した値である。それは押されたキーを識別するためのデバイス非依存の値であり、キーを表す文字とは対照的である。アプリはたいていスキャンコードを無視する。代わりに、キーストロークメッセージを解釈するためにデバイス非依存な仮想キーコードを使う。', '', '', '', '', '', '2016-09-14 10:38:59', '2016-09-14 10:38:59', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Security Concerns', '', 'Windows NT に対して、二つの主なセキュリティの関心事がある。一つは、名前付きオブジェクトで、もう一つは Winlogon である。\r\n\r\n * 名前付きオブジェクト\r\n * Winlogon', '', '', '', '', 'Named Objects|Winlogon', '2016-09-10 10:59:46', '2016-09-10 10:59:46', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('SendAsyncProc', '関数', 'SendMessageCallback 関数とともに使われる、アプリケーション定義のコールバック関数です。システムは、送信先のウィンドウプロシージャにメッセージを渡した後、このコールバック関数にそのメッセージを渡します。SENDASYNCPROC 型は、このコールバック関数へのポインタを定義します。SendAsyncProc 関数はアプリケーション定義の関数名のプレースホルダであり、実際にこの関数名を使う必要はありません。', 'VOID CALLBACK SendAsyncProc(\r\n  HWND hwnd,        // 送信先ウィンドウのハンドル\r\n  UINT uMsg,        // メッセージ\r\n  ULONG_PTR dwData, // アプリケーション定義の値\r\n  LRESULT lResult   // メッセージ処理の結果\r\n);', 'hwnd --- 1 つのウィンドウのハンドルを指定します。このウィンドウのウィンドウプロシージャがメッセージを受信します。 \r\nhwnd パラメータで HWND_BROADCAST フラグを指定して SendMessageCallback 関数を呼び出した場合、システムは、各トップレベルウィンドウ（親を持たないウィンドウ）に対して 1 度ずつ SendAsyncProc 関数を呼び出します。 \r\n///\r\nuMsg --- メッセージを指定します。dwDataSendMessageCallback 関数が送信してきた、アプリケーション定義の値を指定します。\r\n///\r\nlResult --- メッセージ処理の結果を指定します。この値の意味は、メッセージにより異なります。', '戻り値はありません。', 'このコールバック関数をインストールするには、SENDASYNCPROC 型のポインタ（SendAsyncProc 関数へのポインタ）を指定して、SendMessageCallback 関数を呼び出します。\r\n\r\nSendMessageCallback 関数を呼び出したスレッドが、GetMessage、PeekMessage、WaitMessage のいずれかの関数を呼び出した場合にのみ、このコールバック関数が呼び出されます。', 'GetMessage|PeekMessage|SendMessageCallback|WaitMessage', '2016-08-28 05:22:53', '2016-08-28 05:22:53', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411036.aspx', 'Microsoft', '', '', '', ''),
('Sending Messages', '', 'アプリはたいていタスクをすぐに行うためにウィンドウプロシージャに通知するためにメッセージを送信する。SendMessage関数は与えられたウィンドウに応じたウィンドウプロシージャにメッセージを送信する。関数はウィンドウプロシージャが処理を終えてメッセージ結果を返すまで待つ。親と子ウィンドウたちは、互いに通信するためにメッセージを送信する。例えば、親ウィンドウがエディットコントロールを子ウィンドウとして所有していて、メッセージをそこに送ることでコントロールのテキストをセットできる。コントロールは親ウィンドウにメッセージを送信することでユーザーによるテキストの変更を親ウィンドウに通知できる。\r\n\r\nSendMessageCallback関数も、与えられたウィンドウのウィンドウプロシージャにメッセージを送信できる。しかしながら、この関数はすぐに戻る。ウィンドウプロシージャがメッセージを処理した後で、システムは指定されたコールバック関数を呼び出す。コールバック関数に関する情報の詳細は、SendAsyncProc関数を参照せよ。\r\n\r\nたまにあなたは、すべてのトップレベルのウィンドウにメッセージを送信したいと考えるかもしれない。例えば、アプリがシステム時刻を変更したなら、変更に関してすべてのウィンドウにWM_TIMECHANGEメッセージを送ることで通知しなければならない。アプリは、hwndパラメータにHWND_TOPMOSTを指定したSendMessageを呼び出すことで、すべてのトップレベルのウィンドウにメッセージを送信できる。またlpdwRecipientsパラメータにBSM_APPLICATIONSを指定したBroadcastSystemMessage関数を呼び出すことですべてのアプリにメッセージを放映できる。\r\n\r\nInSendMessageやInSendMessageEx関数を使うことで、ウィンドウプロシージャは、それが別のスレッドから送信されたかを確かめることができる。この能力はメッセージの出所に依存するメッセージ処理に便利である。', '', '', '', '', 'SendMessage|SendMessageCallback|SendAsyncProc|BroadcastSystemMessage|InSendMessage|InSendMessageEx', '2016-09-04 07:55:27', '2016-09-04 07:55:27', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Posting Messages', 'Message Deadlocks'),
('SendMessage', '関数', '1 つまたは複数のウィンドウへ、指定されたメッセージを送信します。この関数は、指定されたウィンドウのウィンドウプロシージャを呼び出し、そのウィンドウプロシージャがメッセージを処理し終わった後で、制御を返します。\r\n\r\nメッセージを送信して即座に制御を返すには、SendMessageCallback または SendNotifyMessage 関数を使ってください。メッセージを 1 つのスレッドのメッセージキューにポストして即座に制御を返すには、PostMessage または PostThreadMessage 関数を使ってください。', 'LRESULT SendMessage(\r\n  HWND hWnd,      // 送信先ウィンドウのハンドル\r\n  UINT Msg,       // メッセージ\r\n  WPARAM wParam,  // メッセージの最初のパラメータ\r\n  LPARAM lParam   // メッセージの 2 番目のパラメータ\r\n);', 'hWnd --- 1 つのウィンドウのハンドルを指定します。このウィンドウのウィンドウプロシージャがメッセージを受信します。HWND_BROADCAST を指定すると、この関数は、システム内のすべてのトップレベルウィンドウ（親を持たないウィンドウ）へメッセージを送信します。無効になっている所有されていないウィンドウ、不可視の所有されていないウィンドウ、オーバーラップされた（手前にほかのウィンドウがあって覆い隠されている）ウィンドウ、ポップアップウィンドウも送信先になります。子ウィンドウへはメッセージを送信しません。\r\n///\r\nMsg --- 送信するべきメッセージを指定します。\r\n///\r\nwParam --- メッセージ特有の追加情報を指定します。\r\n///\r\nlParam --- メッセージ特有の追加情報を指定します。', 'メッセージ処理の結果が返ります。この戻り値の意味は、送信されたメッセージにより異なります。', 'HWND_BROADCAST フラグを使って通信を行う必要がある複数のアプリケーションは、アプリケーション間通信の専用メッセージを取得する目的では、RegisterWindowMessage 関数を呼び出すべきです。\r\n\r\n指定されたウィンドウが、呼び出し側スレッドが作成したものであった場合、そのウィンドウのウィンドウプロシージャがサブルーチンとして即座に呼び出されます。指定されたウィンドウが、他のスレッドが作成したものであった場合、システムはそのスレッドへの切り替えを行い、次に適切なウィンドウプロシージャを呼び出します。複数のスレッド間で送信されたメッセージが処理されるのは、受信側スレッドがメッセージ取得コードを実行したときだけです。送信側スレッドは、受信側スレッドがメッセージの処理を終えるまで、ブロックされます（待機状態になります）。', 'InSendMessage|PostMessage|PostThreadMessage|RegisterWindowMessage|SendDlgItemMessage|SendMessageCallback|SendMessageTimeout|SendNotifyMessage', '2016-08-28 05:24:39', '2016-08-28 05:24:39', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411022.aspx', 'Microsoft', '', '', '', ''),
('SendMessageCallback', '関数', '指定されたメッセージを、1 つまたは複数のウィンドウへ送信します。この関数は、指定されたウィンドウのウィンドウプロシージャを呼び出し、即座に制御を返します。ウィンドウプロシージャがメッセージを処理した後、システムは、指定されたコールバック関数を呼び出し、メッセージ処理の結果とアプリケーション定義の値をコールバック関数に渡します。', 'BOOL SendMessageCallback(\r\n  HWND hWnd,                // ウィンドウのハンドル\r\n  UINT Msg,                 // メッセージ\r\n  WPARAM wParam,            // メッセージの最初のパラメータ\r\n  LPARAM lParam,            // メッセージの 2 番目のパラメータ\r\n  SENDASYNCPROC lpCallBack, // コールバック関数\r\n  ULONG_PT', 'hWnd --- 1 つのウィンドウのハンドルを指定します。このウィンドウのウィンドウプロシージャがメッセージを受信します。HWND_BROADCAST を指定すると、この関数は、システム内のすべてのトップレベルウィンドウ（親を持たないウィンドウ）へメッセージを送信します。無効になっている所有されていないウィンドウ、不可視の所有されていないウィンドウ、オーバーラップされた（手前にほかのウィンドウがあって覆い隠されている）ウィンドウ、ポップアップウィンドウも送信先になります。子ウィンドウへはメッセージを送信しません。\r\n///\r\nMsg --- 送信するべきメッセージを指定します。\r\n///\r\nwParam --- メッセージ特有の追加情報を指定します。\r\n///\r\nlParam --- メッセージ特有の追加情報を指定します。\r\n///\r\nlpCallBack --- 1 つのコールバック関数へのポインタを指定します。ウィンドウプロシージャがメッセージを処理した後、システムはこのコールバック関数を呼び出します。このコールバック関数については、SendAsyncProc 関数の説明を参照してください。\r\n\r\nhWndパラメータで HWND_BROADCAST フラグを指定した場合、システムは、各トップレベルウィンドウに対して 1 度ずつ SendAsyncProc 関数を呼び出します。 \r\n///\r\ndwData --- lpfnResultCallBack パラメータで指定したコールバック関数へ送信される、アプリケーション定義の値を指定します。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、 関数を使います。', '非同期メッセージ関数（PostMessage、SendNotifyMessage、SendMessageCallback の各関数）を使って、WM_USER 未満のメッセージ（メッセージの値が 0x8000 未満）を送信する場合は、メッセージのパラメータでポインタを使うことはできません。もしポインタを使っている場合、その操作は失敗します。SendMessageCallback 関数は、受信側スレッドがそのメッセージを処理する前に制御を返します。そのため、受信側スレッドがメッセージの処理を開始する前に、送信側スレッドは、ポインタの指すメモリを解放してしまいます。\r\n\r\nHWND_BROADCAST フラグを使って通信を行う必要がある複数のアプリケーションは、アプリケーション間通信の専用メッセージを取得する目的では、RegisterWindowMessage 関数を呼び出すべきです。\r\n\r\nSendMessageCallback 関数を呼び出したスレッドが、GetMessage、PeekMessage、WaitMessage のいずれかの関数を呼び出した場合にのみ、このコールバック関数が呼び出されます。', 'PostMessage|RegisterWindowMessage|SendAsyncProc|SendMessageCallback|SendNotifyMessage', '2016-08-28 05:26:46', '2016-08-28 05:26:46', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411008.aspx', 'Microsoft', '', '', '', ''),
('SendMessageTimeout', '関数', '指定されたメッセージを、1 つまたは複数のウィンドウへ送信します。この関数は指定されたウィンドウのウィンドウプロシージャを呼び出しますが、そのウィンドウがほかのスレッドに所属している場合は、そのウィンドウプロシージャが処理を終了するまで、または指定されたタイムアウト期間が経過するまで、この関数は制御を返しません。メッセージを受信するウィンドウが現在のスレッドと同じキューに所属している場合は、そのウィンドウプロシージャを直接呼び出し、タイムアウト値を無視します。', 'LRESULT SendMessageTimeout(\r\n  HWND hWnd,            // ウィンドウのハンドル\r\n  UINT Msg,             // メッセージ\r\n  WPARAM wParam,        // メッセージの最初のパラメータ\r\n  LPARAM lParam,        // メッセージの 2 番目のパラメータ\r\n  UINT fuFlags,         // 送信オプション\r\n  UINT uTimeout,        // タイ', 'hWnd --- 1 つのウィンドウのハンドルを指定します。このウィンドウのウィンドウプロシージャがメッセージを受信します。 \r\n\r\nHWND_BROADCAST を指定すると、この関数は、システム内のすべてのトップレベルウィンドウ（親を持たないウィンドウ）へメッセージを送信します。無効になっている所有されていないウィンドウと、不可視の所有されていないウィンドウも送信先になります。この関数は、各ウィンドウがタイムアウトになるまで制御を返しません。そのため、合計の待ち時間は、最大で、uTimeout の時間にトップレベルウィンドウの数をかけた値になります。 \r\n///\r\nMsg --- 送信するべきメッセージを指定します。\r\n///\r\nwParam --- メッセージ特有の追加情報を指定します。\r\n///\r\nlParam --- メッセージ特有の追加情報を指定します。\r\n///\r\nfuFlags --- メッセージの送信方法を指定します。次の値のいずれかまたは任意の組み合わせを指定します。\r\n\r\n[table:SendMessageTimeout_Table1]\r\n///\r\nuTimeout --- タイムアウト期間をミリ秒（ms；1,000 分の 1 秒）単位で指定します。メッセージをブロードキャストした場合、各ウィンドウにこのタイムアウト期間を適用します。たとえば、5 秒のタイムアウト時間を指定した場合、3 つのトップレベルウィンドウがメッセージの処理に失敗すると、、最大 15 秒の遅延が発生します。\r\n///\r\nlpdwResult --- 1 個の DWORD 型変数へのポインタを指定します。関数から制御が返ると、この変数に、メッセージの処理結果が格納されます。意味は、送信したメッセージにより異なります。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗した場合や、タイムアウトが発生した場合は、0 が返ります。拡張エラー情報を取得するには、 関数を使います。GetLastError 関数が 0 を返した場合は、タイムアウトを意味します。ただし、hWnd パラメータで HWND_BROADCAST を指定した場合は、この関数は個々のウィンドウのタイムアウト情報を提供しません。', 'スレッドが 5 秒以内に GetMessage または同様の関数を呼び出さなかった場合、SendMessageTimeout 関数は、そのスレッドがハングアップしていると見なします。', 'GetMessage|InSendMessage|PostMessage|SendDlgItemMessage|SendMessage|SendMessageCallback|SendNotifyMessage', '2016-08-28 05:28:55', '2016-08-28 05:28:55', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411010.aspx', 'Microsoft', '', '', '', ''),
('SendNotifyMessage', '関数', '指定されたメッセージを 1 つまたは複数のウィンドウへ送信します。指定されたウィンドウが、呼び出し側スレッドが作成したものであった場合、この関数はそのウィンドウのウィンドウプロシージャを直接呼び出し、そのウィンドウプロシージャがメッセージの処理を終えるまで制御を返しません。指定されたウィンドウが、ほかのスレッドが作成したものであった場合、この関数はそのウィンドウのウィンドウプロシージャへメッセージを渡し、即座に制御を返します。そして、そのウィンドウプロシージャがメッセージの処理を終えるのを待ちません。', 'BOOL SendNotifyMessage(\r\n  HWND hWnd,      // ウィンドウのハンドル\r\n  UINT Msg,       // メッセージ\r\n  WPARAM wParam,  // メッセージの最初のパラメータ\r\n  LPARAM lParam   // メッセージの 2 番目のパラメータ\r\n);', 'hWnd --- 1 つのウィンドウのハンドルを指定します。このウィンドウのウィンドウプロシージャがメッセージを受信します。\r\n\r\nHWND_BROADCAST を指定すると、この関数は、システム内のすべてのトップレベルウィンドウ（親を持たないウィンドウ）へメッセージを送信します。無効になっている所有されていないウィンドウ、不可視の所有されていないウィンドウ、オーバーラップされた（手前にほかのウィンドウがあって覆い隠されている）ウィンドウ、ポップアップウィンドウも送信先になります。子ウィンドウへはメッセージを送信しません。\r\n///\r\nMsg --- 送信するべきメッセージを指定します。\r\n///\r\nwParam --- メッセージ特有の追加情報を指定します。\r\n///\r\nlParam --- メッセージ特有の追加情報を指定します。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、 関数を使います。', '非同期メッセージ関数（PostMessage、SendNotifyMessage、SendMessageCallback の各関数）を使って、WM_USER 未満のメッセージ（メッセージの値が 0x8000 未満）を送信する場合は、メッセージのパラメータでポインタを使うことはできません。もしポインタを使っている場合、その操作は失敗します。SendNotifyMessage 関数は、受信側スレッドがそのメッセージを処理する前に制御を返します。そのため、受信側スレッドがメッセージの処理を開始する前に、送信側スレッドはポインタが指すメモリを解放してしまいます。\r\n\r\nHWND_BROADCAST フラグを使って通信を行う必要がある複数のアプリケーションは、アプリケーション間通信の専用メッセージを取得する目的では、RegisterWindowMessage 関数を呼び出すべきです。', 'PostMessage|PostThreadMessage|RegisterWindowMessage|SendMessage|SendMessageCallback|SendNotifyMessage', '2016-08-28 05:30:19', '2016-08-28 05:30:19', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411012.aspx', 'Microsoft', '', '', '', ''),
('SetActiveWindow', '関数', 'ウィンドウをアクティブにします。そのウィンドウは、呼び出し側のスレッドのメッセージキューにアタッチされているものでなければなりません。', 'HWND SetActiveWindow(\r\n  HWND hWnd   // ウィンドウのハンドル\r\n);', 'hWnd［入力］ --- アクティブ化したいトップレベルウィンドウのハンドルを指定します。', '関数が成功すると、以前にアクティブであったウィンドウのハンドルが返ります。\r\n\r\n関数が失敗すると、NULL が返ります。拡張エラー情報を取得するには、 関数を使います。', 'この関数はウィンドウをアクティブ化しますが、アプリケーションがバックグラウンドにあるときはその限りではありません。アプリケーションがフォアグラウンドにあるときに、システムがウィンドウをアクティブ化した場合は、そのウィンドウはフォアグラウンド（ 「」の最上位）へ移動します。\r\n\r\nhWnd パラメータで指定されたウィンドウが、呼び出し側スレッドによって作成されたものであった場合、呼び出し側スレッドのアクティブウィンドウのステータスは hWnd に設定されます。それ以外の場合、呼び出し側スレッドのアクティブウィンドウのステータスは NULL に設定されます。\r\n\r\n関数を使うと、任意のスレッドは自らの入力処理を他のスレッドへアタッチすることができます。この方法により、任意のスレッドは SetActiveWindow を呼び出して、他のスレッドのメッセージキューにアタッチされているウィンドウをアクティブ化できます。', 'GetActiveWindow|SetForegroundWindow|WM_ACTIVATE', '2016-09-11 08:33:50', '2016-09-11 08:33:50', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411014.aspx', 'Microsoft', '', '', '', ''),
('SetFocus', '関数', '指定されたウィンドウにキーボードフォーカスを設定します。このウィンドウは、呼び出し側スレッドのメッセージキューにアタッチされているものでなければなりません。', 'HWND SetFocus(\r\n  HWND hWnd   // ウィンドウのハンドル\r\n);', 'hWnd［入力］ --- キーボードフォーカスを設定したいウィンドウのハンドルを指定します。NULL を指定すると、キーストロークは無視されます。', '関数が成功すると、以前にキーボードフォーカスを持っていたウィンドウのハンドルが返ります。hWnd パラメータが無効な場合や、指定のウィンドウが呼び出し側のスレッドのメッセージキューにアタッチされていない場合は、NULL が返ります。拡張エラー情報を取得するには、GetLastError を使います。', 'この関数は、キーボードフォーカスを失うウィンドウへ WM_KILLFOCUS メッセージを送信し、キーボードフォーカスを受け取るウィンドウへ WM_SETFOCUS メッセージを送信します。また、フォーカスを受け取るウィンドウかフォーカスを受け取るウィンドウの親ウィンドウをアクティブにします。\r\n\r\nあるウィンドウがアクティブであってフォーカスを設定されていない場合、何かキーを押すと、WM_SYSCHAR、WM_SYSKEYDOWN、WM_SYSKEYUP いずれかのメッセージが生成されます。VK_MENU キーも押されていた場合、そのメッセージの IParam パラメータのビット 30 がセットされます。VK_MENU キーが押されていなかった場合、生成されるメッセージはビット 30 をセットしません。\r\n\r\n任意のスレッドは AttachThreadInput 関数を使うことにより、自らの入力処理を他のスレッドへアタッチすることができます。この方法により、任意のスレッドは SetFocus を呼び出して、他のスレッドのメッセージキューにアタッチされているウィンドウへキーボードフォーカスを設定できます。', 'GetFocus|WM_KILLFOCUS|WM_SETFOCUS|WM_SYSCHAR|WM_SYSKEYDOWN|WM_SYSKEYUP', '2016-09-11 08:35:14', '2016-09-11 08:35:14', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411074.aspx', 'Microsoft', '', '', '', ''),
('SetKeyboardState', '関数', 'キーボードのキーの状態を表す 256 バイトの配列を、呼び出し側スレッドのキーボード入力状態テーブルへコピーします。このテーブルは、GetKeyboardState と GetKeyState の各関数がアクセスするテーブルと同じものです。このテーブルを変更しても、他のスレッドへのキーボード入力には何の影響もありません。', 'BOOL SetKeyboardState(\r\n  LPBYTE lpKeyState   // 仮想キーコードからなる配列\r\n);', 'lpKeyState［入力］ --- キーボードのキーの状態を保持する 256 バイトの配列へのポインタを指定します。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、GetLastError 関数を使います。', '関数は、呼び出し側スレッドの入力状態を変更しますが、システム全体の入力状態は変更しません。したがって、アプリケーションは SetKeyboardState を使って Num Lock、Caps Lock、Scroll Lock（ さらに日本語の一部のキーボードの「カナ」）の各キーに対応する各インジケータランプをオンまたはオフにすることはできません。SendInput を使ってキーストロークをシミュレートすることにより、これらのキーの状態をセットまたはクリアできます。\r\n\r\nWindows NT：keybd_event 関数も、NumLock、CapsLock、ScrollLock の各キーをトグルさせる（ オンとオフを交互に繰り返す）ことができます。\r\n\r\nWindows 95：keybd_event 関数がトグルさせることができるのは、CapsLock と ScrollLock の各キーだけです。NUM LOCK キーをトグルさせることはできません。', 'GetAsyncKeyState|GetKeyboardState|GetKeyState|keybd_event|MapVirtualKey|SendInput', '2016-09-11 08:36:38', '2016-09-11 08:36:38', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411041.aspx', 'Microsoft', '', '', '', ''),
('SetMessageExtraInfo', '関数', '現在のスレッドに関するメッセージ拡張情報を設定します。メッセージの拡張情報とは、現在のスレッドのメッセージキューに関連付けられている、アプリケーション定義またはドライバ定義の 32 ビット値です。スレッドに関するメッセージの拡張情報を取得するには、GetMessageExtraInfo 関数を使います。', 'LPARAM SetMessageExtraInfo(\r\n  LPARAM lParam  // アプリケーション定義の 32 ビット値\r\n);', 'lParam --- 現在のスレッドに関連付けるべき 1 つの 32 ビット値を指定します。', '現在のスレッドに既に関連付けられていたメッセージ拡張情報が返ります。', '', 'GetMessageExtraInfo', '2016-08-28 05:31:17', '2016-08-28 05:31:17', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411057.aspx', 'Microsoft', '', '', '', ''),
('SHAppBarMessage', '関数', 'システムにAppBarメッセージを送信する。', 'UINT_PTR SHAppBarMessage(\r\n  _In_    DWORD       dwMessage,\r\n  _Inout_ PAPPBARDATA pData\r\n);', 'dwMessage [in] Type: DWORD --- \r\n送信するAppBarメッセージ。このパラメータは以下のいずれかの値である。\r\n\r\n * ABM_NEW\r\n * ABM_REMOVE\r\n * ABM_QUERYPOS\r\n * ABM_SETPOS\r\n * ABM_GETSTATE\r\n * ABM_GETTASKBARPOS\r\n * ABM_ACTIVATE\r\n * ABM_GETAUTOHIDEBAR\r\n * ABM_SETAUTOHIDEBAR\r\n * ABM_WINDOWPOSCHANGED\r\n * ABM_SETSTATE\r\n * ABM_GETAUTOHIDEBAREX\r\n * ABM_SETAUTOHIDEBAREX \r\n///\r\npData [in, out] Type: PAPPBARDATA --- APPBARDATA構造体へのポインタ。\r\n\r\nThe content of the structure on entry and on exit depends on the value set in the dwMessage parameter. 指定方法についてはそれぞれのメッセージを参照せよ。', 'この関数はメッセージ依存の値を返す。詳しくは特定のAppBarの送信メッセージのドキュメンテーションを参照せよ。それらの文書へのリンクは参照に与えられている。', '', 'APPBARDATA|ABM_NEW|ABM_REMOVE|ABM_QUERYPOS|ABM_SETPOS|ABM_GETSTATE|ABM_GETTASKBARPOS|ABM_ACTIVATE|ABM_GETAUTOHIDEBAR|ABM_SETAUTOHIDEBAR|ABM_WINDOWPOSCHANGED|ABM_SETSTATE|ABM_GETAUTOHIDEBAREX|ABM_SETAUTOHIDEBAREX', '2016-09-22 03:22:47', '2016-09-22 03:22:47', '<shellapi.h>', 'shell32.dll', 'https://msdn.microsoft.com/ja-jp/library/windows/desktop/bb762108.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Simple Reconversion', '', '単純な再変換は、ターゲットの文字列とコンポジション文字列が文字列全体で同じであるときだ。この場合、dwCompStrOffset と dwTargetStrOffset がゼロであり、dwStrLen、dwCompStrLen、そして dwTargetStrLenが同じ値である。IME は、構造体で与えられた文字列全体のコンポジション文字列を提供し、変換結果によりターゲットの文節をセットする。', '', '', '', '', 'RECONVERTSTRING', '2016-09-10 10:39:12', '2016-09-10 10:39:12', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Simulating Input', '', '中断されないユーザー入力イベントたちの並びをシミュレートするには、SendInput関数を使う。この関数は３つのパラメータを受け入れる。第一パラメータcInputsは、シミュレートされる入力イベントの個数を表す。第二パラメータrgInputsは、INPUT構造体の配列であり、それぞれは入力イベントの種類とイベントに関する追加的な情報を表す。最後のパラメータcbSizeは、INPUT構造体のサイズをバイト数で受け付ける。\r\n\r\nSendInput関数は、デバイスの入力ストリームへシミュレートされる入力イベントの並びを注入（inject）することで動作する。その効果はkeybd_eventやmouse_event関数を続けて呼び出すことに似ているが、システムはシミュレートされるイベントに他の入力イベントを混入させないことを保証する。呼び出しが完了したとき、戻り値は、入力イベントの再生の成功した個数を表す。この値がゼロなら、入力はブロックされたことを意味する。\r\n\r\nSendInput関数は、キーボードの現在の状態をリセットしない。したがって、この関数読んだときにユーザーが何かキーを押したら、それらはこの関数が生成するイベントを邪魔するかもしれない。もしあなたが妨害の可能性が心配なら、GetAsyncKeyState関数でキーボードの状態をチェックして、必要に応じて修正せよ。', '', '', '', '', '', '2016-09-16 13:25:04', '2016-09-16 13:25:04', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Single-byte Character Sets', '', 'シングルバイト文字セット（SBCS）は、256の個別の文字をコードの値として対応付ける写像であり、コードページとして実装されている。SBCSは、WindowsコードページとしてもOEMコードページとしても対応付けることができる。SBCSコードページはまた、非ネイティブなコードページを含むことができる。例えば、EBCDICコードページである。コードページの詳細は、「コードページ」を参照せよ。\r\n\r\n注意：Windowsアプリは、さまざまなコードページの非一貫性を避けるため、またローカリゼーションの簡単さのためにUnicodeを使うべきである。しかしながら、いくつかのレガシーなプロトコルは、SBCSの使用を必要とする。それぞれのSBCSコードページは、異なる文字たちをサポートするが、Unicodeで提供されるすべての文字をサポートするページはない。それぞれのSBCSコードページは、異なるサブセットをサポートし、異なってエンコードされる。SBCSコードページから別のコードページへ変換されたデータは、壊れやすい。なぜなら、異なるコードページの同じデータの値は、別の文字としてエンコードするからだ。UnicodeからSBCSへ変換されたデータは、データを失いやすい。なぜなら与えられたコードページは、Unicodeデータで使われるすべての文字を表すことができないかもしれないからだ。\r\n\r\nあなたのアプリは、\"A\"バージョンのWindows関数たちと共に、SBCS Windowsコードページを使うことができる。「関数プロトタイプとコードページに対する慣習」を参照せよ。SBCSコードページを識別するのを助けるために、アプリはGetCPInfoかGetCPInfoEx関数を使うことができる。加えて、アプリはMultiByteToWideCharとWideCharToMultiByte関数をUnicodeとSBCS文字列の間の変換のために使うことができる。', '', '', '', '', 'Code Pages|Unicode', '2016-09-18 05:00:49', '2016-09-18 05:00:49', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374056.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Soft Keyboard', '', 'ソフトキーボードは、IME によって表示される特殊なウィンドウだ。いくつかの IME は、特殊な読みの文字を持つため、IME はそれらの特殊な読みの文字を表示するためにソフトキーボードを提供できる。この方法では、ユーザは各キーの読みの文字を覚える必要がない。例えば、IME は、読みの文字に対して「ボ」「ポ」「モ」「フォ」を使うのに対して、別の IME では読みの文字に部首を使うことができる。\r\n\r\nIME はキーの読みの文字列を変更でき、それらのキーが変更されたことをユーザに知らせることができる（それは変換状態に依存する）。例えば、候補選択時に IME は、ユーザに選択キーのみを表示することができる。\r\n\r\nIME は、ソフトキーボードに自分自身の UI を作成できるし、システム定義済みのソフトキーボードを使うことができる。もし、IME がシステム定義済みのソフトキーボードを使いたければ、ImeInquire が呼ばれたときに、IMEINFO 構造体の fdwUICaps メンバーに UI_CAP_SOFTKBD を指定する必要がある。\r\n\r\nIME は、ソフトキーボードウィンドウを作成するのに ImmCreateSoftKeyboard を呼び出す必要がある。それはソフトキーボードの表示・非表示を切り替えるために ImmShowSoftKeyboard も呼び出すことができる。ソフトキーボードは UI ウィンドウの１つのコンポーネントであるから、所有者は UI ウィンドウでなければならない。\r\n\r\nソフトキーボードの種類はいくつかある。それぞれは、特定の国や特殊な目的で設計される。IME は、次のいずれかの手段を使って、ソフトキーボードの読み文字を変更できる：IMC_SETSOFTKBDSUBTYPE またはIMC_SETSOFTKBDDATA。', '', '', '', '', 'IMEINFO|ImeInquire|ImmCreateSoftKeyboard|ImmShowSoftKeyboard|IMC_SETSOFTKBDSUBTYPE|IMC_SETSOFTKBDDATA', '2016-09-10 10:36:12', '2016-09-10 10:36:12', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('SOFTKBDDATA', '構造体', '各仮想キーに対する DBCS コードを定義する。', 'typedef struct {\r\n    UINT uCount;\r\n    WORD wCode[1][256]\r\n} SOFTKBDDATA;', 'uCount --- 内部コード配列への 256 ワードの仮想キーマッピングの個数。\r\n///\r\nwCode[1][256] --- 内部コード配列への 256 ワードの仮想キーマッピング。これは 1 個の 256 ワードの配列より多いかもしれない。', '', '1 種類のソフトキーボードに対して 2 つの 256 ワード配列を使うことはあり得る。一つは非シフト状態、もう一\r\nつは、シフト状態である。ソフトキーボードは 1 個の仮想キーを表示するのに２つの内部コードを使うことがで\r\nきる。', '', '2016-09-10 04:14:32', '2016-09-10 04:14:32', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('SORTIDFROMLCID', 'マクロ', 'ロケール識別子から並べ替え順識別子を取得します。', 'WORD SORTIDFROMLCID(\r\n   LCID lcid\r\n);', 'lcid --- ロケール識別子。MAKELCIDマクロを使ってロケール識別子を作成するか、次の定義済みの値のいずれかが使えます。\r\n\r\n * LOCALE_INVARIANT\r\n * LOCALE_SYSTEM_DEFAULT\r\n * LOCALE_USER_DEFAULT\r\n\r\nWindows Vistaとそれ以降：以下のカスタムロケール識別子もサポートされています。\r\n\r\n * LOCALE_CUSTOM_DEFAULT\r\n * LOCALE_CUSTOM_UI_DEFAULT\r\n * LOCALE_CUSTOM_UNSPECIFIED', '並べ替え順識別子を返します。', '', 'MAKELANGID|MAKELCID|PRIMARYLANGID|SUBLANGID', '2016-09-18 05:39:24', '2016-09-18 05:39:24', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374057.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('struct list', '構造体', '線形リストを構成します。', 'struct list\r\n{\r\n    struct list *next;\r\n    struct list *prev;\r\n};', 'next --- 次のノード、またはリスト先頭のノードを表します。\r\n///\r\nprev --- 前のノード、またはリスト終端のノードを表します。', '', 'list_で始まるインライン関数で線形リストを操作できます。\r\n\r\n * リストの初期化 list_init\r\n * ノードの追加 list_add_head、list_add_tail、list_add_after、list_add_before\r\n * ノードの除去 list_remove\r\n * 次のノードの取得 list_next\r\n * 前のノードの取得 list_prev\r\n * 先頭のノード list_head\r\n * 終端のノード list_tail\r\n * リストは空か list_empty\r\n * ノードの個数 list_count\r\n\r\n次のマクロが利用可能です。\r\n\r\n * LIST_ENTRY\r\n * LIST_FOR_EACH\r\n * LIST_FOR_EACH_ENTRY\r\n * LIST_FOR_EACH_ENTRY_REV\r\n * LIST_FOR_EACH_ENTRY_SAFE\r\n * LIST_FOR_EACH_ENTRY_SAFE_REV\r\n * LIST_FOR_EACH_REV\r\n * LIST_FOR_EACH_SAFE\r\n * LIST_FOR_EACH_SAFE_REV', 'list_add_after|list_add_before|list_add_head|list_add_tail|list_count|list_empty|LIST_ENTRY|LIST_FOR_EACH|LIST_FOR_EACH_ENTRY|LIST_FOR_EACH_ENTRY_REV|LIST_FOR_EACH_ENTRY_SAFE|LIST_FOR_EACH_ENTRY_SAFE_REV|LIST_FOR_EACH_REV|LIST_FOR_EACH_SAFE|LIST_FOR_EACH_SAFE_REV|list_head|list_init|list_next|list_prev|list_remove|list_tail', '2016-09-08 11:59:59', '2016-09-08 11:59:59', '<wine/list.h>', 'Wine', 'Wine and ReactOS', 'Katayama Hirofumi MZ', '', '', '', ''),
('STYLEBUFA', '構造体', 'スタイルの識別子と名前を含みます。', 'typedef struct {\r\n    DWORD       dwStyle;\r\n    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];\r\n} STYLEBUFA;', 'dwStyle --- 登録文字列のスタイルを表す符号なしの長整数値です。これは、文字列がEUDC範囲であることを指定するために、IME_REGWORD_STYLE_EUDCにすることができます。\r\n///\r\nszDescription --- スタイルの説明を表す文字の配列です。', '', '', 'STYLEBUF|STYLEBUFW', '2016-08-29 03:14:31', '2016-08-29 03:14:31', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741234.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('STYLEBUFW', '構造体', 'スタイルの識別子と名前を含みます。', 'typedef struct {\r\n    DWORD       dwStyle;\r\n    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];\r\n} STYLEBUFW;', 'dwStyle --- 登録文字列のスタイルを表す符号なしの長整数値です。これは文字列がEUDC範囲にあることを示すため、IME_REGWORD_STYLE_EUDCにすることができます。\r\n///\r\nszDescription --- スタイルの説明を表す文字の配列です。', '', '', 'STYLEBUF|STYLEBUFA', '2016-08-29 03:16:55', '2016-08-29 03:16:55', '<immdev.h>', '', 'https://msdn.microsoft.com/en-us/library/aa741235.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('SUBLANGID', 'マクロ', '言語識別子からサブ言語識別子を抽出します。', 'WORD SUBLANGID(\r\n   WORD lgid\r\n);', 'lgid --- 言語識別子。このパラメータに定義済みの値を指定するか、MAKELANGIDマクロを使って識別子を作成できます。', 'サブ言語識別子を返します。これは定義済みのサブ言語識別子か、ユーザー定義のサブ言語識別子です。', '', 'LANGIDFROMLCID|MAKELANGID|PRIMARYLANGID', '2016-09-18 05:34:40', '2016-09-18 05:34:40', '<winnt.h>', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374066.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Surrogates and Supplementary Characters', '', 'Windowsアプリは、Unicode文字データを表すのに通常はUTF-16を使う。16ビットの使用は、65536個の一意な文字たちを直接表すのを可能にする。しかし基本多言語面（BMP）は、人間の言語たちで使われるすべての記号をカバーするのに十分ではない。Unicodeバージョン4.1は、97000文字以上を含む。中国語だけで70000文字ある。\r\n\r\nUnicode標準は16もの追加的な「面」を確立した。それぞれの面は文字の集合を表し、BMPと同じサイズである。Naturally, most code points beyond the BMP do not yet have characters assigned to them, but definition of the planes gives Unicode the potential to define 1,114,112 characters (that is, 2¹⁶ * 17 characters) within the code point range U+0000 to U+10FFFF. For UTF-16 to represent this larger set of characters, the Unicode Standard defines \"supplementary characters\".\r\n\r\n * 補助文字について\r\n * 補助文字の使い方', '', '', '', '', 'About Supplementary Characters|Using Supplementary Characters|Unicode', '2016-09-18 05:07:46', '2016-09-18 05:07:46', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('System and Nonsystem Keystrokes', '', 'システムは、システムキーストロークと非システムキーストロークを区別する。システムキーストロークは、システムキーストロークメッセージ、WM_SYSKEYDOWNとWM_SYSKEYUPを生成する。非システムキーストロークは非システムキーストロークメッセージ、WM_KEYDOWNとWM_KEYUPを生成する。\r\n\r\nもしあなたのウィンドウプロシージャがシステムキーストロークメッセージを処理しなければならないなら、プロシージャがそれをDefWindowProc関数に渡すメッセージを処理した後でそれを確認しなさい。さもなければウィンドウがキーボードフォーカスを持っているときはいつでもALTキーに関わるすべてのシステム操作が無効になるだろう。すなわち、ユーザーはウィンドウのメニューやシステムメニューにアクセスできず、またALT+ESCやALT+TABキーの組み合わせが使えないことになってしまう。\r\n\r\nシステムキーストロークメッセージは、主にアプリよりもむしろシステムによって使われる。システムはビルトインのキーボードインターフェイスをメニューに提供するために、そして、ユーザーにアクティブなウィンドウを制御することを認めるために、システムキーストロークメッセージを使う。システムキーストロークメッセージは、ユーザーがALTキーの組み合わせを打ったとき、あるいはキーボードフォーカスのあるウィンドウがないときに、キーをタイプしたとき（例えばアクティブアプリが最小化されているとき）に生成される。この場合は、メッセージたちはアクティブウィンドウにアタッチされたメッセージキューにポストされる。\r\n\r\n非システムキーストロークメッセージたちは、アプリのウィンドウたちによって使われる。DefWindowProc関数はそれらについて何もしない。ウィンドウプロシージャは、必要のない非システムキーストロークメッセージたちを捨てることができる。', '', '', '', '', '', '2016-09-14 10:18:23', '2016-09-14 10:18:23', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('System-Defined Messages', '', 'システムはアプリと通信するとき、システム定義のメッセージを送信またはポストする。システムは、アプリの操作を制御するために、並びにアプリが処理すべき入力やその他の情報を提供するために、それらのメッセージを使う。アプリは、システム定義のメッセージを送信またはポストできる。アプリは一般的に、すでに存在するウィンドウクラスを使って作成されたコントロールウィンドウの操作を制御するために、それらのメッセージを使う。\r\n\r\nそれぞれのシステム定義のメッセージは一意な（unique）メッセージ識別子と、それに対応するメッセージの目的に言及した記号的な定数を持つ。例えばWM_PAINT定数はウィンドウの中身の描画を要求する。\r\n\r\n記号的な定数は、システム定義のメッセージがどのカテゴリーに属するかを指定する。定数の接頭辞（prefix）は、解釈またはメッセージを処理できるウィンドウの種類を識別する。以下は接頭辞とその関連するメッセージのカテゴリーである。\r\n\r\n[table:System-Defined Messages_Table1]\r\n\r\n一般のウィンドウメッセージは、マウスやキーボード入力、メニューやダイアログ入力、ウィンドウ作成と管理、DDEなどの、幅広い範囲の情報と要求をカバーする。', '', '', '', '', '', '2016-09-04 00:32:09', '2016-09-04 00:32:09', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Message Types', 'Application-Defined Messages'),
('ToAscii', '関数', '指定された仮想キーコードおよびキーボード状態を、対応する単数または複数の文字に変換します。関数は、与えられたキーボードレイアウトハンドルで識別される入力言語と物理キーボードレイアウトを使い、コードを変換します。\r\n\r\n与えられたコードを変換するために使うキーボードレイアウトのハンドルを指定するには、ToAsciiEx 関数を使います。', 'int ToAscii(\r\n  UINT uVirtKey,     // 仮想キーコード\r\n  UINT uScanCode,    // スキャンコード\r\n  PBYTE lpKeyState,  // キー状態配列\r\n  LPWORD lpChar,     // 変換されたキーに対するバッファ\r\n  UINT uFlags        // アクティブメニューフラグ\r\n);', 'uVirtKey --- 変換する仮想キーコードを指定します。\r\n///\r\nuScanCode --- 変換するキーのハードウェアスキャンコードを指定します。キーが上がっている（押されていない）場合、この値の上位ビットがセットされます。\r\n///\r\nlpKeyState --- 現在のキーボード状態が入る、256 バイトの配列へのポインタを指定します。配列の各要素（バイト）には、１つのキーの状態が入ります。バイトの上位ビットがセットされている場合、キーは下がって（押されて）います。 \r\n下位ビットがセットされている場合、キーはオンに切り替えられていることを表します。この関数では、CAPS LOCK キーのトグルビットだけが有効です。NUM LOCK キーおよび SCROLL LOCK キーのトグル状態は無視されます。 \r\n///\r\nlpChar --- 変換された単数または複数の文字を受けるバッファへのポインタを指定します。\r\n///\r\nuFlags --- メニューがアクティブかどうかを指定します。このパラメータには、メニューがアクティブの場合は 1、アクティブでない場合は 0 を指定してください。', '指定されたキーがデッドキーの場合、負の値が戻ります。それ以外の場合、次の値のいずれかが返ります。\r\n\r\n[table:ToAscii_Table1]', 'キーボードレイアウトにすでにデッドキーが格納されているため、ToAscii 関数に与えられたパラメータだけでは仮想キーコードを変換できない場合があります。\r\n\r\n一般的には、ToAscii 関数は仮想キーコードに基づいて変換を行います。場合によっては、uScanCode パラメータのビット 15 を使ってキーの押し下げと解放を区別します。スキャンコードは ALT+number キーの組み合せを変換するのに使います。\r\n\r\nNUM LOCK キーはトグルキーであり、キーボードの動作に影響を与えますが、uVirtKey パラメータだけでカーソル動作キー（VK_HOME、VK_INSERT など）と数字キー（VK_DECIMAL、VK_NUMPAD0 - VK_NUMPAD9）を区別するのに十分であるため、ToAscii 関数は lpKeyState パラメータ（VK_NUMLOCK）のトグル設定（下位ビット）を無視します。', 'OemKeyScan|ToAsciiEx|ToUnicode|VkKeyScan', '2016-09-11 08:39:24', '2016-09-11 08:39:24', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411218.aspx', 'Microsoft', '', '', '', ''),
('ToAsciiEx', '関数', '指定された仮想キーコードおよびキーボード状態を、対応する単数または複数の文字に変換します。関数は与えられた入力ロケール識別子（旧名キーボードレイアウトハンドル）で識別される入力言語と物理キーボードレイアウトを使い、コードを変換します。', 'int ToAsciiEx(\r\n  UINT uVirtKey,     // 仮想キーコード\r\n  UINT uScanCode,    // スキャンコード\r\n  PBYTE lpKeyState,  // キー状態配列\r\n  LPWORD lpChar,     // 変換されたキーに対するバッファ\r\n  UINT uFlags,       // アクティブメニューフラグ\r\n  HKL dwhkl          // 入力ロケール識別子\r\n);', 'uVirtKey --- 変換する仮想キーコードを指定します。\r\n///\r\nuScanCode --- 変換するキーのハードウェアスキャンコードを指定します。キーが上がっている（押されていない）場合、この値の上位ビットがセットされます。\r\n///\r\nlpKeyState --- 現在のキーボード状態が入る、256 バイトの配列へのポインタを指定します。配列の各要素（バイト）には、１つのキーの状態が入ります。バイトの上位ビットがセットされている場合、キーは下がって（押されて）います。 \r\n下位ビットがセットされている場合、キーはオンに切り替えられていることを表します。この関数では CAPS LOCK キーのトグルビットだけが有効です。NUM LOCK キーおよび SCROLL LOCK キーのトグル状態は無視されます。\r\n///\r\nlpChar --- 変換された単数または複数の文字を受けるバッファへのポインタを指定します。\r\n///\r\nuFlags --- メニューがアクティブかどうかを指定します。このパラメータには、メニューがアクティブの場合は 1、アクティブでない場合は 0 を指定してください。\r\n///\r\ndwhkl --- 与えられたコードを変換するために使う入力ロケール識別子（旧名キーボードレイアウトハンドル）を指定します。このパラメータには LoadKeyboardLayout 関数で返された入力ロケール識別子であれば、いずれも指定することができます。', '指定されたキーがデッドキーの場合、負の値が戻ります。それ以外の場合、次の値のいずれかが返ります。\r\n\r\n[table:ToAsciiEx_Table1]', '入力ロケール識別子には音声入力コンバータ、IME、またはその他のあらゆる入力形式が含まれており、キーボードレイアウトよりも広い概念を持ちます。\r\n\r\nキーボードレイアウトにすでにデッドキーが格納されているため、ToAsciiEx 関数に与えられたパラメータだけでは仮想キーコードを変換できない場合があります。\r\n\r\n一般的には、ToAsciiEx 関数は仮想キーコードに基づいて変換を行います。場合によっては、uScanCode パラメータのビット 15 を使ってキーの押し下げと解放を区別します。スキャンコードは ALT+number キーの組み合せを変換するのに使います。\r\n\r\nNUM LOCK キーはキーボードの動作に影響を与えるトグルキーですが、uVirtKey パラメータだけでカーソル動作キー（VK_HOME、VK_INSERT など）と数字キー（VK_DECIMAL、VK_NUMPAD0 - VK_NUMPAD9）を区別するのに十分であるため、ToAsciiEx 関数は lpKeyState パラメータ（VK_NUMLOCK）のトグル設定（下位ビット）を無視します。', 'LoadKeyboardLayout|MapVirtualKeyEx|ToUnicodeEx|VkKeyScan', '2016-09-11 08:42:12', '2016-09-11 08:42:12', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411219.aspx', 'Microsoft', '', '', '', ''),
('ToUnicode', '関数', '指定された仮想キーコードおよびキーボード状態を、対応する Unicode 文字または複数の Unicode 文字に変換します。\r\n\r\n与えられたコードを変換するために使うキーボードレイアウトのハンドルを指定するには、ToUnicodeEx 関数を使います。', 'int ToUnicode(\r\n  UINT wVirtKey,    // 仮想キーコード\r\n  UINT wScanCode,   // スキャンコード\r\n  PBYTE lpKeyState, // キー状態配列のアドレス\r\n  LPWSTR pwszBuff,  // 変換されたキーに対するバッファ\r\n  int cchBuff,      // 変換されたキーバッファのサイズ\r\n  UINT wFlags       // 関数設定フラグの集合\r\n);', 'wVirtKey --- 変換する仮想キーコードを指定します。\r\n///\r\nwScanCode --- 変換するキーのハードウェアスキャンコードを指定します。キーが上がっている（押されていない）場合、この値の上位ビットがセットされます。\r\n///\r\nlpKeyState --- 現在のキーボード状態が入る、256 バイトの配列へのポインタを指定します。配列の各要素（バイト）には、１つのキーの状態が入ります。バイトの上位ビットがセットされている場合、キーは下がって（押されて）います。\r\n///\r\npwszBuff --- 変換された単数または複数の Unicode 文字を受けるバッファへのポインタを指定します。\r\n///\r\ncchBuff --- pwszBuff パラメータで指されるバッファのサイズを文字単位で指定します。\r\n///\r\nwFlags --- 関数の動作を設定するビットフラグの集合を指定します。メニューがアクティブの場合はビット 0 を指定します。ビット 1~31 までは予約されています。', '次の値のいずれかが返ります。\r\n\r\n[table:ToUnicode_Table1]', 'キーボードレイアウトにすでにデッドキーが格納されているため、ToUnicode 関数に与えられたパラメータだけでは仮想キーコードを変換できない場合があります。\r\n\r\n一般的には、ToUnicode 関数は仮想キーコードに基づいて変換を行います。場合によっては、wScanCode パラメータのビット 15 を使ってキーの押し下げと解放を区別します。', 'ToAscii|ToUnicodeEx|VkKeyScan', '2016-09-11 08:45:23', '2016-09-11 08:45:23', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc411220.aspx', 'Microsoft', '', '', '', ''),
('ToUnicodeEx', '関数', '指定された仮想キーコードおよびキーボード状態を、対応する Unicode 文字または複数の Unicode 文字に変換します。', 'int ToUnicodeEx(\r\n  UINT wVirtKey,    // 仮想キーコード\r\n  UINT wScanCode,   // スキャンコード\r\n  PBYTE lpKeyState, // キー状態配列\r\n  LPWSTR pwszBuff,  // 変換されたキーに対するバッファ\r\n  int cchBuff,      // 変換されたキーバッファのサイズ\r\n  UINT wFlags,      // 関数設定フラグの集合\r\n  HKL dwhkl         // 入力ロケール識別子\r\n);', 'wVirtKey --- 変換する仮想キーコードを指定します。\r\n///\r\nwScanCode --- 変換するキーのハードウェアスキャンコードを指定します。キーが上がっている（押されていない）場合、この値の上位ビットがセットされます。\r\n///\r\nlpKeyState --- 現在のキーボード状態が入る、256 バイトの配列へのポインタを指定します。配列の各要素（バイト）には、１つのキーの状態が入ります。バイトの上位ビットがセットされている場合、キーは下がって（押されて）います。\r\n///\r\npwszBuff --- 変換された単数または複数の Unicode 文字を受けるバッファへのポインタを指定します。\r\n///\r\ncchBuff --- pwszBuff パラメータで指されるバッファのサイズを文字単位で指定します。\r\n///\r\nwFlags --- 関数の機能を設定するビットフラグの集合を指定します。メニューがアクティブの場合はビット 0 を指定します。ビット 1~31 までは予約されています。\r\n///\r\ndwhkl --- 与えられたコードを変換するために使う入力ロケール識別子（旧名キーボードレイアウトハンドル）を指定します。このパラメータには、LoadKeyboardLayout 関数で返された入力ロケール識別子であれば、どれでも指定することができます。', '次の値のいずれかが返ります。\r\n\r\n[table:ToUnicodeEx_Table1]', '入力ロケール識別子には音声入力コンバータ、IME、またはその他のあらゆる入力形式が含まれており、キーボードレイアウトよりも広い概念を持ちます。\r\n\r\nキーボードレイアウトにすでにデッドキーが格納されているため、ToUnicodeEx 関数に与えられたパラメータだけでは仮想キーコードを変換できない場合があります。\r\n\r\n一般的には、ToUnicodeEx 関数は仮想キーコードに基づいて変換を行います。場合によっては、wScanCode パラメータのビット 15 を使ってキーの押し下げと解放を区別します。', 'LoadKeyboardLayout|ToAsciiEx|VkKeyScan', '2016-09-11 08:48:22', '2016-09-11 08:48:22', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364836.aspx', 'Microsoft', '', '', '', ''),
('Transition-State Flag', '', 'トランジション状態フラグは、キーストロークメッセージを生成したキーが押されているか、離されているかを表す。WM_KEYDOWNとWM_SYSKEYDOWNについては常にゼロである。WM_KEYUPとWM_SYSKEYUPについては常に1である。', '', '', '', '', '', '2016-09-14 10:50:13', '2016-09-14 10:50:13', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('TranslateMessage', '関数', '仮想キーメッセージを文字メッセージへ変換します。文字メッセージは、呼び出し側スレッドのメッセージキューにポストされ、次にそのスレッドが GetMessage または PeekMessage 関数を呼び出すと、その文字メッセージが読み取られます。', 'BOOL TranslateMessage(\r\n  CONST MSG *lpMsg   // メッセージ情報\r\n);', 'lpMsg --- メッセージ情報を保持している、1 個の 構造体へのポインタを指定します。呼び出し側スレッドは、GetMessage または PeekMessage 関数を使って、自らのメッセージキューからこのメッセージ情報を取得します。', 'メッセージが変換された場合（つまり、文字メッセージをスレッドのメッセージキューにポストした場合）、0 以外の値が返ります。\r\n\r\nメッセージが、WM_KEYDOWN、WM_KEYUP、WM_SYSKEYDOWN、WM_SYSKEYUP のいずれかであった場合、変換の有無にかかわりなく、0 以外の値が返ります。\r\n\r\nメッセージが変換されなかった場合（つまり、文字メッセージをスレッドのメッセージキューにポストしなかった場合）、0 が返ります。', 'TranslateMessage 関数は、lpMsg パラメータが指すメッセージに変更を加えません。\r\n\r\nと の各メッセージの組み合わせは、 または メッセージを生成します。 と の各メッセージの組み合わせは、 または メッセージを生成します。\r\n\r\nTranslateMessage 関数は、キーボードドライバが ASCII 文字を割り当てているキーに対してのみ、WM_CHAR メッセージを生成します。\r\n\r\nアプリケーションが何か他の目的で仮想キーメッセージを処理する場合、TranslateMessage 関数を呼び出すべきではありません。たとえば、TranslateAccelerator 関数が 0 以外の値を返した場合（キーボードメッセージが変換された場合）、TranslateMessage 関数を呼び出すべきではありません。', 'GetMessage|IsDialogMessage|PeekMessage|TranslateAccelerator|WM_CHAR|WM_DEADCHAR|WM_KEYDOWN|WM_KEYUP|WM_SYSCHAR|WM_SYSDEADCHAR|WM_SYSKEYDOWN|WM_SYSKEYUP', '2016-08-28 05:32:25', '2016-08-28 05:32:25', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364841.aspx', 'Microsoft', '', '', '', ''),
('TRANSMSG', '構造体', 'IME 生成のメッセージを受け取るために ImeToAsciiEx で使われる、転送メッセージを格納する。', 'typedef struct {\r\n    UINT    message;\r\n    WPARAM  wParam;\r\n    LPARAM  lParam;\r\n} TRANSMSG;', 'message --- メッセージ識別子を指定する。\r\n///\r\nwParam --- このメッセージに関する追加的な情報を指定する。この正確な意味は、message メンバーの値に依存する。\r\n///\r\nlParam --- このメッセージに関する追加的な情報を指定する。この正確な意味は、message メンバーの値に依存する。', '', 'この構造体は、未来の 64 ビット Windows のために追加された。この構造体は、以前に用いられた\r\nLPDWORD lpdwTransBuf を置き換えるために、ImeToAsciiEx によって、TRANSMSGLIST 構造体と一緒に\r\n用いられるだろう。この構造体を使うことで、同じオフセットでメモリーのデータを保持し、下位互換性を保つ。', 'ImeToAsciiEx|TRANSMSGLIST', '2016-09-10 04:18:01', '2016-09-10 04:18:01', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('TRANSMSGLIST', '構造体', 'ImeToAsciiEx から返却された転送メッセージリストを格納する。', 'typedef struct {\r\n    UINT      uMsgCount;\r\n    TRANSMSG  TransMsg[1];\r\n} TRANSMSGLIST;', 'uMsgCount --- TRANSMSG配列のメッセージの個数。\r\n///\r\nTransMsg --- メッセージを表す TRANSMSG 構造体の配列。', '', 'この構造体は、未来の 64 ビット Windows のために追加された。この構造体は、以前に用いられた\r\nLPDWORD lpdwTransBuf を置き換えるために、ImeToAsciiEx によって用いられるだろう。この構造体を使う\r\nことで、同じオフセットでメモリーのデータを保持し、下位互換性を保つ。', 'ImeToAsciiEx|TRANSMSG', '2016-09-10 04:19:39', '2016-09-10 04:19:39', '<immdev.h>', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('UI Class from IME', '', 'この設計では、すべての IME は、システムに対してそれ自身の UI クラスを登録することを想定している。それぞれの IME によって提供される UI クラスは、IME 特有の機能に対して責任がある。IME は、IME がプロセスにアタッチされるとき、IME 自身がその IME で使われるいくつかのクラスを登録するかもしれない。これは、DLL のエントリポイントが DLL_PROCESS_ATTACH で呼ばれるときに起こる。そのとき IME は ImeInquire 関数の第二引数 lpszClassName にクラス名をセットしないといけない。\r\n\r\nUI クラスは、すべてのアプリが IME クラスとして使えるよう、CS_IME スタイルを付けて登録されるべきだ。(ナル文字を含む) UI クラス名は、16 文字までであるが、将来のバージョンでは増えるかもしれない。\r\n\r\nUI クラスの cbWndExtra メンバーは、2 * sizeof(LONG_PTR)でなければならない。割り増しのデータcbWndExtra の目的はシステムによって定義される。例えば、IMMGWLP_IMC と IMMGWLP_PRIVATE である。\r\n\r\nIME は、どんなウィンドウクラスも登録でき、アプリで動作するどんなウィンドウも作成できる。', '', '', '', '', 'ImeInquire', '2016-09-10 10:18:30', '2016-09-10 10:18:30', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('UI Window', '', 'IME クラスの IME ウィンドウたちは、アプリかシステムによって作成される。IME ウィンドウが作成されたら、IME 自身によって提供される UI ウィンドウが作成され、IME ウィンドウによって所有される。\r\n\r\nそれぞれの UI ウィンドウは、現在の入力コンテキストを所有する。この入力コンテキストは、UI ウィンドウがWM_IME_xxx メッセージを受け取ったときに、GetWindowLongPtr 関数に IMMGWLP_IMC をつけて呼び出すことで取得できる。UI ウィンドウは、この入力コンテキストを参照でき、メッセージを扱うことができる。GetWindowLongPtr 関数に IMMGWLP_IMC をつけて入力コンテキストを取得することは、UI ウィンドウプロシージャの間、いつでも可能だ（ただし WM_CREATE メッセージを除く）。\r\n\r\nUI ウィンドウの cbWndExtra は、IME によって拡張できない。IME がウィンドウインスタンスの割り増しのデータを使う必要がある場合は、UI ウィンドウは、IMMGWLP_PRIVATE をつけて SetWindowLongPtr とGetWindowLongPtr 関数を使う。この IMMGWLP_PRIVATE は、LONG_PTR 値の割り増しのデータを提供する。UI ウィンドウのプライベートな使用目的で、さらなるデータが必要なら、IMMGWLP_PRIVATE 領域にメモリブロックのハンドルを置くことができる。UI ウィンドウプロシージャは、DefWindowProc 関数が使えるが、UIウィンドウは、WM_IME_xxx メッセージを DefWindowProc に渡すことはできない。このメッセージが UI ウィンドウプロシージャによって扱わなくても、UI ウィンドウは、DefWindowProc にそれを渡さない。\r\n\r\nUI ウィンドウは、現在選択中の入力コンテキストを参照することによる、すべてのタスクを成し遂げなければならない。アプリのウィンドウがアクティブになったとき、UI ウィンドウは、現在の入力コンテキストを含むメッセージを受け取る。すると UI ウィンドウは、入力コンテキストを使う。よって、入力コンテキストは、UI ウィンドウがコンポジションウィンドウ・状態ウィンドウなどを表示するためのすべての情報を含んでいないといけない。\r\n\r\nUI ウィンドウは、入力コンテキストを参照するが、更新する必要はない。しかしながら、もし UI ウィンドウが入力コンテキストを更新したければ、それは、IMM 関数を呼ぶべきだ。なぜなら、入力コンテキストは、IMM によって管理され、IMM と IME は、入力コンテキストが変更されたときを通知されるべきだからである。\r\n\r\n例えば、UI ウィンドウはたまに、ユーザがマウスをクリックしたとき、入力コンテキストの変換モードを変更する必要がある。このとき、UI ウィンドウは、ImmSetConversionStatus 関数を呼ぶべきである。ImmSetConversionStatus 関数は、UI ウィンドウに WM_IME_NOTIFY と共に NotifyIME に対する通知を作成する。UI ウィンドウが変換モードの表示を変更したいなら、UI ウィンドウは、WM_IME_NOTIFY メッセージを待つべきである。', '', '', '', '', 'DefWindowProc|ImmSetConversionStatus|WM_IME_NOTIFY|GetWindowLongPtr|SetWindowLongPtr', '2016-09-10 10:20:01', '2016-09-10 10:20:01', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Unicode', '', 'Unicode（ユニコード）は、世界規模の文字エンコーディングの標準である。システムは文字と文字列の扱いにもっぱらUnicodeを使う。Unicodeのすべての見地の詳細な説明については、「Unicode標準」を参照せよ。\r\n\r\n文字と文字列のデータを扱う、古いメカニズムと比較すると、Unicodeは、ソフトウェアローカリゼーションを単純化し、多言語テキスト処理を改良する。あなたのアプリにおいて文字と文字列のデータを表現するのにUnicodeを使うことにより、あなたは、すべての文字コードに対して単一のバイナリファイルを使うことにより、グローバルなマーケティングにおいて、宇宙的なデータ交換の能力を実現する。Unicodeは以下のことをする：\r\n\r\n * 書体と言語の任意の組み合わせから描かれた、文字の任意の組み合わせを単一の文書の中で共存することを許容する。\r\n * 各文字の意味を定義する。\r\n * 書体の振る舞いを標準化する。\r\n * 双方向のテキストに対する標準化されたアルゴリズムを提供する。\r\n * 他の標準への相互の写像を定義する。\r\n * 単一の文字セットの複数のエンコーディングを定義する：\r\nUTF-7、UTF-8、UTF-16、そしてUTF-32。それらのエンコーディングのデータ変換は損失なしである。\r\n\r\nUnicodeは世界中の言語で使われる膨大な書体、そして技術的な記号や出版で使われる特殊文字をも多大な数でサポートする。サポートする書体は、ラテン語、ギリシャ語、キリル語、ヘブライ語、アラビア語、Devanagari語、タイ語、漢字、ハングル、ひらがな、カタカナを含むがそれだけにとどまらない。サポートする言語は、ドイツ語、フランス語、英語、ギリシャ語、ロシア語、ヘブライ語、アラビア語、ヒンディー語、タイ語、中国語、そして日本語を含むが、それだけにとどまらない。Unicodeは現在、世界中で使われる現代的なコンピューターで使われっる文字の大多数を表現でき、また、もっと完璧になるように更新され続けている。\r\n\r\nUnicodeを有効にした関数たちは、「関数プロトタイプに対する慣習」で記載されている。それらの関数は、Unicodeで最もよく使われ、Windows OSにおけるネイティブなUnicodeエンコーディングとして使われるUTF-16（ワイド文字）エンコーディングを使う。それぞれのコードの値は、文字と文字列データに対して8ビットのコードの値を使う古いコードページのアプローチとは対照的に、16ビットの幅を持つ。16ビットの使用は、直接65,536文字のエンコーディングを許容する。事実、人間の言語を記述するのに使われる記号の宇宙は、それよりもさらに大きく、U+D800～U+DFFの範囲のUTF-16コードポイントは、サロゲートペアを形成するために使われる。サロゲートペアは補助文字の32ビットエンコーディングを構成する。詳しくは、「サロゲートと補助文字」を参照せよ。\r\n\r\nThe Unicode character set includes numerous combining characters, such as U+0308 (\"¨\"), a combining dieresis or umlaut. Unicode can often represent the same glyph in either a \'\'composed\'\' or a \'\'decomposed\'\' form: for example, the composed form of \"Ä\" is the single Unicode code point \"Ä\" (U+00C4), while its decomposed form is \"A\" + \"¨\" (U+0041 U+0308). Unicode does not define a composed form for every glyph. For example, the Vietnamese lowercase \"o\" with circumflex and tilde (\"ỗ\") is represented by U+006f U+0302 U+0303 (o + Circumflex + Tilde). For further discussion of combining characters and related issues, see Using Unicode Normalization to Represent Strings.\r\n\r\n8ビットと7ビット環境との互換性のために、UnicodeはそれぞれUTF-8とUTF-7としてもエンコードできる。WindowsにおいてUnicodeを有効にした関数はUTF-16を使うが、マルチバイト文字セットのコードページとして、WindowsでサポートされたUTF-8やUTF-7でエンコードしたデータを扱うことが可能だ。\r\n\r\n新しいWindowsアプリは内部データ表現としてUTF-16を使うべきだ。Windowsは、コードページたちに対して広大なサポートをも提供し、同じアプリで混ぜて使うことができる。Unicodeベースのアプリはときどきコードページを扱う必要がある。その理由は、「コードページ」で議論されている。\r\n\r\nアプリは、コードページを元にした文字列とUnicode文字列の間で変換するために、MultiByteToWideCharとWideCharToMultiByte関数を使うことができる。それらの名前には、\"MultiByte\"とあるが、これらはシングルバイト文字セット（SBCS）、ダブルバイト文字セット（DBCS）、マルチバイト文字セット（MBCS）のコードページとも同じようにうまく動作する。\r\n\r\nたいていWindowsアプリは、内部でUTF-16を使うべきであり、他の形式を使わなければならないインターフェイスでは薄いレイヤーの一部として変換している。このテクニックは、データの損失と破壊に耐える。それぞれのコードページは、別々の文字をサポートするが、Unicodeで提供されるあらゆる種類の文字はサポートしない。多くのコードページは異なるエンコーディングによる異なるサブセットをサポートする。UTF-8とUTF-7に対するコードページは例外で、それらは完璧なUnicode文字セットをサポートし、それらとUTF-16の間の変換は損失なしである。\r\n\r\n１つのコードページで使われるエンコーディングから直接別のコードページで使われるエンコーディングへ変換したデータは、壊れやすい。なぜなら、異なるコードページでは同じデータの値が別の文字でエンコードされるからだ。あなたのアプリがなるべく近いインターフェイスに変換するときでも、あなたは扱うデータの範囲について注意深く考えるべきだ。\r\n\r\nUnicodeからコードページへ変換したデータは、データの損失が起こりやすい。なぜなら与えられたコードページはUnicodeデータにおいて使われるすべての文字を表現できないかもしれないからだ。よって、WideCharToMultiByteは、もしターゲットのコードページがUnicode文字列においてすべての文字を表現できなければ、データを損失するかもしれないことを注意しておく。\r\n\r\nコードページを元にしたレガシーなアプリをUnicodeを使うように現代化するとき、あなたは、ジェネリックな関数を使うことができる。また、単一なソースコードから２つのバージョンをコンパイルするためにTEXTマクロを使うことができる。１つのバージョンはUnicodeをサポートし、もう一つはWindowsコードページを扱う。このメカニズムにより、コンパイル・ビルド・テストできるアプリのソースを変換のすべてのフェーズで管理しながら、Windowsコードページを使う巨大なアプリから、Unicodeを使うアプリへ変換することができる。詳しくは「関数プロトタイプに対する慣習」を参照せよ。\r\n\r\nUnicode文字と文字列は、コードページベースの文字と文字列の型とは違ったデータ型を使う。一連のマクロと名前付け慣習と共に、この区別は、２種類の文字データを混ぜてしまう事故を最小化する。これは、コンパイラーの型チェックがUnicode文字列を期待する関数でUnicodeのパラメータだけが使われることを保証することを手助けする。', '', '', '', '', '', '2016-09-20 11:21:13', '2016-09-20 11:21:13', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374081.aspx', 'Katayama Hirofumi MZ', '', '', '', '');
INSERT INTO `entries` (`entry_name`, `entry_type`, `description`, `syntax`, `parameters`, `return_value`, `remarks`, `see_also`, `added_time`, `modified_time`, `header`, `modules`, `sources`, `translators`, `ros_location`, `analysis`, `prev_page`, `next_page`) VALUES
('Unicode and Character Sets', '', 'マイクロソフト ウィンドウズはUnicodeと伝統的な文字セットを国際的な市場の多数の異なる言語のサポートを提供する。\r\n\r\nUnicodeは、世界規模の文字エンコーディング標準であり、現代的なコンピューティングにおいて使われる、それぞれの文字を表現する一意な数を提供する。それは出版で使われる技術的な記号や特殊文字を含む。UnicodeはXMLやECMAScript (JavaScript)のように現代的な標準で必要であり、ISO/IEC 10646を実装するための公式のメカニズムである。それは多くのオペレーティングシステム、すべての現代的なブラウザー、その他の多くの製品でサポートされている。新しいWindowsアプリは、さまざまなコードページの非一貫性を避け、ローカリゼーションを単純化することを助けるために、Unicodeを使うべきである。\r\n\r\n伝統的な文字セットは、以前の文字エンコーディング標準であった。それは、特定の言語や地政学的な地域で使われる文字を表すために、8ビットコードを使ったり、8ビット値の組み合わせを使ったりしたWindowsコードページだった。', '', '', '', '', '', '2016-09-18 03:36:55', '2016-09-18 03:36:55', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374083.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Unicode in the Windows API', '', '文字を扱うWindows API関数は、一般的に以下のいずれかの形式によって実装される。\r\n\r\n * WindowsコードページとUnicodeのいずれかでもコンパイル可能なジェネリック（generic）なバージョン\r\n * \"ANSI\"を表す文字の\"A\"が付いたWindowsコードページなバージョン\r\n * \"wide\"を表す文字の\"W\"の付いたUnicodeなバージョン\r\n\r\nいくつかの新しい関数は、Unicodeなバージョンのみをサポートする。詳しくは、「関数プロトタイプとコードページに対する慣習」を参照せよ。\r\n\r\n以下のトピックスは、Unicodeのデータ型たちとそれらがどのように関数とメッセージで使われるかを議論する。リソース、ファイル名、コマンドライン引数の使用法、そして異なる型の文字列間の変換手段。\r\n\r\n * Automatic Message Translation\r\n * Character Sets Used in File Names\r\n * Command Line Arguments\r\n * Conventions for Function Prototypes\r\n * Standard C Functions\r\n * String Function Differences\r\n * Translation Between String Types\r\n * Windows Data Types for Strings', '', '', '', '', '', '2016-09-20 11:27:09', '2016-09-20 11:27:09', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374089.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Unicode Interface', '', 'Windows 95 でサポートされた IMM/IME インターフェイスの ANSI 版と共に、Windows NT と Windows 98は IME に対して Unicode インターフェイスをサポートする。Unicode インターフェイスによってシステムと通信するため、IME は、IMEINFO 構造体の fdwProperty メンバーの IME_PROP_UNICODE ビットをセットするべきだ。fdwProperty は、ImeInquire 関数の最初の引数である。ImeInquire は、アプリプロセスのすべてのスレッドに対して IME を初期化するために呼び出される。IME は、単一のシステムにおいて同じ IMEINFO 構造体を返すことを想定している。Windows 98 は、ImmIsUIMessage を除くすべての Unicode 関数をサポートする。', '', '', '', '', 'IMEINFO|ImeInquire|ImmIsUIMessage', '2016-09-10 11:02:53', '2016-09-10 11:02:53', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('UnloadKeyboardLayout', '関数', '入力ロケール識別子（旧名キーボードレイアウト）を削除します。', 'BOOL UnloadKeyboardLayout(\r\n  HKL hkl   // 入力ロケール識別子\r\n);', 'hkl --- アンロードする入力ロケール識別子（旧名キーボードレイアウトハンドル）を指定します。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。関数が失敗する理由として次が挙げられます。\r\n\r\n * 無効な入力ロケール識別子が渡されています。\r\n * 入力ロケール識別子が、あらかじめロードされています。\r\n * 入力ロケール識別子は使用中です。\r\n\r\n拡張エラー情報を取得するには、GetLastError 関数を使います。', '入力ロケール識別子には音声入力コンバータ、IME、またはその他のあらゆる入力形式が含まれており、キーボードレイアウトよりも広い概念を持ちます。\r\n\r\nWindows 95：UnloadKeyboardLayout 関数は、システム既定の入力ロケール識別子をアンロードすることができません。これにより、ファイルシステム名やシェルコマンドを入力する場合に、常に適切なキャラクタセットを利用することができます。\r\n\r\nWindows NT/2000：UnloadKeyboardLayout 関数は、システム既定の入力ロケール識別子をアンロードすることができます。', 'ActivateKeyboardLayout|GetKeyboardLayoutName|LoadKeyboardLayout', '2016-09-11 08:51:19', '2016-09-11 08:51:19', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364842.aspx', 'Microsoft', '', '', '', ''),
('UnregisterHotKey', '関数', '呼び出し側スレッドが既に定義したホットキーを破棄します。', 'BOOL UnregisterHotKey(\r\n  HWND hWnd,  // ウィンドウのハンドル\r\n  int id      // ホットキーの識別子\r\n);', 'hWnd［入力］ --- 破棄したいホットキーに関連付けられているウィンドウのハンドルを指定します。ホットキーがどのウィンドウにも関連付けられていない場合、このパラメータには NULL を指定します。\r\n///\r\nid［入力］ --- 破棄したいホットキーの識別子を指定します。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、 関数を使います。', '', 'RegisterHotKey', '2016-09-11 08:52:46', '2016-09-11 08:52:46', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364856.aspx', 'Microsoft', '', '', '', ''),
('Using lpTransMsgList to Generate Messages', '', 'IME によって開始されたイベントは、入力コンテキストに関連付けられたウィンドウへのメッセージを生成するように実現される。基本的に、IME は ImeToAsciiEx の引数として与えられた lpTransMsgList を使って、メッセージを生成する。ImeToAsciiEx が呼び出されたとき、IME は lpTransMsgList バッファへメッセージを追加する。\r\n\r\nImeToAsciiEx 関数の lpTransMsgList で指定されたバッファは、システムによって提供される。この関数は、一度にバッファ内のすべてのメッセージたちを置くことができる。メッセージの本当の個数は、バッファ先頭のダブルワード値で与えられる。しかしながら、もし、ImeToAsciiEx 関数が、与えられた個数よりも多くのメッセージを生成したいなら、ImeToAsciiEx 関数は、入力コンテキスト内の hMsgBuf へすべてのメッセージを置くことができ、そのときメッセージの個数が戻り値として返される。\r\n\r\nImeToAsciiEx の戻り値が lpTransMsgList で指定された値よりも大きいとき、システムは、lpTransMsgList からメッセージを取り出さない。代わりに、システムは入力コンテキスト内の hMsgBuf を見る。この hMsgBuf は、ImeToAsciiEx の引数として渡される。', '', '', '', '', 'ImeToAsciiEx', '2016-09-10 10:33:37', '2016-09-10 10:33:37', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Using Supplementary Characters', '', 'UTF-16は補助文字をサロゲートペアとして扱う。OSは、サロゲートペアを非空白マークと同じように処理する。表示のときは、サロゲートペアは「Unicode標準」で処方されるように、Uniscribeの手段によって１つのグリフ（字形）を表示する。\r\n\r\nWindows Vistaは、UTF-16文字列においてサロゲートとサロゲートペアの識別を助けるために、３つの新しいマクロを導入した。それらはIS_HIGH_SURROGATE、IS_LOW_SURROGATE、IS_SURROGATE_PAIRである。\r\n\r\nあるアプリがUnicodeをサポートしていて、システムコントロールと標準API関数（ExtTextOutやDrawTextなど）を使っていれば、自動的に補助文字をサポートする。よって、もしあなたのアプリが標準システムコントロールを使い、表示に一般的なExtTextOutのタイプの呼び出しを使っていれば、補助文字は、特殊なコードを書かなくてもうまく動作するべきである。\r\n\r\nApplications that implement their own editing support by working out glyph positions in a customized way can use Uniscribe for all text processing. Uniscribe has separate functions to deal with complex script processing, such as text display, hit testing, and cursor movement. An application must call the Uniscribe functions specifically to get these advanced features. Note that applications using the Uniscribe functions are fully multilingual, but this imposes a performance penalty. Thus some applications should do their own processing of supplementary characters.\r\n\r\n補助文字を表現するためのサロゲートのメカニズムは、うまく定義されて（well-defined）いるので、アプリはUTF-16サロゲートテキスト処理を扱うコードを含むことができる。アプリが、サロゲートペアになっていない分離されたサロゲートのUTF-16の値に遭遇したら、その値は、サロゲートペアの半分でなければならない。したがって、アプリは単純な範囲チェックによってサロゲートペアを検出できる。アプリがもし上位または下位の範囲内のUTF-16の値に遭遇したら、文字の残りを取得するために、前または次の16ビット値にアクセスしないといけない。あなたはアプリを書いているときは、CharNextとCharPrevは、サロゲートペアではなく16ビットのコードポイント単位で動くことに注意せよ。\r\n\r\n注意：単独のサロゲートなコードポイントは、下位に接することのない上位のサロゲートか、上位に接することのない下位のサロゲートである。それらのコードポイントは、無効でありサポートされない。振る舞いは未定義である。\r\n\r\nもしあなたがフォントを開発しているか、IMEの提供者なら、Windows XP以前のOSは、デフォルトで補助文字が無効になっていることに注意せよ。Windows XPとそれ以降は、補助文字をデフォルトで有効にしている。もしあなたが補助文字を必要とするフォントまたはIMEパッケージを提供するなら、あなたのアプリは、次のレジストリの値をセットしなければならない：\r\n\r\n<pre>[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\LanguagePack] SURROGATE=(REG_DWORD)0x00000002\r\n \r\n[HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\International\\Scripts\\42] IEFixedFontName=[Surrogate Font Face Name] IEPropFontName=[Surrogate Font Face Name]</pre>', '', '', '', '', '', '2016-09-20 11:56:40', '2016-09-20 11:56:40', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('Using the Input Context', '', 'アプリまたはシステムが新しい入力コンテキストを作成するとき、システムは、新しい入力コンテキストに IMCのコンポーネント（IMCC）たちを用意する。コンポーネントたちは、hCompStr、 hCandInfo、 hGuideLine、 hPrivate、そして hMsgBuf である。基本的に、IME は、入力コンテキストとそのコンポーネントたちを作成する必要がない。IME は、それらのコンポーネントのサイズを変更でき、そのポインタを取得するためにロックできる。\r\n\r\n * HIMC へのアクセス方法\r\n * HIMCC へのアクセス方法', '', '', '', '', 'Accessing the HIMC|Accessing the HIMCC', '2016-09-10 10:28:09', '2016-09-10 10:28:09', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Using the Message Buffer to Generate Messages', '', 'もし、ImeToAsciiEx が呼び出されていない場合でも、IME は入力コンテキストのメッセージバッファを使って、入力コンテキストに関連付けられたウィンドウにメッセージを生成することができる。このメッセージバッファは、メモリーブロックのハンドルとして処理され、IME は、メッセージをこのメモリーブロックへ置く。それからIME は、ImmGenerateMessage 関数を呼び、それが適切なウィンドウへのメッセージバッファに格納されたメッセージを送信する。', '', '', '', '', 'ImeToAsciiEx|ImmGenerateMessage', '2016-09-10 10:34:32', '2016-09-10 10:34:32', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Virtual-Key Codes', '', '以下の表は、システムで使われる仮想キーコードと等価な、記号的な定数名と十六進数の値と、マウスとキーボードを表しています。\r\nコードは、数値順でリストされています。\r\n\r\n[table:Virtual-Key Codes_Table1]', '', '', '', '', '', '2016-09-11 02:28:41', '2016-09-11 02:28:41', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731', 'Katayama Hirofumi MZ', '', '', '', ''),
('Virtual-Key Codes Described', '', 'キーストロークメッセージのwParamパラメータは、押し離ししたキーの仮想キーコードを含む。ウィンドウプロシージャは、仮想キーコードの値に応じてキーストロークメッセージを処理または無視する。\r\n\r\nたいていのウィンドウプロシージャは、受け取るキーストロークメッセージの小さなサブセットのみを処理し、残りを無視する。例えば、あるウィンドウプロシージャは、（訳略）WM_KEYDOWNメッセージのみを処理する。たいていのウィンドウプロシージャは、キーストロークメッセージを処理しない。代わりにメッセージを文字メッセージに変換するためにTranslateMessage関数を使う。TranslateMessageと文字メッセージに関しては、文字メッセージを参照せよ。', '', '', '', '', '', '2016-09-14 10:24:31', '2016-09-14 10:24:31', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646267.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('VkKeyScan', '関数', '任意の文字を、現在のキーボードに対応する仮想キーコードとシフト状態に変換します。\r\n\r\nこの関数は、VkKeyScanEx 関数に取って代わられましたが、キーボードレイアウトを指定する必要がなければまだ使えます。', 'SHORT VkKeyScan(\r\n  TCHAR ch   // 変換したい文字\r\n);', 'ch［入力］ --- 仮想キーコードへ変換したい文字を指定します。', '関数が成功すると、下位バイトが仮想キーコードで上位バイトがシフト状態の値が返ります。上位バイトは、次の値の組み合わせになります。\r\n\r\n[table:VkKeyScan_Table1]\r\n\r\n渡された文字コードに対応するキーが見つからない場合、下位バイト、上位バイトとも -1 の値が返ります。', '右側の Alt キーをシフトキーとして使うキーボードレイアウト（ たとえば、フランス語のキーボードレイアウト）では、シフト状態は値 6 と表されます。右の Alt キーは内部で Ctrl+Alt へ変換されるからです。\r\n\r\n数字キーパッド（VK_NUMPAD0～VK_DIVIDE）への変換は無視されます。この関数は、文字を、10 キーを除くメインキーボードセクションのキーストロークへのみ変換することを意図しているからです。たとえば、文字「7」は、VK_7 へ変換されますが、VK_NUMPAD7 へ変換されることはありません。\r\n\r\nVkKeyScan 関数は、WM_KEYUP や WM_KEYDOWN メッセージを使って文字を送信するアプリケーションで使われます。', 'GetAsyncKeyState|GetKeyboardState|GetKeyNameText|GetKeyState|SetKeyboardState|VkKeyScanEx|WM_KEYDOWN|WM_KEYUP', '2016-09-11 08:54:28', '2016-09-11 08:54:28', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364860.aspx', 'Microsoft', '', '', '', ''),
('VkKeyScanEx', '関数', '任意の文字を、対応する仮想キーコードとシフト状態へ変換します。この関数は、入力言語と、入力ロケール識別子が指定する物理的なキーボードレイアウトを使って、文字を変換します。', 'SHORT VkKeyScanEx(\r\n  TCHAR ch,  // 変換したい文字\r\n  HKL dwhkl  // 入力ロケール識別子\r\n);', 'ch［入力］ --- 仮想キーコードへ変換したい文字を指定します。\r\n///\r\ndwhkl［入力］ --- 文字を変換する際に利用したい入力ロケール識別子を指定します。このパラメータは、LoadKeyboardLayout 関数が返した、任意の入力ロケール識別子を利用できます。', '関数が成功すると、下位バイトには仮想キーコードを含む値が返ります。上位バイトにはシフト状態を含む値が返り、次のフラグビットの組み合わせになります。\r\n\r\n[table:VkKeyScanEx_Table1]\r\n\r\n関数が、渡された文字コードに対応するキーを見つけられなかった場合、上位バイトと下位バイトの両方が -1 になります。', '入力ロケール識別子は、キーボードレイアウトより包括的な概念です。入力ロケール識別子は、音声認識（ 音声からテキストへのコンバータ）、IME、他の形態の入力にも拡張できるからです。\r\n\r\n右側の Alt キーをシフトキーとして使うキーボードレイアウト（ たとえばフランス語のキーボードレイアウト）では、シフト状態は値 6 と表されます。右側の Alt キーは、内部で Ctrl+Alt へ変換されるからです。\r\n\r\n数字キーパッド（VK_NUMPAD0～VK_DIVIDE）への変換は無視されます。この関数は、文字を、10 キーを除くメインキーボードセクションのキーストロークへのみ変換することを意図しているからです。たとえば、文字「7」は VK_7 へ変換されますが、VK_NUMPAD7 へ変換されることはありません。\r\n\r\nVkKeyScanEx 関数は、WM_KEYUP や WM_KEYDOWN メッセージを使って文字を送信するアプリケーションで使われます。', 'GetAsyncKeyState|GetKeyboardState|GetKeyNameText|GetKeyState|LoadKeyboardLayout|SetKeyboardState|ToAsciiEx', '2016-09-11 08:57:13', '2016-09-11 08:57:13', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364882.aspx', 'Microsoft', '', '', '', ''),
('WaitMessage', '関数', 'あるスレッドのメッセージキューの中にメッセージが存在しない場合、ほかのスレッドに制御を与えます。この関数は、最初のスレッドを一時停止し、そのスレッドのメッセージキューに新しいメッセージが置かれるまで制御を返しません。', 'BOOL WaitMessage(VOID);', 'パラメータはありません。', '関数が成功すると、0 以外の値が返ります。\r\n\r\n関数が失敗すると、0 が返ります。拡張エラー情報を取得するには、 関数を使います。', 'まだ読み取られていない入力メッセージがメッセージキューの中に存在する場合でも、キューを調査する関数を呼び出してから WaitMessage 関数を呼び出すと、制御が返らないことに注意してください。PeekMessage、GetMessage、GetQueueStatus、WaitMessage、、 のような関数は、キューを調査した後、そのキューを、新しいとは見なされない状態へ変更するからです。その後、WaitMessage 関数を呼び出しても、指定されたタイプの新しい入力メッセージが到着するまでは、WaitMessage 関数は制御を返しません。まだ読み取られていない既存の入力メッセージ（スレッドがキューを直前に調査する時点より前に受信したメッセージ）は、（WaitMessage が制御を返すかどうか判断する意味では）無視されます。', 'GetMessage|PeekMessage|WaitMessage', '2016-08-28 05:33:21', '2016-08-28 05:33:21', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/ja-jp/library/cc364864.aspx', 'Microsoft', '', '', '', ''),
('Win32 IME Structure', '', '新しい Win32 IME は、2 つのコンポーネントを提供する必要がある。一つは IME 変換インターフェイスで、もう一つは IME ユーザインターフェイス (操作系：UI) だ。IME 変換インターフェイスは、IME モジュールからエクスポートされた、関数の集合として提供される。それらの関数は IMM によって呼び出せる。IME UI は、ウィンドウフォームとして提供される。それらのウィンドウは、メッセージを受け取り、IME に対する UI を提供する。', '', '', '', '', '', '2016-09-10 10:10:55', '2016-09-10 10:10:55', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('Window Procedure', '', 'ウィンドウプロシージャは、ウィンドウに送信されたすべてのメッセージを受け取り、処理する関数である。すべてのウィンドウクラスは、ウィンドウプロシージャを持ち、そのクラスで作成されたすべてのウィンドウは、メッセージに応えるために同じウィンドウプロシージャを使う。\r\n\r\nシステムはメッセージを、プロシージャへメッセージデータを引数として渡すことで、ウィンドウプロシージャに送信する。そしてウィンドウプロシージャは、メッセージに対して適切なアクションを実行する。それはメッセージ識別子をチェックし、メッセージを処理する間、メッセージパラメータによって指定された情報を使う。\r\n\r\nウィンドウプロシージャは、通常メッセージを無視しない。メッセージを処理しないなら、それは既定の処理としてシステムに送信される。ウィンドウプロシージャは、これをDefWindowProc関数を呼び出す形で行う。DefWindowProcはメッセージ結果を戻り値として返す。ウィンドウプロシージャは、この値を自分自身のメッセージ結果として返さなければならない。ほとんどのウィンドウプロシージャは、いくつかの少ないメッセージのみを処理し、他のメッセージをDefWindowProcを呼ぶことでシステムに渡す。\r\n\r\nウィンドウプロシージャは、同じクラスに属するすべてのウィンドウで共有されるので、いくつかの異なるウィンドウに対するメッセージも処理できる。メッセージに影響する特定のウィンドウを識別するには、ウィンドウプロシージャは、メッセージに渡されたウィンドウハンドルを検査することができる。', '', '', '', '', 'DefWindowProc', '2016-09-04 02:14:31', '2016-09-04 02:14:31', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'Message Loop', 'Message Filtering'),
('Windows Messages', '', 'システムは入力をメッセージという形でウィンドウプロシージャに渡す。メッセージはシステムとアプリ両方で生成される。システムは入力イベントごとにメッセージを生成する。例えば、ユーザーがキーを打ち込んだり、マウスを移動したり、スクロールバーなどのコントロールをクリックしたりしたときだ。システムはまた、アプリによって引き起こされたシステムにおける変更への反応としてメッセージを生成する。例えば、アプリがシステムフォントリソースのプールを変更したり、アプリのウィンドウの一つのサイズを変更したりしたときだ。アプリはタスクを実行したり、他のアプリのウィンドウと通信したりする目的で、アプリが所有するウィンドウを指図するためにメッセージを生成できる。\r\n\r\nシステムは4つのパラメータの集合としてウィンドウプロシージャにメッセージを送信する：ウィンドウハンドル、メッセージ識別子、2つのメッセージパラメータと呼ばれる値。ウィンドウハンドルは、メッセージの対象を識別子する。システムはウィンドウハンドルにより、どのウィンドウプロシージャがメッセージを受け取るべきかを決定する。\r\n\r\nメッセージ識別子は、メッセージの目的を識別する名前の付いた定数である。ウィンドウプロシージャがメッセージを受け取ったとき、ウィンドウプロシージャはどのようにメッセージを処理するかを決めるためにメッセージ識別子を使う。例えば、メッセージ識別子WM_PAINTは、ウィンドウプロシージャにウィンドウのクライアント領域が変更され、再描画しなければならないことを伝える。\r\n\r\nメッセージパラメータは、メッセージを処理するときにウィンドウプロシージャによってデータやデータの所在を指定する。メッセージパラメータの意味と値はメッセージに依存する。メッセージパラメータは、整数やパックされたビットフラグ、追加的なデータを含む構造体へのポインタなどを含むことができる。メッセージがメッセージパラメータを使わないとき、それらは典型的にゼロにセットされる。ウィンドウプロシージャは、メッセージパラメータをどのように解釈するために、メッセージ識別子をチェックしなければならない。', '', '', '', '', '', '2016-09-04 00:19:03', '2016-09-04 00:19:03', '', '', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927.aspx', 'Katayama Hirofumi MZ', '', '', 'About Messages and Message Queues', 'Message Types'),
('Winlogon', '', 'ログオンセッションのユーザは、まだシステムへのアクセス権が許されないので、IME の設定ダイアログで提供された情報は、セキュリティ問題を生じかねない。だが、システム管理者は、ログオンセッション上で IME がアクティブにならないようにシステムの設定を変更できる。うまくふるまう IME は、IME のクライアントプロセスがWinlogon プロセスだったなら、ユーザに設定ダイアログを開くことを許すべきではない。IME は、もし、ログオンセッションを実行しているクライアントプロセスが Winlogon プロセスかどうかを、ImeInquire 関数の引数dwSystemInfoFlags の IME_SYSTEMINFO_WINLOGON ビットにより、チェックできる。', '', '', '', '', 'ImeInquire', '2016-09-10 11:01:41', '2016-09-10 11:01:41', '', '', 'Win32 Multilingual IME Overview for IME Development Version 1.41', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_CHAR', 'メッセージ', 'WM_KEYDOWNメッセージがTranslateMessage関数によって変換されたときにキーボードフォーカスを持つウィンドウにポストされる。WM_CHARメッセージは、押されたキーの文字コードを含む。', 'WM_CHAR', 'wParam --- キーの文字コード。\r\n///\r\nlParam --- リピートカウント、拡張キーフラグ、コンテキストコード、直前のキー状態フラグ、そしてトランジション状態フラグが以下の表のように与えられる。\r\n\r\n[table:WM_CHAR_Table1]', 'アプリはこのメッセージを処理したら、ゼロを返すべきだ。', 'The WM_CHAR message uses Unicode Transformation Format (UTF)-16. \r\n\r\nBecause there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the information in the high-order word of the lParam parameter is generally not useful to applications. The information in the high-order word applies only to the most recent WM_KEYDOWN message that precedes the posting of the WM_CHAR message. \r\n\r\nFor enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the lParam parameter. \r\n\r\nThe WM_UNICHAR message is the same as WM_CHAR, except it uses UTF-32. It is designed to send or post Unicode characters to ANSI windows, and it can handle Unicode Supplementary Plane characters.', 'WM_KEYDOWN|WM_KEYUP|WM_IME_CHAR', '2016-09-01 10:26:41', '2016-09-01 10:26:41', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646276.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_CHAR', 'メッセージ', 'IMEが変換結果の文字を取得するときに、アプリに送られます。ウィンドウは、そのウィンドウプロシージャーを通じてこのメッセージを受け取ります。', 'WM_IME_CHAR', 'hwnd --- ウィンドウへのハンドル。\r\n///\r\nwParam --- DBCS: １バイト文字か、２バイト文字の値。２バイト文字については、(BYTE)(wParam >> 8)が最初のバイトになる。\r\n\r\nUnicode: Unicode文字の値。\r\n///\r\nlParam --- 以下のように定義されるリピートカウント、スキャンコード、拡張キーフラグ、コンテキストコード、直前のキー状態フラグ、そして、トランジション状態フラグ。\r\n\r\n[table:WM_IME_CHAR_Table1]', '', '非Unicodeウィンドウに対するWM_CHARメッセージとは違って、このメッセージは、２バイト文字や１バイト文字を含むことができます。Unicodeウィンドウでは、このメッセージはWM_CHARと同じです。\r\n\r\n非Unicodeウィンドウに対しては、もしWM_IME_CHARメッセージが２バイト文字を含み、アプリがこのメッセージをDefWindowProcに渡したら、IMEはこのメッセージを２つのWM_CHARメッセージに変換し、それぞれが２バイト文字の1バイトを含みます。', 'WM_IME_KEYDOWN|WM_IME_KEYUP|WM_CHAR', '2016-08-28 03:28:27', '2016-08-28 03:28:27', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374132.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_COMPOSITION', 'メッセージ', 'IMEがキー入力の結果として、コンポジション状態を変更するとき、アプリに送信されます。ウィンドウプロシージャーを通じて、ウィンドウはこのメッセージを受け取ります。', 'WM_IME_COMPOSITION', 'hwnd --- ウィンドウへのハンドル。\r\n///\r\nwParam --- コンポジション文字列への最後の変更を表すDBCS文字。\r\n///\r\nlParam --- どのようにコンポジション文字列が変更されたかを表す値。このパラメーターは以下の１個以上の値です。これらの値の詳細は、「IMEコンポジション文字列の値」をご覧ください。\r\n\r\n * GCS_COMPATTR\r\n * GCS_COMPCLAUSE\r\n * GCS_COMPREADSTR\r\n * GCS_COMPREADATTR\r\n * GCS_COMPREADCLAUSE\r\n * GCS_COMPSTR\r\n * GCS_CURSORPOS\r\n * GCS_DELTASTART\r\n * GCS_RESULTCLAUSE\r\n * GCS_RESULTREADCLAUSE\r\n * GCS_RESULTREADSTR\r\n * GCS_RESULTSTR\r\n\r\nlParamはさらに次の１個以上の値を持つことができます。\r\n\r\n[table:WM_IME_COMPOSITION_Table1]', '戻り値はありません。', 'アプリ自体がコンポジション文字列を表示するなら、アプリはこのメッセージを処理すべきです。さもなければ、メッセージをIMEウィンドウに送信すべきです。\r\n\r\nアプリがIMEウィンドウを作成したら、このメッセージをそのウィンドウへ渡すべきです。DefWindowProc関数は、このメッセージを既定のIMEウィンドウへ渡すことで処理します。IMEウィンドウは指定された変更フラグに基づいてIMEの見た目を更新することで、このメッセージを処理します。アプリは、新しいコンポジション状態を取得するために、ImmGetCompositionStringを呼び出すことができます。\r\n\r\nGCS_値が指定されなければ、メッセージは現在のコンポジションがキャンセルされ、かつ、コンポジション文字列を描画するアプリがコンポジション文字列を削除すべきことを意味します。', 'WM_IME_STARTCOMPOSITION|WM_IME_ENDCOMPOSITION|ImmGetCompositionString', '2016-08-28 03:37:45', '2016-08-28 03:37:45', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374133.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_COMPOSITIONFULL', 'メッセージ', 'IMEウィンドウがコンポジションウィンドウの領域を拡張するスペースがないとき、アプリに送信されます。ウィンドウは、ウィンドウプロシージャーを通じて、このメッセージを受け取ります。', 'WM_IME_COMPOSITIONFULL', 'パラメーターはありません。', '戻り値はありません。', 'アプリは、どのようにウィンドウを表示すべきかを指定するために、IMC_SETCOMPOSITIONWINDOWコマンドを使うべきです。\r\n\r\nIMEの代わりにIMEウィンドウが、SendMessage関数によってこの通知メッセージを送信します。', 'WM_IME_COMPOSITION', '2016-08-28 03:40:53', '2016-08-28 03:40:53', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374134.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_CONTROL', 'メッセージ', '要求したコマンドを実行するIMEウィンドウを指揮するために、アプリによって送信されます。アプリはアプリ自体が作成したIMEウィンドウを制御するためにこのメッセージを使います。このメッセージを送信するためには、アプリは、以下のパラメーターでSendMessage関数を呼びます。', 'WM_IME_CONTROL', 'hwnd --- ウィンドウへのハンドル。\r\n///\r\nwParam --- コマンドです。このパラメーターは、以下のうち１個を指定します。\r\n\r\n * IMC_CLOSESTATUSWINDOW\r\n * IMC_GETCANDIDATEPOS\r\n * IMC_GETCOMPOSITIONFONT\r\n * IMC_GETCOMPOSITIONWINDOW\r\n * IMC_GETSTATUSWINDOWPOS\r\n * IMC_OPENSTATUSWINDOW\r\n * IMC_SETCANDIDATEPOS\r\n * IMC_SETCOMPOSITIONFONT\r\n * IMC_SETCOMPOSITIONWINDOW\r\n * IMC_SETSTATUSWINDOWPOS \r\n///\r\nlParam --- wParamの値に依存した形式のコマンド特有のデータです。詳細は、それぞれのコマンドの書類をご覧ください。', 'メッセージはコマンド特有の値を返します。', '', 'IMC_CLOSESTATUSWINDOW|IMC_GETCANDIDATEPOS|IMC_GETCOMPOSITIONFONT|IMC_GETCOMPOSITIONWINDOW|IMC_GETSTATUSWINDOWPOS|IMC_OPENSTATUSWINDOW|IMC_SETCANDIDATEPOS|IMC_SETCOMPOSITIONFONT|IMC_SETCOMPOSITIONWINDOW|IMC_SETSTATUSWINDOWPOS', '2016-08-28 03:46:47', '2016-08-28 03:46:47', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374135.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_ENDCOMPOSITION', 'メッセージ', 'IMEがコンポジションを終わるときに、アプリに送信されます。ウィンドウはウィンドウプロシージャーを通じてこのメッセージを受け取ります。', 'WM_IME_ENDCOMPOSITION', 'パラメーターはありません。', '戻り値はありません。', 'アプリ自体がコンポジション文字列を表示するなら、アプリはこのメッセージを処理すべきです。\r\n\r\nもしアプリがIMEウィンドウを作成したなら、アプリはそのウィンドウにこのメッセージを渡すべきです。DefWindowProc関数は、このメッセージを既定のIMEウィンドウに渡すことで処理します。', 'WM_IME_STARTCOMPOSITION|WM_IME_COMPOSITION|DefWindowProc', '2016-08-28 03:51:26', '2016-08-28 03:51:26', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374136.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_KEYDOWN', 'メッセージ', 'キー入力をアプリに通知し、かつメッセージ順序を保つため、IMEによってアプリに送信されます。ウィンドウはこのメッセージをそのウィンドウプロシージャーを通じて受け取ります。', 'WM_IME_KEYDOWN', 'hwnd --- ウィンドウへのハンドル。\r\n///\r\nwParam --- キーの仮想キーコード。 \r\n///\r\nlParam --- 下記の表に示される、リピートカウント、スキャンコード、拡張キーフラグ、コンテキストコード、直前のキー状態フラグ、そしてトランジション状態フラグ。\r\n\r\n[table:WM_IME_KEYDOWN_Table1]', 'アプリはこのメッセージを処理したら、ゼロを返すべきです。', 'アプリは、このメッセージを処理するか、対応するWM_KEYDOWNメッセージを生成するためにDefWindowProcに渡すことができます。', 'WM_IME_KEYUP|WM_KEYDOWN', '2016-08-28 03:55:45', '2016-08-28 03:55:45', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374137.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_KEYUP', 'メッセージ', 'アプリにキーの離されたことを通知するために、またメッセージ順序を保つために、IMEによってアプリに送信されます。ウィンドウはウィンドウプロシージャーを通じてこのメッセージを受け取ります。', 'WM_IME_KEYUP', 'hwnd --- ウィンドウへのハンドルです。\r\n///\r\nwParam --- キーの仮想キーコード。\r\n///\r\nlParam --- 下記に示される、リピートカウント、スキャンコード、拡張キーフラグ、コンテキストコード、直前のキー状態フラグ、そしてトランジション状態フラグ。\r\n\r\n[table:WM_IME_KEYUP_Table1]', 'アプリはこのメッセージを処理したら、ゼロを返すべきです。', 'アプリは、このメッセージを処理するか、対応するWM_KEYUPメッセージを生成するために、DefWindowProc関数に渡すことができます。', 'WM_IME_KEYDOWN|WM_KEYUP', '2016-08-28 04:03:06', '2016-08-28 04:03:06', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374138.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_NOTIFY', 'メッセージ', 'IMEウィンドウへの変更を通知するためにアプリに送信されます。ウィンドウは、ウィンドウプロシージャーを通じてこのメッセージを受け取ります。', 'WM_IME_NOTIFY', 'hwnd --- ウィンドウへのハンドル。\r\n///\r\nwParam --- コマンド。このパラメーターは次のうちの一つです。\r\n\r\n * IMN_CHANGECANDIDATE\r\n * IMN_CLOSECANDIDATE\r\n * IMN_CLOSESTATUSWINDOW\r\n * IMN_GUIDELINE\r\n * IMN_OPENCANDIDATE\r\n * IMN_OPENSTATUSWINDOW\r\n * IMN_SETCANDIDATEPOS\r\n * IMN_SETCOMPOSITIONFONT\r\n * IMN_SETCOMPOSITIONWINDOW\r\n * IMN_SETCONVERSIONMODE\r\n * IMN_SETOPENSTATUS\r\n * IMN_SETSENTENCEMODE\r\n * IMN_SETSTATUSWINDOWPOS \r\n///\r\nlParam --- wParamパラメーターの値に基づく形式のコマンド特有のデータ。詳細はそれぞれのコマンドの書類を参照下さい。', '戻り値は、送信されたコマンドに依存します。', 'アプリ自体がIMEウィンドウを管理する義務があれば、アプリはこのメッセージを処理すべきです。', 'ImmNotifyIME|NotifyIME|IMN_CHANGECANDIDATE|IMN_CLOSECANDIDATE|IMN_CLOSESTATUSWINDOW|IMN_GUIDELINE|IMN_OPENCANDIDATE|IMN_OPENSTATUSWINDOW|IMN_SETCANDIDATEPOS|IMN_SETCOMPOSITIONFONT|IMN_SETCOMPOSITIONWINDOW|IMN_SETCONVERSIONMODE|IMN_SETOPENSTATUS|IMN_SETSENTENCEMODE|IMN_SETSTATUSWINDOWPOS', '2016-08-28 04:06:47', '2016-08-28 04:06:47', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374139.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_REQUEST', 'メッセージ', 'コマンドと要求情報を提供するためにアプリに送信されます。ウィンドウは、ウィンドウプロシージャーを通じてこのメッセージを受け取ります。', 'WM_IME_REQUEST', 'hwnd --- ウィンドウへのハンドル。\r\n/// \r\nwParam --- コマンド。このパラメーターは以下のうちの１つです。\r\n\r\n * IMR_CANDIDATEWINDOW\r\n * IMR_COMPOSITIONFONT\r\n * IMR_COMPOSITIONWINDOW\r\n * IMR_CONFIRMRECONVERTSTRING\r\n * IMR_DOCUMENTFEED\r\n * IMR_QUERYCHARPOSITION\r\n * IMR_RECONVERTSTRING \r\n///\r\nlParam --- コマンド特有のデータ。詳しくは、それぞれのコマンドの書類を参照下さい。', 'コマンド特有の値を返します。', '', 'IMR_CANDIDATEWINDOW|IMR_COMPOSITIONFONT|IMR_COMPOSITIONWINDOW|IMR_CONFIRMRECONVERTSTRING|IMR_DOCUMENTFEED|IMR_QUERYCHARPOSITION|IMR_RECONVERTSTRING', '2016-08-28 04:09:29', '2016-08-28 04:09:29', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374140.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_SELECT', 'メッセージ', 'OSが現在のIMEを変更しようとしているときに、アプリに送信されます。ウィンドウは、ウィンドウプロシージャーを通じてこのメッセージを受け取ります。', 'WM_IME_SELECT', 'hwnd --- ウィンドウへのハンドル。\r\n///\r\nwParam --- 選択指定子。このパラメーターは、指定したIMEが選択されたときTRUEを指定します。このパラメーターは、指定したIMEの選択が解除されたときFALSEを指定します。\r\n///\r\nlParam --- IMEに関連付けられた入力ロケール。', '戻り値はありません。', 'IMEウィンドウを作成したアプリは、そのウィンドウが、新しく選択されたIMEへのハンドルを取得できるようにするために、このメッセージをそのウィンドウに渡すべきです。\r\n\r\nDefWindowProc関数は、このメッセージを既定のIMEウィンドウに情報を渡すことで処理します。', 'DefWindowProc', '2016-08-28 04:14:02', '2016-08-28 04:14:02', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374141.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_SETCONTEXT', 'メッセージ', 'ウィンドウがアクティブになるとき、アプリに送信されます。ウィンドウは、ウィンドウプロシージャーを通じてこのメッセージを受け取ります。', 'WM_IME_SETCONTEXT', 'hwnd --- ウィンドウへのハンドル。\r\n///\r\nwParam --- アクティブになるときTRUE。さもなければFALSE。\r\n///\r\nlParam --- 表示オプションたち。このパラメーターは、次の1個以上の値です。\r\n\r\n[table:WM_IME_SETCONTEXT_Table1]', 'DefWindowProcかImmIsUIMessageの戻り値を返します。', 'アプリがIMEウィンドウを作成したなら、アプリはImmIsUIMessageを呼び出すべきです。さもなければDefWindowProcにこのメッセージを渡すべきです。\r\n\r\nもしアプリがコンポジションウィンドウを描画するなら、既定のIMEウィンドウはそのコンポジションウィンドウを表示する必要がありません。この場合、アプリは、メッセージをDefWindowProcかImmIsUIMessageに渡す前に、lParamパラメーターからISC_SHOWUICOMPOSITIONWINDOWの値をクリアしなければなりません。あるUIウィンドウを表示するためには、IMEがそれを表示しないように、アプリは対応する値を削除すべきです。', 'ImmIsUIMessage|DefWindowProc', '2016-08-28 04:51:37', '2016-08-28 04:51:37', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374142.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_IME_STARTCOMPOSITION', 'メッセージ', 'キー入力の結果としてIMEがコンポジション文字列を生成する直前に送信されます。ウィンドウは、ウィンドウプロシージャーを通じてこのメッセージを受け取ります。', 'WM_IME_STARTCOMPOSITION', 'パラメーターはありません。', '戻り値はありません。', 'このメッセージは、IME自身のコンポジションウィンドウを開くためのIMEウィンドウへの通知です。アプリ自体がコンポジション文字列を表示するなら、アプリはこのメッセージを処理すべきです。\r\n\r\nもしアプリがIMEウィンドウを作成したなら、このメッセージはそのウィンドウへ渡すべきです。DefWindowProc関数はこのメッセージを既定のIMEウィンドウに渡すことにより処理します。', 'WM_IME_COMPOSITION|WM_IME_ENDCOMPOSITION', '2016-08-28 04:55:13', '2016-08-28 04:55:13', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/dd374143.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_INPUTLANGCHANGE', 'メッセージ', 'アプリの入力言語が変更された後にトップレベルのウィンドウに送信される。あなたはこのメッセージに対してアプリ特有の設定を行い、このメッセージをDefWindowProc関数に渡すことで、すべての最初のレベルの子ウィンドウに渡すべきだ。それらの子ウィンドウはそのメッセージをDefWindowProcに渡すことでそのまた子ウィンドウに渡すことを繰り返す。\r\n\r\nウィンドウは、ウィンドウプロシージャ関数を通じてこのメッセージを受け取る。', '#define WM_INPUTLANGCHANGE              0x0051', 'wParam --- 新しいロケールの文字セット。\r\n///\r\nlParam --- 入力ロケール識別子。詳細は、「言語、ロケール、そしてキーボードレイアウト」を参照。', 'アプリはこのメッセージを処理したら、非ゼロを返すべきだ。', '', 'Languages, Locales, and Keyboard Layouts|DefWindowProc|WM_INPUTLANGCHANGEREQUEST', '2016-09-10 07:08:44', '2016-09-10 07:08:44', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms632629.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_INPUTLANGCHANGEREQUEST', 'メッセージ', 'ユーザーが新しい入力言語を選択したときに、フォーカスを持ったウィンドウにポストされる。（キーボードコントロールパネルアプリ内で指定された）ホットキーと共に、あるいはシステムタスクバー上のインディケータからポストされる。アプリはこのメッセージをDefWindowProc関数に渡すことで変更を受け入れるか、すぐに返すことで取り下げる（実行を防ぐ）ことができる。\r\n\r\nウィンドウは、このメッセージをウィンドウプロシージャ関数を通じて受け取る。', '#define WM_INPUTLANGCHANGEREQUEST       0x0050', 'wParam --- 新しい入力ロケール。このパラメータは以下のフラグの組み合わせです。\r\n\r\n[table:WM_INPUTLANGCHANGEREQUEST_Table1]\r\n///\r\nlParam --- 入力ロケールの識別子。詳細は、「言語、ロケール、そしてキーボードレイアウト」を参照。', 'このメッセージはアプリにポストされるが、送信されない。よって戻り値は無視される。変更を受け入れるには、このメッセージをDefWindowProcに渡すべきだ。変更を取り下げるには、アプリはDefWindowProcを呼ぶことなくゼロを戻り値として返すべきだ。', 'DefWindowProc関数がWM_INPUTLANGCHANGEREQUESTメッセージを受け取ったとき、DefWindowProcは新しいロケールをアクティブ化し、アプリにWM_INPUTLANGCHANGEメッセージを送信することで変更を通知する。\r\n\r\n言語識別子は、2個以上のキーボードレイアウトをインストールしている場合で、キーボードコントロールパネルアプリを使ってインディケータを有効にしている場合に限り、タスクバーに存在する。', 'Languages, Locales, and Keyboard Layouts|DefWindowProc|WM_INPUTLANGCHANGE', '2016-09-10 06:59:43', '2016-09-10 06:59:43', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms632630.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_KEYDOWN', 'メッセージ', '非システムキーが押されたときに、キーボードフォーカスを持つウィンドウにポストされる。非システムキーとは、Altキーが押されていないときは、押されたキーのことである。', 'WM_KEYDOWN', 'wParam --- 非システムキーの仮想キーコード。「仮想キーコード」を参照。\r\n///\r\nlParam --- 下記に示される、リピートカウント、拡張キーフラグ、コンテキストコード、直前のキー状態フラグ、そしてトランジション状態フラグ。\r\n\r\n[table:WM_KEYDOWN_Table1]', 'アプリはこのメッセージを処理したら、ゼロを返すべきだ。', 'もしF10キーが押されれば、DefWindowProc関数は、内部フラグをセットする。DefWindowProcがWM_KEYUPメッセージを受け取ったとき、関数は、内部フラグがセットされているかチェックして、もしそうであれば、WM_SYSCOMMANDメッセージをトップレベルのウィンドウに送信する。WM_SYSCOMMANDメッセージのパラメータは、SC_KEYMENUにセットされる。\r\n\r\nBecause of the autorepeat feature, more than one WM_KEYDOWN message may be posted before a WM_KEYUP message is posted. The previous key state (bit 30) can be used to determine whether the WM_KEYDOWN message indicates the first down transition or a repeated down transition. \r\n\r\nFor enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter. \r\n\r\nアプリは、wParamを改変することなく、TranslateMessageに渡さなければならない。', 'Virtual-Key Codes|DefWindowProc|WM_KEYUP|WM_CHAR', '2016-09-01 10:37:18', '2016-09-01 10:37:18', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646280.aspx', 'Katayama Hirofumi MZ', '', '', '', ''),
('WM_KEYUP', 'メッセージ', '非システムキーが離されたときに、キーボードフォーカスを持つウィンドウにポストされる。非システムキーは、Altキーが押されていないときに押されたキー、あるいはウィンドウがキーボードフォーカスを持っているときに押されたキーである。', 'WM_KEYUP', 'wParam --- 非システムキーの仮想キーコード。「仮想キーコード」を参照。\r\n///\r\nlParam --- 下記に示される、リピートカウント、スキャンコード、拡張キーフラグ、コンテキストコード、直前のキー状態フラグ、トランジション状態フラグ。\r\n\r\n[table:WM_KEYUP_Table1]', 'アプリはこのメッセージを処理したら、ゼロを返すべきだ。', 'DefWindowProc関数はもしF10キーまたはAltキーが離されていれば、WM_SYSCOMMANDメッセージをトップレベルのウィンドウに送信する。めこのメッセージのwParamパラメータは、SC_KEYMENUにセットされる。\r\n\r\nFor enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter. \r\n\r\nアプリは、wParamを改変することなくTranslateMessageに渡さなければならない。', 'Virtual-Key Codes|TranslateMessage|DefWindowProc|WM_KEYDOWN|WM_CHAR', '2016-09-01 10:47:10', '2016-09-01 10:47:10', '<winuser.h>', 'user32.dll', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms646281.aspx', 'Katayama Hirofumi MZ', '', '', '', '');

-- --------------------------------------------------------

--
-- テーブルの構造 `tables`
--

CREATE TABLE `tables` (
  `table_name` varchar(128) NOT NULL,
  `contents` varchar(16384) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- テーブルのデータのダンプ `tables`
--

INSERT INTO `tables` (`table_name`, `contents`) VALUES
('ABM_GETSTATE_Table1', '戻り値 --- 説明\r\n///\r\nABS_ALWAYSONTOP --- タスクバーはalways-on-top状態にある。\r\n\r\nWindows 7ではABS_ALWAYSONTOPはもはや返されない。なぜならタスクバーは常にその状態だからだ。古いコードはこの値の欠席を無視すべきであり、この戻り値がなければalways-on-top状態にないことを意味すると見なすべきではない。\r\n///\r\nABS_AUTOHIDE --- タスクバーはautohide状態にある。'),
('ABM_SETSTATE_Table1', '値 --- 意味\r\n///\r\n0 --- autohideでもalways-on-topでもない\r\n///\r\nABS_ALWAYSONTOP --- always-on-topであるがautohideではない\r\n///\r\nABS_AUTOHIDE --- autohideだが、always-on-topではない\r\n///\r\nABS_AUTOHIDE | ABS_ALWAYSONTOP --- autohideかつalways-on-topである'),
('ActivateKeyboardLayout_Table1', '値 --- 意味\r\n///\r\nHKL_NEXT --- システムにより管理されている、ロードされたロケール識別子の巡回リスト内で、次のロケール識別子を選択します。 \r\n///\r\nHKL_PREV --- システムにより管理されている、ロードされたロケール識別子の巡回リスト内で、前のロケール識別子を選択します。'),
('ActivateKeyboardLayout_Table2', '値 --- 意味\r\n///\r\nKLF_REORDER --- このビットがセットされている場合、与えられたロケール識別子をリストの先頭に移動して、システムが持つロードされたロケール識別子の巡回リストを並べ替えます。このビットがセットされていない場合、リストは順序が変更されることなく循環します。 たとえば、フランス語、ドイツ語、スペイン語のロケール識別子をこの順でロードした状態で、さらに英語のロケール識別子をアクティブ化している場合、KLF_REORDER ビットをセットしてドイツ語のロケール識別子をアクティブ化すると、順序はドイツ語、英語、フランス語、スペイン語の順になります。ドイツ語ロケール識別子を KLF_REORDER ビットをセットせずにアクティブ化すると、順序はドイツ語、スペイン語、英語、フランス語の順になります。\r\n\r\nロードされているロケール識別子の数が３未満の場合、このフラグは適切な値を取りません。\r\n///\r\nKLF_SETFORPROCESS --- Windows 2000：プロセス全体に対して指定されたロケール識別子をアクティブ化し、現在のスレッドのフォーカスまたはアクティブウィンドウに WM_INPUTLANGCHANGE メッセージを送信します。\r\n///\r\nKLF_UNLOADPREVIOUS --- このフラグはサポートされていません。代わりに UnloadKeyboardLayout 関数を使います。'),
('APPBARDATA_Table1', '値 --- 意味\r\n///\r\nABE_BOTTOM --- 下端。\r\n///\r\nABE_LEFT --- 左端。\r\n///\r\nABE_RIGHT --- 右端。\r\n///\r\nABE_TOP --- 上端。'),
('CANDIDATEFORM_Table1', '値 --- 意味\r\n///\r\nCFS_CANDIDATEPOS --- ptCurrentPosで与えられた左上端位置で候補ウィンドウを表示します。座標は、リストウィンドウを保持するウィンドウの左上端から相対的であり、システムによって補正されることがあります。\r\n///\r\nCFS_EXCLUDE --- rcAreaで与えられた領域から候補ウィンドウを除外します。ptCurrentPosメンバーは、キャレット位置などの関心のある現在位置の座標を指定します。'),
('CANDIDATELIST_Table1', '値 --- 意味\r\n///\r\nIME_CAND_UNKNOWN --- 候補たちはこのリストにないスタイルです。\r\n///\r\nIME_CAND_READ --- 候補たちは同じ読みです。\r\n///\r\nIME_CAND_CODE --- 候補たちはコード範囲です。\r\n///\r\nIME_CAND_MEANING --- 候補たちは同じ意味です。\r\n///\r\nIME_CAND_RADICAL --- 候補たちは同じ部首文字を使います。\r\n///\r\nIME_CAND_STROKES --- 候補たちは同じ総字画です。'),
('Composition String_Table1', '値 --- 意味\r\n///\r\nATTR_INPUT --- ユーザーにより文字が入力された。IMEはまだこの文字を変換していない。\r\n///\r\nATTR_INPUT_ERROR --- IMEが変換できないエラー文字。例えば、IMEは、子音を複数一緒に置けない。\r\n///\r\nATTR_TARGET_CONVERTED --- ユーザーによって選択され、IMEによって変換された文字。\r\n///\r\nATTR_CONVERTED --- IMEによって既に変換された文字。\r\n///\r\nATTR_TARGET_NOTCONVERTED --- 変換された文字。ユーザーはちょうど選択したが、まだ変換されていない。\r\n///\r\nATTR_FIXEDCONVERTED --- IMEがもはや変換しない文字。'),
('COMPOSITIONFORM_Table1', '値 --- 意味\r\n///\r\nCFS_DEFAULT --- 既定の位置へコンポジションウィンドウを移動します。IMEウィンドウは、フローティングウィンドウのように、クライアント領域の外側でコンポジションウィンドウを表示できます。\r\n///\r\nCFS_FORCE_POSITION --- ptCurrentPosで与えられた正確な位置でコンポジションウィンドウの左上端を表示します。座標は、コンポジションウィンドウを含むウィンドウの左上端から相対的であり、IMEによって補正されません。\r\n///\r\nCFS_POINT --- ptCurrentPosで与えられた位置でコンポジションウィンドウの左上端を表示します。座標は、コンポジションウィンドウを含むウィンドウの左上端から相対的であり、座標はIMEによって補正されます。\r\n///\r\nCFS_RECT --- rcAreaで与えられた位置でコンポジションウィンドウを表示します。座標は、コンポジションウィンドウを含むウィンドウの左上端から相対的です。'),
('COMPOSITIONSTRING_Table1', '値 --- 内容\r\n///\r\nATTR_INPUT --- 現在入力されている文字。\r\n///\r\nATTR_TARGET_CONVERTED --- 変換中ですでに変換済みの文字。\r\n///\r\nATTR_CONVERTED --- IME により変換された文字。\r\n///\r\nATTR_TARGET_NOTCONVERTED --- 変換中で選択されたがまだ変換済みではない文字。\r\n///\r\nATTR_FIXEDCONVERTED --- これ以上変換されない文字。\r\n///\r\nATTR_INPUT_ERROR --- エラー文字で変換できない。'),
('COMPOSITIONSTRING_Table2', '内容 --- 説明\r\n///\r\n現在入力されている文字。 --- ユーザが入力中の文字。日本語ならこの文字はまだ IME によって変換されていないひらがな、カタカナ、英数字になる。\r\n///\r\n変換中ですでに変換済みの文字。 --- ユーザによって選択され、IME によって選択された文字。\r\n///\r\nIME により変換された文字。 --- IME が変換した文字。\r\n///\r\n変換中で選択されたがまだ変換済みではない文字。 --- ユーザによって変換のために選択されていて、まだ IME によって変換されていない文字。日本語ならこの文字は、ユーザが入力したひらがな、カタカナ、英数字になる。\r\n///\r\nエラー文字で変換できない。 --- 文字がエラー文字で、IME がこの文字を変換できない。例えばいくつかの子音は連結できない。'),
('EM_GETIMESTATUS_Table1', '値 --- 意味\r\n///\r\nEMSIS_COMPOSITIONSTRING --- コンポジション文字列の処理に対する振る舞いをセットします。'),
('EM_GETIMESTATUS_Table2', '戻り値 --- 説明\r\n///\r\nEIMES_GETCOMPSTRATONCE --- もしこのフラグがセットされていたら、エディットコントロールは、fFlagsをGCS_RESULTSTR にセットしたWM_IME_COMPOSITION メッセージをフックし、結果文字列をすぐに返します。もしこのフラグがセットされていなければ、エディットコントロールは、WM_IME_COMPOSITIONメッセージを既定のウィンドウプロシージャーに渡し、WM_CHARメッセージから結果文字列を処理します。これはエディットコントロールの既定の動作です。\r\n///\r\nEIMES_CANCELCOMPSTRINFOCUS --- もしこのフラグがセットされていれば、エディットコントロールはWM_SETFOCUSメッセージを受け取ったとき、コンポジション文字列をキャンセルします。もしこのフラグがセットされていなければ、エディットコントロールはコンポジション文字列をキャンセルしません。これはエディットコントロールの既定の動作です。\r\n///\r\nEIMES_COMPLETECOMPSTRKILLFOCUS --- もしこのフラグがセットされていれば、エディットコントロールは、WM_KILLFOCUSメッセージを受け取ったとき、コンポジション文字列を確定します。もしこのフラグがセットされていなければ、コンポジション文字列を確定しません。これはエディットコントロールの既定の動作です。'),
('EM_SETIMESTATUS_Table1', '値 --- 意味\r\n///\r\nEMSIS_COMPOSITIONSTRING --- 操作するコンポジション文字列に対する振る舞いをセットします。'),
('EM_SETIMESTATUS_Table2', '値 --- 意味\r\n///\r\nEIMES_GETCOMPSTRATONCE --- もしこのフラグがセットされていたら、エディットコントロールは、lParamにGCS_RESULTSTR をセットしたWM_IME_COMPOSITIONメッセージをフックして、すぐに結果文字列を返します。もしこのフラグがセットされていなければ、エディットコントロールは、既定のウィンドウプロシージャーにWM_IME_COMPOSITION メッセージに渡し、WM_CHARメッセージからの結果文字列を処理します。これはエディットコントロールの既定の動作です。\r\n///\r\nEIMES_CANCELCOMPSTRINFOCUS --- もしこのフラグがセットされていれば、エディットコントロールは、WM_SETFOCUSを受け取ったときにコンポジション文字列をキャンセルします。もしこのフラグがセットされていなければ、エディットコントロールは、コンポジション文字列をキャンセルしません。これはエディットコントロールの既定の動作です。\r\n///\r\nEIMES_COMPLETECOMPSTRKILLFOCUS --- もしこのフラグがセットされていれば、エディットコントロールはWM_KILLFOCUSメッセージを受け取ったときにコンポジション文字列を確定します。もしこのフラグがセットされていなければ、コンポジション文字列を確定しません。これはエディットコントロールの既定の動作です。'),
('GUIDELINE_Table1', '値 --- 説明\r\n///\r\nGL_LEVEL_NOGUIDELINE --- 何もガイドラインがないことを意味し、UI は、古いガイドラインは非表示にするべきだ。\r\n///\r\nGL_LEVEL_FATAL --- 致命的なエラーが発生したことを意味する。\r\n///\r\nGL_LEVEL_ERROR --- 通常のエラーが発生したことを意味し、処理が止まるかもしれない。\r\n///\r\nGL_LEVEL_WARNING --- 警告が発生したことを意味し、処理は続行される。\r\n///\r\nGL_LEVEL_INFORMATION --- ユーザに対する情報を意味する。'),
('GUIDELINE_Table2', '値 --- 説明\r\n///\r\nGL_ID_UNKNOWN --- 未知のエラー。\r\n///\r\nGL_ID_NOMODULE --- IME が必要なモジュールが見つからなかったときに指定する。\r\n///\r\nGL_ID_NODICTIONARY --- 辞書が見つからないか、辞書がおかしいときに指定する。\r\n///\r\nGL_ID_CANNOTSAVE --- 辞書や統計情報が保存できないときに指定する。\r\n///\r\nGL_ID_NOCONVERT --- 少しも変換できないときに指定する。\r\n///\r\nGL_ID_TYPINGERROR --- IME が処理できないタイプエラーのとき指定する。\r\n///\r\nGL_ID_TOOMANYSTROKE --- 一文字や一つの文節に多すぎるキーストロークがあったときに指定する。\r\n///\r\nGL_ID_READINGCONFLICT --- 読みの衝突が発生したときに指定する。例えば、子音が連結できないときである。\r\n///\r\nGL_ID_INPUTREADING --- IME がユーザに読みの文字入力状態にあることを伝える。\r\n///\r\nGL_ID_INPUTRADICAL --- IME がユーザに部首文字入力状態にあることを伝える。\r\n///\r\nGL_ID_INPUTCODE --- ユーザに文字コード入力状態にあることを伝える。\r\n///\r\nGL_ID_CHOOSECANIDATE --- ユーザに、候補文字列を選択する状態であることを伝える。\r\n///\r\nGL_ID_REVERSECONVERSION --- 逆変換の情報をユーザーに伝える。逆変換は、ImmGetGuideLine(hIMC, GGL_PRIVATE, lpBuf, dwBufLen)を通じて取得できる。lpBuf の情報は、CANDIDATELIST 形式である。\r\n///\r\nGL_ID_PRIVATE_FIRST --- GL_ID_PRIVATE_FIRST と GL_ID_PRIVATE_LASTの間に位置する ID は、IME 用に予約済みである。IME はこれらの ID を自分自身の GUIDELINE 用に使うことができる。\r\n///\r\nGL_ID_PRIVATE_LAST --- GL_ID_PRIVATE_FIRST と GL_ID_PRIVATE_LASTの間に位置する ID は、IME 用に予約済みである。IME はこれらの ID を自分自身の GUIDELINE 用に使うことができる。'),
('IME Composition String Values_Table1', '値 --- 説明\r\n///\r\nGCS_COMPATTR --- コンポジション文字列の属性を取得または更新する。\r\n///\r\nGCS_COMPCLAUSE --- コンポジション文字列の文節情報を取得または更新する。\r\n///\r\nGCS_COMPREADATTR --- 現在のコンポジションの読み文字列の属性を取得または更新する。\r\n///\r\nGCS_COMPREADCLAUSE --- コンポジション文字列の読み文字列の文節情報を取得または更新する。\r\n///\r\nGCS_COMPREADSTR --- 現在のコンポジションの読み文字列を取得または更新する。\r\n///\r\nGCS_COMPSTR --- 現在のコンポジション文字列を取得または更新する。\r\n/// \r\nGCS_CURSORPOS --- コンポジション文字列における現在の位置を取得または更新する。\r\n///\r\nGCS_DELTASTART --- コンポジション文字列における変更点の開始位置を取得または更新する。\r\n///\r\nGCS_RESULTCLAUSE --- 結果文字列の文節情報を取得または更新する。\r\n///\r\nGCS_RESULTREADCLAUSE --- 読み文字列の文節情報を取得または更新する。\r\n///\r\nGCS_RESULTREADSTR --- 読み文字列を取得または更新する。\r\n///\r\nGCS_RESULTSTR --- コンポジション結果の文字列を取得または更新する。'),
('IME Conversion Mode Values_Table1', 'ビット --- 意味\r\n///\r\nIME_CMODE_ALPHANUMERIC --- 英数入力モード。これは既定であり、0x0000として定義されている。\r\n///\r\nIME_CMODE_CHARCODE --- 文字コード入力モードなら1であり、さもなければゼロである。\r\n///\r\nIME_CMODE_EUDC --- EUDC変換モードなら1であり、さもなければゼロである。\r\n///\r\nIME_CMODE_FIXED --- Windows Me/98, Windows 2000, Windows XP: 固定入力モードなら1であり、さもなければゼロである。\r\n///\r\nIME_CMODE_FULLSHAPE --- 全角モードなら1であり、半角モードならゼロである。\r\n///\r\nIME_CMODE_HANJACONVERT --- Hanja変換モードなら1であり、さもなければゼロである。\r\n///\r\nIME_CMODE_KATAKANA --- カタカナモードであれば1であり、さもなければゼロである。\r\n///\r\nIME_CMODE_NATIVE --- ネイティブモードであれば1であり、英数モードならゼロである。\r\n///\r\nIME_CMODE_NOCONVERSION --- IMEによる変換プロセスを妨害するには1をセットし、さもなければゼロをセットする。\r\n///\r\nIME_CMODE_ROMAN --- ローマ字入力モードなら1にセットし、さもなければゼロにセットする。\r\n///\r\nIME_CMODE_SOFTKBD --- ソフトキーボードモードなら1にセットし、さもなければゼロにセットする。\r\n///\r\nIME_CMODE_SYMBOL --- 記号変換モードなら1にセットし、さもなければゼロにセットする。'),
('IME File Format_Table1', '情報 --- 説明\r\n///\r\ndwFileOS --- dwFileOS は、VOS__WINDOWS32 であるべきだ。\r\n///\r\ndwFileType --- IME では、VFT_DRV を指定するべきだ。\r\n///\r\ndwFileSubtype --- IME では、VFT2_DRV_INPUTMETHOD を指定すべきだ。\r\n///\r\nFileDescription --- FileDescription は、言語固有のブロックに指定される。これは IME の名前とバージョンであるべきだ。この文字列は表示目的で使われる。長さは 32 個分の TCHAR である。\r\n///\r\nProductName --- 言語固有のブロックで指定される。文字通り製品名である。\r\n///\r\n文字セット ID と 言語 ID --- コードページ（文字セット ID; CharSet ID）と言語 ID (Language ID)の対である。複数のコードページが指定されると IME は最初の対を使用する。\r\n///\r\nファイル名 --- 8.3 形式でなければならない。'),
('IME Hot Key Identifiers_Table1', '識別子 --- 意味\r\n///\r\nIME_CHOTKEY_IME_NONIME_TOGGLE --- （簡体字）言語が簡体字のとき、IMEと非IME処理を切り替える。\r\n///\r\nIME_CHOTKEY_SHAPE_TOGGLE --- （簡体字）IMEのシェープ変換モードを切り替える。\r\n///\r\nIME_CHOTKEY_SYMBOL_TOGGLE --- （簡体字）IMEの記号変換モードを切り替える。記号モードは、キーボードの句読点と記号をマップすることによって、ユーザーが中国語の句読点と記号を入力できることを表す。\r\n///\r\nIME_ITHOTKEY_RECONVERTSTRING --- Windows Me/98, Windows 2000, Windows XP: （繁体字）再変換を引き起こす。\r\n///\r\nIME_JHOTKEY_CLOSE_OPEN --- （日本語）IMEを開いたり閉じたりする。\r\n///\r\nIME_KHOTKEY_ENGLISH --- （韓国語）英語に切り替える。\r\n///\r\nIME_KHOTKEY_SHAPE_TOGGLE --- （韓国語）IMEのシェープ変換モードを切り替える。\r\n///\r\nIME_KHOTKEY_HANJACONVERT --- （韓国語）Hanja変換に切り替える。\r\n///\r\nIME_THOTKEY_IME_NONIME_TOGGLE --- （繁体字）言語が繁体字のとき、IMEと非IME処理を切り替える。\r\n///\r\nIME_THOTKEY_SHAPE_TOGGLE --- （繁体字）IMEのシェープ変換モードを切り替える。\r\n///\r\nIME_THOTKEY_SYMBOL_TOGGLE --- （繁体字）IMEの記号変換モードを切り替える。'),
('IME Sentence Mode Values_Table1', '定数 --- 定義\r\n///\r\nIME_SMODE_AUTOMATIC --- IMEは自動モードで変換を実行する。\r\n///\r\nIME_SMODE_NONE --- センテンスに情報なし。\r\n///\r\nIME_SMODE_PHRASEPREDICT --- IMEは次の文字を予測するためにフレーズ情報を使う。\r\n///\r\nIME_SMODE_PLURALCLAUSE --- IMEは変換プロセスを実行するために、複数の文節情報を使う。\r\n///\r\nIME_SMODE_SINGLECONVERT --- IMEは1文字モードで変換プロセスを実行する。\r\n/// \r\nIME_SMODE_CONVERSATION --- IMEは対話モードを使う。これはチャットアプリで便利である。'),
('ImeConfigure_Table1', 'フラグ --- 説明\r\n///\r\nIME_CONFIG_GENERAL --- 汎用のダイアログ。\r\n///\r\nIME_CONFIG_REGWORD --- 単語登録のダイアログ。\r\n///\r\nIME_CONFIG_SELECTDICTIONARY --- IME 辞書選択のダイアログ。'),
('ImeConversionList_Table1', 'フラグ --- 説明\r\n///\r\nGCL_CONVERSION --- 引数 lpSrc に読みの文字列を指定する。IME は結果文字列を引数 lpDst に返す。\r\n///\r\nGCL_REVERSECONVERSION --- 結果文字列を引数 lpSrc に指定する。IME は読みの文字列を引数 lpDst に返す。\r\n///\r\nGCL_REVERSE_LENGTH --- 結果文字列を引数 lpSrc に指定する。IME は、GCL_REVERSECONVERSION で扱える長さを返す。例えば、IME は読みの文字列に句点の結果文字列を変換できない。結果としてそれは句点のない文字列の長さバイト数として返す。'),
('ImeEscape_Table1', 'uEscape --- 意味\r\n///\r\nIME_ESC_QUERY_SUPPORT --- 実装をチェックする。もしこのエスケープが実装されていなければ戻り\r\n値はゼロである。\r\n///\r\nIME_ESC_RESERVED_FIRST --- IME_ESC_RESERVED_FIRST と IME_ESC_RESERVED_LAST の\r\n間のエスケープはシステムによって予約済みである。\r\n///\r\nIME_ESC_RESERVED_LAST --- IME_ESC_RESERVED_FIRST と IME_ESC_RESERVED_LAST の\r\n間のエスケープはシステムによって予約済みである。\r\n///\r\nIME_ESC_PRIVATE_FIRST --- IME_ESC_PRIVATE_FIRST と IME_ESC_PRIVATE_LAST の間のエスケープは IME によって予約済みである。IME は IME 固有の目的でこれらのエスケープ機能を自由に使うことができる。\r\n///\r\nIME_ESC_PRIVATE_LAST --- IME_ESC_PRIVATE_FIRST と IME_ESC_PRIVATE_LAST の間のエスケープは IME によって予約済みである。IME は IME 固有の目的でこれらのエスケープ機能を自由に使うことができる。\r\n///\r\nIME_ESC_SEQUENCE_TO_INTERNAL --- 中国語特有のエスケープ。すべての極東のプラットフォームで実行したいアプリはこれを使うべきではない。これは中国語 EUDC エディタのためのものである。*(LPWORD)lpData はシーケンスコードで、戻り値はこのシーケンスコードに対する文字コードである。典型的に中国語 IME は読み文字コードを 1 から n までのシーケンスへエンコードする。\r\n///\r\nIME_ESC_GET_EUDC_DICTIONARY --- 中国語特有のエスケープ。すべての極東のプラットフォームで実行したいアプリはこれを使うべきではない。これは中国語 EUDC エディタのためのものである。この機能から戻るときに、(LPTSTR)lpData はEUDC 辞書のフルパスファイル名で埋められる。lpData によって指し示されるこのバッファのサイズは、MAX_PATH * sizeof(TCHAR)以上でなければならない。注意：Windows 95/98 と Windows NT 4.0 のEUDC エディタは、80*sizeof(TCHAR)までのバッファを使うことを想定している。\r\n///\r\nIME_ESC_SET_EUDC_DICTIONARY --- EUDC 辞書ファイルをセットする。入力時に、引数 lpData は、フルパスを指定するゼロ終端文字列のポインタである。中国語 EUDC エディタで使うときは、他のアプリで使うべきではない。\r\n///\r\nIME_ESC_MAX_KEY --- 中国語特有のエスケープ。すべての極東のプラットフォームで実行したいアプリはこれを使うべきではない。これは中国語 EUDC エディタのためのものである。戻り値は、EUDC 文字に対するキーストロークの最大個数である。\r\n///\r\nIME_ESC_IME_NAME --- 中国語特有のエスケープ。すべての極東のプラットフォームで実行したいアプリはこれを使うべきではない。これは中国語 EUDC エディタのためのものである。この機能から戻るとき、(LPTSTR)lpData は、EUDC エディタで表示される IME の名前である。lpData によって指し示されるこのバッファのサイズは、16 * sizeof(TCHAR)以上でなければならない。\r\n///\r\nIME_ESC_SYNC_HOTKEY --- 繁体字中国語特有のエスケープ。すべての極東のプラットフォームで実行したいアプリはこれを使うべきではない。これは、異なる IME の間の同期のためにある。入力引数*(LPDWORD)lpData は、IME のプライベートなホットキー ID である。もしこの ID がゼロなら、この IME は関連するすべてのプライベートなホットキーをチェックすべきある。\r\n///\r\nIME_ESC_HANJA_MODE --- 韓国語特有のエスケープ。すべての極東のプラットフォームで実行したいアプリはこれを使うべきではない。これは Hangeul から Hanja への変換のためにある。入力引数(LPSTR)lpData は、 Hangeul 文字列で埋められ、それは Hanja とゼロ終端文字列に変換されるだろう。コンポジション文字が存在するときで、アプリが Hangeul 文字を Hanja 変換と同じ方式で Hanja 文字に変換したいとき、アプリはこの機能をリクエストするだけでいい。その場合、IME 自体が Hanja 変換モードとして設定する。\r\n///\r\nIME_ESC_GETHELPFILENAME --- IME のヘルプファイルの名前のエスケープ。この機能から戻るとき、(LPTSTR)lpData は IME のヘルプファイルのフルパスファイル名である。パス名は、MAX_PATH * sizeof(TCHAR)未満でなければならない。これは Windows 98 と Windows 2000 に追加された。注意：Windows 98 はパスの長さが 80 個未満の TCHAR であることを想定している。\r\n///\r\nIME_ESC_PRIVATE_HOTKEY --- lpData は、IME_HOTKEY_PRIVATE_FIRST からIME_HOTKEY_PRIVATE_LAST までの範囲のホットキー ID を含むDWORD を指し示す。システムがこの範囲でホットキーリクエストを受け取った後、IMM は ImeEscape 関数を使って、それを IME に発送（dispatch）する。注意：Windows 95 はこのエスケープをサポートしない。'),
('ImeGetImeMenuItems_Table1', 'ビット --- 説明\r\n///\r\nIGIMIF_RIGHTMENU --- もしこのビットが 1 なら、この関数は、右クリックコンテキストメニューに対するメニュー項目たちを返す。'),
('ImeGetImeMenuItems_Table2', 'ビット --- 説明\r\n///\r\nIGIMII_CMODE --- 変換モードに関するメニュー項目たちを返す。\r\n///\r\nIGIMII_SMODE --- センテンスモードに関するメニュー項目たちを返す。\r\n///\r\nIGIMII_CONFIGURE --- IME の設定に関するメニュー項目たちを返す。\r\n///\r\nIGIMII_TOOLS --- IME ツールに関するメニュー項目たちを返す。\r\n///\r\nIGIMII_HELP --- IME ヘルプに関するメニュー項目たちを返す。\r\n///\r\nIGIMII_OTHER --- その他に関するメニュー項目たちを返す。\r\n///\r\nIGIMII_INPUTTOOLS --- 文字入力の拡張した方法を提供する IME の入力ツールに関するメニュー項目たちを返す。'),
('ImeInquire_Table1', 'フラグ --- 説明\r\n///\r\nIME_SYSINFO_WINLOGON --- クライアントプロセスが、Winlogon プロセスであることを IME に伝える。IME は、このフラグが指定されたときに、IME はユーザに IMEの設定の変更を許可すべきではない。\r\n///\r\nIME_SYSINFO_WOW16 --- クライアントプロセスが、16 ビットアプリであることを IME に伝える。'),
('IMEMENUITEMINFOA_Table1', '値 --- 意味\r\n///\r\nIMFT_RADIOCHECK --- hbmCheckedメンバーがNULLなら、チェックマークの代わりにラジオボタンマークを使ってチェックされたメニュー項目を表示します。\r\nIMFT_SEPARATOR --- メニュー項目が区分線であることを指定します。メニュー項目区分線は水平に分割する線として表示されます。この場合、hbmpItemとszStringメンバーは無視されます。\r\nIMFT_SUBMENU --- このメニュー項目がサブメニューであることを指定します。'),
('IMEMENUITEMINFOA_Table2', '値 --- 意味\r\n///\r\nIMFS_CHECKED --- メニュー項目はチェックされます。\r\n///\r\nIMFS_DEFAULT --- メニュー項目は既定です。1個のメニューは太字で表示される1個の既定のメニュー項目を持つことができます。\r\n///\r\nIMFS_DISABLED --- メニュー項目は無効ですが、影が付きません。それでもまだ選択できます。\r\n///\r\nIMFS_ENABLED --- メニュー項目は有効です。これは既定の状態です。\r\n///\r\nIMFS_GRAYED --- メニュー項目は無効であり、影が付くので、選択できません。\r\n///  \r\nIMFS_HILITE --- メニュー項目はハイライトされています。\r\n///\r\nIMFS_UNCHECKED --- メニュー項目はチェックされていません。\r\n///\r\nIMFS_UNHILITE --- メニュー項目はハイライトされていません。'),
('IMEMENUITEMINFOW_Table1', '値 --- 意味\r\n///\r\nIMFT_RADIOCHECK --- もしhbmCheckedメンバーがNULLなら、チェックマークの代わりにラジオボタンマークを使ってチェックのついたメニュー項目を表示します。\r\n///\r\nIMFT_SEPARATOR --- メニュー項目が区分線であることを指定します。メニュー項目区分線は、水平に分割する線として表示されます。hbmpItemとszString メンバーはこの場合、無視されます。\r\n///\r\nIMFT_SUBMENU --- メニュー項目がサブメニューであることを指定します。'),
('IMEMENUITEMINFOW_Table2', '値 --- 意味\r\n///\r\nIMFS_CHECKED --- メニュー項目はチェックが付きます。\r\n///\r\nIMFS_DEFAULT --- メニュー項目は既定です。1個のメニューは太字で表示される1個の既定のメニュー項目を持ちます。\r\n///  \r\nIMFS_DISABLED --- メニュー項目は無効ですが、影が付きません。まだ選択できます。\r\n///\r\nIMFS_ENABLED --- メニュー項目は有効です。これは既定の状態です。\r\n/// \r\nIMFS_GRAYED --- メニュー項目は無効で影が付くので選択できません。\r\n///\r\nIMFS_HILITE --- メニュー項目はハイライトされています。\r\n///\r\nIMFS_UNCHECKED --- メニュー項目はチェックが付いていません。\r\n///\r\nIMFS_UNHILITE --- メニュー項目はハイライトされていません。'),
('ImeRegisterWord_Table1', '値 --- 説明\r\n///\r\nIME_REGWORD_STYLE_EUDC --- 文字列は EUDC の範囲内である。\r\n///\r\nIME_REGWORD_STYLE_USER_FIRSTからIME_REGWORD_STYLE_USER_LAST まで --- IME_REGWORD_STYLE_USER_FIRST からIME_REGWORD_STYLE_USER_LAST までの範囲の定数は、IME ISV のプライベートなスタイルとして使われる。 IME ISV は自由に固有のスタイルを定義できる。例えば：\r\n\r\n<pre>#define MSIME_NOUN \\　\r\n    (IME_REGWORD_STYLE_USER_FIRST)\r\n#define MSIME_VERB \\\r\n    (IME_REGWORD_STYLE_USER_FIRST + 1)</pre>'),
('ImeSetCompositionString_Table1', '値 --- 説明\r\n///\r\nSCS_SETSTR --- アプリは、コンポジション文字列、読みの文字列、またはそれらの両方をセットする。少なくとも lpComp と lpRead引数 の一つは、有効な文字列を指し示さなければならない。もしどちらかの文字列が長すぎれば、IME は切り捨てる。\r\n///\r\nSCS_CHANGEATTR --- アプリは、コンポジション文字列、読みの文字列、またはそれらの両方の属性をセットする。少なくとも lpComp とlpRead 引数の一つは、有効な属性配列を指し示さねばならない。\r\n///\r\nSCS_CHANGECLAUSE --- アプリは、コンポジション文字列、読みの文字列、またはそれらの両方の文節情報をセットする。少なくとも lpCompと lpRead 引数の一つは、有効な文節情報配列を指し示さねばならない。\r\n///\r\nSCS_QUERYRECONVERTSTRING --- アプリは IME に RECONVERTSTRING 構造体を調節することを問い合わせる。もしアプリがこの値つきでImeSetCompositionString 関数を呼び出したら、IME は、RECONVERTSTRING 構造体を調節する。そのときアプリは、調節した RECONVERTSTRING 構造体を\r\nSCS_RECONVERTSTRING つきでこの関数に渡すことができる。IME は WM_IMECOMPOSITION メッセージを生成しないだろう。\r\n///\r\nSCS_SETRECONVERTSTRING --- アプリは IME に RECONVERTSTRING 構造体に含まれている文字列を再変換するか問い合わせる。'),
('ImeToAsciiEx_Table', 'ビット --- 内容\r\n///\r\nビット 0 – 7 --- VK_PACKET\r\n///\r\nビット 8 – 15 --- Leading byte\r\n///\r\nビット 16 – 23 --- Trailing DBCS byte （もしあれば）\r\n///\r\nビット 24 – 31 --- 予約済み'),
('ImeToAsciiEx_Table1', 'ビット --- 内容\r\n///\r\nビット 0 – 7 --- VK_PACKET\r\n///\r\nビット 8 – 15 --- Leading byte \r\n///\r\nビット 16 – 23 ---  Trailing DBCS byte （もしあれば） \r\n///\r\nビット 24 – 31 --- 予約済み'),
('ImmAssociateContextEx_Table1', '値 --- 意味\r\n/// \r\nIACE_CHILDREN --- 入力コンテキストを hWnd パラメータで指定されたウィンドウの子ウィンドウにのみ関連付けます。 \r\n///\r\nIACE_DEFAULT --- ウィンドウの既定の入力コンテキストを復元します。\r\n///  \r\nIACE_IGNORENOCONTEXT --- 入力コンテキストが関連付けられていなかったウィンドウには入力コンテキストを関連付けません｡'),
('ImmConfigureIME_Table1', '値 --- 意味\r\n/// \r\nIME_CONFIG_GENERAL --- プロパティダイアログボックスを表示します。 \r\n///\r\nIME_CONFIG_REGISTERWORD --- 単語登録用のダイアログボックス（日本語 IME の場合、［単語/用例の登録］）を表示します。 \r\n///\r\nIME_CONFIG_SELECTDICTIONARY --- 辞書選択用のダイアログボックス（日本語 IME の場合、［ユーザー辞書の設定］）を表示します。'),
('ImmCreateSoftKeyboard_Table1', 'uType --- 説明\r\n///\r\nSOFTKEYBOARD_TYPE_T1 --- タイプ T1 ソフトキーボード。この種類のソフトキーボードは、IMC_SETSOFTKBDDATA によって更新されるべきだ。\r\n///\r\nSOFTKEYBOARD_TYPE_C1 --- タイプ C1 ソフトキーボード。この種類のソフトキーボードは 2 セットの 256ワード配列データつきの\r\nIMC_SETSOFTKBDDATA によって更新されるべきだ。最初のセットは非\r\nシフト状態、二番目はシフト状態である。'),
('ImmEnumInputContext_Table1', '値 --- 意味\r\n/// \r\n0 --- 現在のスレッド。 \r\n///\r\n–1 --- 現在のプロセス。 \r\n///\r\nスレッド ID --- 入力コンテキストを列挙するスレッドの ID。他のプロセスに属するスレッドのスレッド ID も指定できます。'),
('ImmGetCompositionString_Table1', '値 --- 意味\r\n/// \r\nIMM_ERROR_NODATA --- 指定した入力コンテキストではまだ変換データが準備できていません。 \r\n///\r\nIMM_ERROR_GENERAL --- IME により一般エラーが検出されました。'),
('ImmGetConversionList_Table1', '値 --- 意味\r\n/// \r\nGCL_CONVERSION --- ソース文字列は、読み文字列です。このソース文字列を変換して得られた変換結果が指定したバッファにコピーされます。 \r\n///\r\nGCL_REVERSECONVERSION --- ソース文字列は、変換結果です。ソース文字列を逆変換して得られた読み文字列が指定したバッファにコピーされます。 \r\n///\r\nGCL_REVERSE_LENGTH --- ソース文字列は、変換結果です。GCL_REVERSECONVERSION を指定した場合に生成される読み文字列のバイト単位での長さが関数から返ります。'),
('ImmGetGuideLine_Table1', '値 --- 意味\r\n/// \r\nGGL_LEVEL --- エラーレベルを取得します。 \r\n///\r\nGGL_INDEX --- エラーインデックスを取得します。 \r\n///\r\nGGL_STRING --- エラーメッセージの文字列を取得します。 \r\n///\r\nGGL_PRIVATE --- 逆変換に関する情報を取得します。'),
('ImmGetGuideLine_Table2', '値 --- 意味\r\n///\r\nGL_LEVEL_ERROR --- エラーが発生しました。IME は処理を続行できません。 \r\n///\r\nGL_LEVEL_FATAL --- 致命的なエラーが発生しました。IME は処理を続行できません。データは失われます。 \r\n///\r\nGL_LEVEL_INFORMATION --- エラーはありませんが、ユーザーへの情報は取得可能です。 \r\n///\r\nGL_LEVEL_NOGUIDELINE --- エラーはありません。1 つ前のエラーメッセージをまだ表示している場合は、表示を消してください。 \r\n///\r\nGL_LEVEL_WARNING --- 予期しない入力またはその他の結果が発生しました。ユーザーに対して警告メッセージを表示しなければなりませんが、IME の処理は続行可能です。'),
('ImmGetGuideLine_Table3', '値 --- 意味 \r\n///\r\nGL_ID_CANNOTSAVE --- 辞書または統計データを保存できません。 \r\n///\r\nGL_ID_NOCONVERT --- IME はこれ以上変換できません。 \r\n///\r\nGL_ID_NODICTIONARY --- IME は辞書を見つけられません。または、辞書が予期しない形式になっています。 \r\n///\r\nGL_ID_NOMODULE --- IME は必要なモジュールを見つけられません。 \r\n///\r\nGL_ID_READINGCONFLICT --- 読みに矛盾があります。たとえば、組み合わせられない母音が入っているなど。 \r\n/// \r\nGL_ID_TOOMANYSTROKE --- 1 つの文字または文節に入力されたキーストロークが多すぎます。 \r\n///\r\nGL_ID_TYPINGERROR --- 入力エラーです。このような入力は、IME では処理できません。 \r\n///\r\nGL_ID_UNKNOWN --- 未知のエラーです。エラーメッセージ文字列を取得してください。 \r\n///\r\nGL_ID_INPUTREADING --- IME は読みの入力を受け付けます。 \r\n///\r\nGL_ID_INPUTRADICAL --- IME は部首の入力を受け付けます。 \r\n///\r\nGL_ID_INPUTCODE --- IME は文字コードの入力を受け付けます。 \r\n///\r\nGL_ID_CHOOSECANDIDATE --- IME は変換候補の選択を受け付けます。 \r\n/// \r\nGL_ID_REVERSECONVERSION --- 逆変換に関する情報が取得可能です。'),
('ImmGetImeMenuItems_Table1', '値 --- 意味\r\n///\r\nIGIMIF_RIGHTMENU --- このフラグをセットすると、ショートカットメニュー（ マウスの右ボタンをクリックしたときに表示されるメニュー）のメニュー項目が返ります。'),
('ImmGetImeMenuItems_Table2', '値 --- 意味 \r\n///\r\nIGIMII_CMODE --- 入力モードを制御するメニュー項目を取得します。\r\n/// \r\nIGIMII_SMODE --- 変換モードを制御するメニュー項目を取得します。\r\n/// \r\nIGIMII_CONFIGURE --- 各種設定に関連するメニュー項目を取得します。 \r\n///\r\nIGIMII_TOOLS --- ツールに関連するメニュー項目を取得します。 \r\n///\r\nIGIMII_HELP --- ヘルプを制御するメニュー項目を取得します。 \r\n///\r\nIGIMII_OTHER --- その他の IME 機能を制御するメニュー項目を取得します。 \r\n///\r\nIGIMII_INPUTTOOLS --- 入力ツールを制御するメニュー項目を取得します。'),
('ImmGetProperty_Table1', '値 --- 取得する情報 \r\n///\r\nIGP_PROPERTY --- プロパティ情報\r\n/// \r\nIGP_CONVERSION --- 変換関連の機能\r\n/// \r\nIGP_SENTENCE --- 変換モードの機能\r\n/// \r\nIGP_UI --- ユーザーインターフェイス関連の機能 \r\n///\r\nIGP_SETCOMPSTR --- 変換文字列関連の機能 \r\n///\r\nIGP_SELECT --- 選択継承機能\r\n///\r\nIGP_GETIMEVERSION --- 指定した IME に対応するシステムバージョン番号'),
('ImmGetProperty_Table2', '値 --- 意味\r\n/// \r\nIME_PROP_AT_CARET --- この値がセットされている場合、変換ウィンドウがキャレットの位置にあります。クリアされている場合は、キャレットの近くにあります。 \r\n///\r\nIME_PROP_SPECIAL_UI --- この値がセットされている場合、IME には非標準のインターフェイスがあります。アプリケーションから IME ウィンドウ内に描画を行うことはしないでください。 \r\n///\r\nIME_PROP_CANDLIST_START_FROM_1 --- この値がセットされている場合、候補一覧に示されている文字列の番号は 1 から始まります。クリアされている場合は、0 から始まります。 \r\n///\r\nIME_PROP_UNICODE --- この値がセットされている場合、IME は Unicode IME として表示され、IME とシステムは Unicode IME インターフェイスを介して通信します。クリアされている場合、IME は ANSI インターフェイスを使ってシステムと通信します。 \r\n///\r\nIME_PROP_COMPLETE_ON_UNSELECT --- この値がセットされている場合、IME がアクティブでなくなったときに、変換文字列が確定されます。クリアされている場合、IME がアクティブでなくなったときに（ キーボードレイアウトの変更などにより）、変換文字列は取り消されます。 \r\n///\r\nIME_PROP_ACCEPT_WIDE_VKEY --- Windows 2000：この値がセットされている場合、IME は VK_PACKET を使って 関数から送られて来た Unicode（ インジェクトされた Unicode）を処理します。クリアされている場合、IME はインジェクトされた Unicode を処理できず、そのため、インジェクトされた Unicode は直接アプリケーションへ送られる可能性があります。'),
('ImmGetProperty_Table3', '値 --- 意味 \r\n///\r\nUI_CAP_2700 --- 0 または 2700 のテキストエスケープメント値（10 分の 1 度単位の文字送りの方向）をサポートします。\r\n/// \r\nUI_CAP_ROT90 --- 0、900、1800、2700 のテキストエスケープメント値をサポートします。\r\n/// \r\nUI_CAP_ROTANY --- 任意のテキストエスケープメント値をサポートします。'),
('ImmGetProperty_Table4', '値 --- 意味\r\n///\r\nSCS_CAP_COMPSTR --- ImmSetCompositionString 関数を SCS_SETSTR 値を指定して呼び出すことにより、変換文字列を生成できます。 \r\n///\r\nSCS_CAP_MAKEREAD --- ImmSetCompositionString 関数を SCS_SETSTR を指定して呼び出した場合に、対応する変換文字列から読み文字列を生成することができます。 \r\n///\r\nSCS_CAP_SETRECONVERTSTRING --- この IME は逆変換をサポートしています。逆変換を行うには、IMMSetCompositionString 関数を使います。'),
('ImmGetProperty_Table5', '値 --- 意味\r\n/// \r\nSELECT_CAP_CONVMODE --- 新しい IME が選択されたときに、入力モードを継承します。 \r\n///\r\nSELECT_CAP_SENTENCE --- 新しい IME が選択されたときに、変換モードを継承します。'),
('ImmGetProperty_Table6', '値 --- 意味\r\n/// \r\nIMEVER_0310 --- Windows 3.1 用に作成された IME です。 \r\n///\r\nIMEVER_0400 --- Windows 95 用に作成された IME です。'),
('ImmNotifyIME_Table1', '値 --- 意味\r\n/// \r\nNI_CHANGECANDIDATELIST --- 選択されている候補一覧を変更します。dwIndex パラメータには、選択する候補一覧のインデックスを指定し、dwValue パラメータには何も指定しません。\r\n/// \r\nNI_CLOSECANDIDATE --- IME に、候補一覧を閉じるように指示します。dwIndex パラメータには、閉じる一覧のインデックスを指定し、dwValue パラメータには何も指定しません。IME は、一覧を閉じたらアプリケーションに メッセージを送信します。\r\n/// \r\nNI_COMPOSITIONSTR --- IME に、変換文字列に対する処理を実行するように指示します。dwValue パラメータには何も指定しません。DwIndex パラメータには、CPS_CANCEL、CPS_COMPLETE、CPS_CONVERT、CPS_REVERT のいずれかを指定します。 \r\n///\r\nNI_IMEMENUSELECTED --- IME に、指定したメニューを処理することをアプリケーションに許可するよう指示します。dwIndex パラメータにはメニューの ID を指定し、dwValue パラメータにはそのメニュー項目用のアプリケーション定義の値を指定します。 \r\n///\r\nNI_OPENCANDIDATE --- IME に、候補一覧を開くように指示します。dwIndex パラメータには、開く一覧のインデックスを指定します。DwValue パラメータには、何も指定しません。IME は、一覧を開いたらアプリケーションに メッセージを送信します。 \r\n///\r\nNI_SELECTCANDIDATESTR --- 変換候補の 1 つを選択します。dwIndex パラメータには、対象とする候補一覧のインデックスを指定します。dwValue パラメータには、その候補一覧での候補文字列のインデックスを指定します。 \r\n///\r\nNI_SETCANDIDATE_PAGESIZE --- dwIndex パラメータには、変更する候補一覧を指定します。0～3 の範囲内の値を指定しなければなりません。 \r\n///\r\nNI_SETCANDIDATE_PAGESTART --- dwIndex パラメータには、変更する候補一覧を指定します。0～3 の範囲内の値を指定しなければなりません。'),
('ImmNotifyIME_Table2', '値 --- 意味\r\n///\r\nCPS_CANCEL --- 変換文字列を消去し、状態を変換文字列なしに設定します。 \r\n///\r\nCPS_COMPLETE --- 現在の変換文字列を変換結果として確定します。 \r\n///\r\nCPS_CONVERT --- 変換文字列を変換します。 \r\n///\r\nCPS_REVERT --- 現在の変換文字列を取り消し、未変換文字列に戻します。'),
('ImmSetCompositionString_Table1', '値 --- 意味\r\n///\r\nSCS_SETSTR --- 変換文字列か読み文字列のいずれか、またはその両方を設定します。この値を指定する場合は、パラメータ lpComp と lpRead の少なくともどちらか一方に有効な文字列へのポインタを指定しなければなりません。これらのパラメータに指定した文字列が長すぎた場合は、長すぎる部分が IME によって切り捨てられます。 \r\n///\r\nSCS_CHANGEATTR  --- 変換文字列か読み文字列のいずれか、またはその両方の属性を設定します。この値を指定する場合は、パラメータ lpComp と lpRead の少なくともどちらか一方に有効な属性配列へのポインタを指定しなければなりません。 \r\n///\r\nSCS_CHANGECLAUSE  --- 変換文字列か読み文字列のいずれか、またはその両方の文節情報を設定します。この値を指定する場合は、パラメータ lpComp と lpRead の少なくともどちらか一方に有効な文節情報配列へのポインタを指定しなければなりません。 \r\n///\r\nSCS_SETRECONVERTSTRING  --- Windows 98 および Windows 2000：IME に 構造体に格納された文字列を逆変換するよう指示します。 \r\n///\r\nSCS_QUERYRECONVERTSTRING  --- Windows 98 および Windows 2000：IME に RECONVERTSTRING 構造体を調整するよう指示します。前もってこれを行えば、SCS_SETRECONVERTSTRING を指定してこの関数を呼び出し、調整済みの RECONVERTSTRING 構造体を渡すことができるようになります。この値を指定した場合、IME は WM_IME_COMPOSITION メッセージを生成しません。'),
('ImmShowSoftKeyboard_Table1', 'nCmdShow --- 意味\r\n///\r\nSW_HIDE --- ソフトキーボードを隠す。\r\n///\r\nSW_SHOWNOACTIVATE --- ソフトキーボードを表示する。'),
('INDICM_REMOVEDEFAULTMENUITEMS_Table1', '値 --- 説明\r\n///\r\nRDMI_LEFT --- 左クリックメニューのメニュー項目たちを除去する。\r\n///\r\nRDMI_RIGHT --- 右クリックメニューのメニュー項目たちを除去する。'),
('INPUTCONTEXT_Table1', 'メンバー名 --- 説明\r\n///\r\nA --- ANSI用のLOGFONTA。\r\n///\r\nW --- Unicode用のLOGFONTW。'),
('Keystroke Message Flags_Table1', '値 --- 説明\r\n///\r\nKF_ALTDOWN --- ATLキーが押されたかを表す、ALTキーフラグを操作する。\r\n///\r\nKF_DLGMODE --- ダイアログがアクティブかどうかを表す、ダイアログモードフラグを操作する。\r\n///\r\nKF_EXTENDED --- 拡張キーフラグを操作する。\r\n///\r\nKF_MENUMODE --- メニューがアクティブかどうかを表すメニューモードフラグを操作する。\r\n///\r\nKF_REPEAT --- リピートカウントを操作する。\r\n///\r\nKF_UP --- トランジション状態フラグを操作する。'),
('LoadKeyboardLayout_Table1', '値 --- 意味\r\n///\r\nKLF_ACTIVATE --- 指定された入力ロケール識別子がまだロードされていない場合、関数は現在のスレッドのために入力ロケール識別子をロードしてアクティブ化します。\r\n///\r\nKLF_NOTELLSHELL --- 新しい入力ロケール識別子のロード時に、ShellProc フックプロシージャが HSHELL_LANGUAGE フックコードを受け取らないようにします。この値は通常、アプリケーションが複数の入力ロケール識別子を順次にロードするときに使われます。最後以外のすべての入力ロケール識別子にこの値を適用すると、すべての入力ロケール識別子が追加されるまでシェルの処理を遅らせます。\r\n///\r\nKLF_REORDER --- 指定された入力ロケール識別子を現在のスレッドのためのアクティブなロケール識別子にし、入力ロケール識別子リストの先頭に移動します。この値が指定されている場合、入力ロケール識別子リストは KLF_ACTIVATE が与えられなくても並べ替えられます。\r\n///\r\nKLF_REPLACELANG --- Windows 95/98、Windows NT 4.0 および Windows 2000：新しい入力ロケール識別子と現在の入力ロケール識別子で言語識別子が同じ場合、新しい入力ロケール識別子は現在の入力ロケール識別子をその言語の入力ロケール識別子と置き換えます。入力ロケール識別子の言語識別子が同じで、この値が与えられていない場合、現在の入力ロケール識別子は置き換えられず、関数は NULL を返します。\r\n///\r\nKLF_SUBSTITUTE_OK --- 指定された入力ロケール識別子を、ユーザーが指定する別のロケールで代替します。システムはこのフラグをセットして起動するため、アプリケーションは常にこのフラグを使うことが推奨されます。レジストリキー HKEY_CURRENT_USER\\Keyboard Layout\\Substitutes は、代替ロケールを明示的に定義します。たとえば、キーに含まれている値の名前が \"00000409\" であり、その値が \"00010409\" の場合、米語レイアウト（\"00000409\"）をロードすると、その代わりに Dvorak 米語レイアウト（\"00010409\"）がロードされます。システムはブート中に KLF_SUBSTITUTE_OK フラグを使うため、入力ロケール識別子のロード時は、ユーザー設定が選択できるように、アプリケーションがこの値を使うことが推奨されます。\r\n///\r\nKLF_SETFORPROCESS --- Windows 2000：このフラグは KLF_ACTIVATE フラグと一緒の場合にだけ有効になります。指定された入力ロケール識別子をプロセス全体に対してアクティブ化し、現在のスレッドのフォーカスまたはアクティブウィンドウに WM_INPUTLANGCHANGE メッセージを送信します。通常、LoadKeyboardLayout 関数は現在のスレッドに対してだけ入力ロケール識別子をアクティブ化します。\r\n///\r\nKLF_UNLOADPREVIOUS --- このフラグはサポートされていません。代わりに、UnloadKeyboardLayout 関数を使います。'),
('MAKELANGID_Table1', '主言語識別子 --- サブ言語識別子 --- 意味\r\n///\r\nLANG_NEUTRAL --- SUBLANG_NEUTRAL --- ニュートラルな言語\r\n///\r\nLANG_NEUTRAL --- SUBLANG_DEFAULT --- ユーザーの既定の言語\r\n///\r\nLANG_NEUTRAL --- SUBLANG_SYS_DEFAULT --- システムの既定の言語\r\n///\r\nLANG_NEUTRAL --- SUBLANG_CUSTOM_DEFAULT --- Windows Vistaとそれ以降：既定のカスタムロケール\r\n///\r\nLANG_NEUTRAL --- SUBLANG_CUSTOM_UNSPECIFIED --- Windows Vistaとそれ以降：未指定のカスタムロケール\r\n///\r\nLANG_NEUTRAL --- SUBLANG_UI_CUSTOM_DEFAULT --- Windows Vistaとそれ以降：既定のカスタム多言語UIロケール'),
('NI_COMPOSITIONSTR_Table1', '値 --- 意味\r\n///\r\nCPS_COMPLETE --- 結果文字列としてコンポジション文字列を決めるために。\r\n///\r\nCPS_CONVERT --- コンポジション文字列を変換するために。\r\n///\r\nCPS_REVERT --- コンポジション文字列を元に戻すために。現在のコンポジション文字列はキャンセルされ、変換が解除された文字列がコンポジション文字列としてセットされる。\r\n///\r\nCPS_CANCEL --- コンポジション文字列をクリアし、コンポジション文字列がない状態をセットするために。'),
('OemKeyScan_Table1', 'ビット値 --- 意味\r\n///\r\n1 --- どちらかの Shift キーが押されています。\r\n///\r\n2 --- どちらかの Ctrl キーが押されています。\r\n///\r\n4 --- どちらかの Alt キーが押されています。\r\n///\r\n8 --- Hankaku キーが押されています。\r\n///\r\n16 --- 予約済み（ キーボードレイアウトドライバによって定義されます）。\r\n///\r\n32 --- 予約済み（ キーボードレイアウトドライバによって定義されます）。'),
('PeekMessage_Table1', '値 --- 意味\r\n///\r\nPM_NOREMOVE --- PeekMessage 関数がメッセージを処理した後、そのメッセージをキューから削除しません。\r\n///\r\nPM_REMOVE --- PeekMessage 関数がメッセージを処理した後、そのメッセージをキューから削除します。'),
('PeekMessage_Table2', '値 --- 意味\r\n/// \r\nPM_QS_INPUT --- Windows 98 と Windows 2000：マウスメッセージとキーボードメッセージを処理します。\r\n/// \r\nPM_QS_PAINT --- Windows 98 と Windows 2000：ペイントメッセージを処理します。\r\n///\r\nPM_QS_POSTMESSAGE --- Windows 98 と Windows 2000：タイマとホットキーを含め、すべてのポスト済みメッセージを処理します。\r\n/// \r\nPM_QS_SENDMESSAGE --- Windows 98 と Windows 2000：すべての送信済みメッセージを処理します。'),
('PostMessage_Table1', '値 --- 意味 \r\n///\r\nHWND_BROADCAST --- システム内のすべてのトップレベルウィンドウへメッセージをポストします。無効になっている所有されていないウィンドウ、不可視の所有されていないウィンドウ、オーバーラップされた（手前にほかのウィンドウがあって覆い隠されている）ウィンドウ、ポップアップウィンドウもポスト先になります。子ウィンドウへはメッセージをポストしません。 \r\n///\r\nNULL --- PostMessage 関数は、dwThreadId パラメータで現在のスレッドの識別子を指定して PostThreadMessage 関数を呼び出した場合と同じ動作をします。'),
('RegisterHotKey_Table1', '値 --- 意味\r\n///\r\nMOD_ALT --- どちらかの Alt キーを押します。\r\n///\r\nMOD_CONTROL --- どちらかの Ctrl キーを押します。\r\n///\r\nMOD_SHIFT --- どちらかの Shift キーを押します。\r\n///\r\nMOD_WIN --- どちらかの Windows キー（Microsoft Windows のロゴが付いているキー）を押します。'),
('SendMessageTimeout_Table1', '値 --- 意味\r\n/// \r\nSMTO_ABORTIFHUNG --- 受信側プロセスがハングアップ状態であると判断した場合、タイムアウト期間の経過を待たずに制御を返します。 \r\n///\r\nSMTO_BLOCK --- この関数が制御を返すまでは、呼び出し側スレッドがほかのすべての要求を処理することをブロックします（待機させます）。 \r\n///\r\nSMTO_NORMAL --- 呼び出し側スレッドは、この関数が制御を返すのを待っている間に、ほかの要求を処理できます。 \r\n///\r\nSMTO_NOTIMEOUTIFNOTHUNG --- Windows 2000：受信側スレッドがハングアップしていない場合、タイムアウト期間が経過しても制御を返しません。'),
('System-Defined Messages_Table1', '接頭辞 --- カテゴリー\r\n///\r\nABMとABN --- アプリ デスクトップ ツールバー\r\n///\r\nACMとACN --- アニメーション コントロール\r\n///\r\nBCM, BCN, BM, そしてBN --- ボタン コントロール\r\n///\r\nCBとCBN --- コンボボックス コントロール\r\n///\r\nCBEMとCBEN --- 拡張コンボボックス コントロール\r\n///\r\nCCM --- 一般のコントロール\r\n///\r\nCDM --- コモン ダイアログボックス\r\n///\r\nDFM --- 既定のコンテキストメニュー\r\n///\r\nDL --- ドラッグリストボックス\r\n///\r\nDM --- 既定のプッシュボタンコントロール\r\n///\r\nDTMとDTN --- 日付と時間の選択コントロール\r\n///\r\nEMとEN --- エディットコントロール\r\n///\r\nHDMとHDN --- ヘッダーコントロール\r\n///\r\nHKM --- ホットキーコントロール\r\n///\r\nIPMとIPN --- IPアドレスコントロール\r\n///\r\nLBとLBN --- リストボックスコントロール\r\n///\r\nLM --- システムリンクコントロール\r\n///\r\nLVMとLVN --- リストビューコントロール\r\n///\r\nMCMとMCN --- 月ごとのカレンダーコントロール\r\n///\r\nPBM --- プログレスバー\r\n///\r\nPGMとPGN --- ページャーコントロール\r\n///\r\nPSMとPSN --- プロパティシート\r\n///\r\nRBとRBN --- Rebarコントロール\r\n///\r\nSBとSBN --- ステータスバーウィンドウ\r\n/// \r\nSBM --- スクロールバーコントロール\r\n///\r\nSMC --- シェルメニュー\r\n///\r\nSTMとSTN --- スタティックコントロール\r\n///\r\nTBとTBN --- ツールバー\r\n///\r\nTBMとTRBN --- トラックバーコントロール\r\n///\r\nTCMとTCN --- タブコントロール\r\n///\r\nTDMとTDN --- タスクダイアログ\r\n///\r\nTTMとTTN --- ツールチップコントロール\r\n///\r\nTVMとTVN --- ツリービューコントロール\r\n///\r\nUDMとUDN --- アップダウンコントロール\r\n///\r\nWM --- 一般'),
('ToAscii_Table1', '値 --- 意味\r\n///\r\n0 --- 指定された仮想キーでは、現在のキーボード状態に対する変換はありません。\r\n///\r\n1 --- バッファに１つの文字がコピーされました。\r\n///\r\n2 --- バッファに２つの文字がコピーされました。これは通常、キーボードレイアウトに格納されたデッドキー文字（アクセントまたは区別的発音符）が指定された仮想キーと組み合せて１文字を構成できないことを表します。'),
('ToAsciiEx_Table1', '値 --- 意味\r\n///\r\n0 --- 指定された仮想キーでは、現在のキーボード状態に対する変換はありません。\r\n///\r\n1 --- バッファに１つの文字がコピーされました。\r\n///\r\n2 --- バッファに２つの文字がコピーされました。これは通常、キーボードレイアウトに格納されたデッドキー文字（アクセントまたは区別的発音符）を指定された仮想キーと組み合せて 1 文字を構成できないことを表します。'),
('ToUnicode_Table1', '値 --- 意味\r\n///\r\n-1 --- 指定された仮想キーは、デッドキー文字（アクセントまたは区別的発音符）です。複数の文字が入力されてキーボード状態に格納されていても、キーボードレイアウトとは関係なくこの値が返ります。可能であれば、Unicode キーボードレイアウトを使っている場合でも、pwszBuffer パラメータで指定されているバッファに、デッドキー文字のスペーシングバージョンを書き込みます。たとえば、NON_SPACING ACUTE（0x0301）という文字ではなく、SPACING ACUTE（0x00B4）という文字を書き込みます。\r\n///\r\n0 --- 指定された仮想キーでは、現在のキーボード状態に対する変換はありません。pwszBuffer パラメータで指定されたバッファには何も書き込まれませんでした。\r\n///\r\n1 --- pwszBuffer パラメータで指定されたバッファに 1 つの文字が書き込まれました。\r\n///\r\n2以上 --- pwszBuff パラメータで指定されたバッファに 2 つ以上の文字が書き込まれました。通常、キーボードレイアウトに格納されたデッドキー文字（アクセントまたは区別的発音符）が、指定された仮想キーと組み合せて１文字を構成できないことが原因です。'),
('ToUnicodeEx_Table1', '値 --- 意味\r\n///\r\n-1 --- 指定された仮想キーは、デッドキー文字（アクセントまたは区別的発音符）です。複数の文字が入力されてキーボード状態に格納されていても、キーボードレイアウトとは関係なくこの値が返ります。可能であれば、Unicode キーボードレイアウトを使っている場合でも、pwszBuffer パラメータで指定されているバッファに、デッドキー文字のスペーシングバージョンを書き込みます。たとえば、NON_SPACING ACUTE（0x0301）という文字ではなく、SPACING ACUTE（0x00B4）という文字を書き込みます。\r\n///\r\n0 --- 指定された仮想キーでは、現在のキーボード状態に対する変換はありません。pwszBuffer パラメータで指定されたバッファには何も書き込まれませんでした。\r\n///\r\n1 --- pwszBuffer パラメータで指定されたバッファに１つの文字が書き込まれました。\r\n///\r\n2 以上 --- pwszBuff パラメータで指定されたバッファに２つ以上の文字が書き込まれました。通常、キーボードレイアウトに格納されたデッドキー文字（アクセントまたは区別的発音符）が、指定された仮想キーと組み合せて 1 文字を構成できないことが原因です。'),
('Virtual-Key Codes_Table1', 'Constant/value --- Description\r\n///\r\nVK_LBUTTON 0x01 --- Left mouse button\r\n///\r\nVK_RBUTTON 0x02 --- Right mouse button\r\n///\r\nVK_CANCEL 0x03 --- Control-break processing\r\n///\r\nVK_MBUTTON 0x04 --- Middle mouse button (three-button mouse)\r\n///\r\nVK_XBUTTON1 0x05 --- X1 mouse button\r\n///\r\nVK_XBUTTON2 0x06 --- X2 mouse button\r\n///\r\n- 0x07 --- Undefined\r\n///\r\nVK_BACK 0x08 --- BACKSPACE key\r\n///\r\nVK_TAB 0x09 --- TAB key\r\n///\r\n- 0x0A-0B --- Reserved\r\n///\r\nVK_CLEAR 0x0C --- CLEAR key\r\n///\r\nVK_RETURN 0x0D --- ENTER key\r\n///\r\n- 0x0E-0F --- Undefined\r\n///\r\nVK_SHIFT 0x10 --- SHIFT key\r\n///\r\nVK_CONTROL 0x11 --- CTRL key\r\n///\r\nVK_MENU 0x12 --- ALT key\r\n///\r\nVK_PAUSE 0x13 --- PAUSE key\r\n///\r\nVK_CAPITAL 0x14 --- CAPS LOCK key\r\n///\r\nVK_KANA 0x15 --- IME Kana mode\r\n///\r\nVK_HANGUEL 0x15 --- IME Hanguel mode (maintained for compatibility; use VK_HANGUL)\r\n///\r\nVK_HANGUL 0x15 --- IME Hangul mode\r\n///\r\n- 0x16 --- Undefined\r\n///\r\nVK_JUNJA 0x17 --- IME Junja mode\r\n///\r\nVK_FINAL 0x18 --- IME final mode\r\n///\r\nVK_HANJA 0x19 --- IME Hanja mode\r\n///\r\nVK_KANJI 0x19 --- IME Kanji mode\r\n///\r\n- 0x1A --- Undefined\r\n///\r\nVK_ESCAPE 0x1B --- ESC key\r\n///\r\nVK_CONVERT 0x1C --- IME convert\r\n///\r\nVK_NONCONVERT 0x1D --- IME nonconvert\r\n///\r\nVK_ACCEPT 0x1E --- IME accept\r\n///\r\nVK_MODECHANGE 0x1F --- IME mode change request\r\n///\r\nVK_SPACE 0x20 --- SPACEBAR\r\n///\r\nVK_PRIOR 0x21 --- PAGE UP key\r\n///\r\nVK_NEXT 0x22 --- PAGE DOWN key\r\n///\r\nVK_END 0x23 --- END key\r\n///\r\nVK_HOME 0x24 --- HOME key\r\n///\r\nVK_LEFT 0x25 --- LEFT ARROW key\r\n///\r\nVK_UP 0x26 --- UP ARROW key\r\n///\r\nVK_RIGHT 0x27 --- RIGHT ARROW key\r\n///\r\nVK_DOWN 0x28 --- DOWN ARROW key\r\n///\r\nVK_SELECT 0x29 --- SELECT key\r\n///\r\nVK_PRINT 0x2A --- PRINT key\r\n///\r\nVK_EXECUTE 0x2B --- EXECUTE key\r\n///\r\nVK_SNAPSHOT 0x2C --- PRINT SCREEN key\r\n///\r\nVK_INSERT 0x2D --- INS key\r\n///\r\nVK_DELETE 0x2E --- DEL key\r\n///\r\nVK_HELP 0x2F --- HELP key\r\n///\r\n0x30 --- 0 key\r\n///\r\n0x31 --- 1 key\r\n///\r\n0x32 --- 2 key\r\n///\r\n0x33 --- 3 key\r\n///\r\n0x34 --- 4 key\r\n///\r\n0x35 --- 5 key\r\n///\r\n0x36 --- 6 key\r\n///\r\n0x37 --- 7 key\r\n///\r\n0x38 --- 8 key\r\n///\r\n0x39 --- 9 key\r\n///\r\n- 0x3A-40 --- Undefined\r\n///\r\n0x41 --- A key\r\n///\r\n0x42 --- B key\r\n///\r\n0x43 --- C key\r\n///\r\n0x44 --- D key\r\n///\r\n0x45 --- E key\r\n///\r\n0x46 --- F key\r\n///\r\n0x47 --- G key\r\n///\r\n0x48 --- H key\r\n///\r\n0x49 --- I key\r\n///\r\n0x4A --- J key\r\n///\r\n0x4B --- K key\r\n///\r\n0x4C --- L key\r\n///\r\n0x4D --- M key\r\n///\r\n0x4E --- N key\r\n///\r\n0x4F --- O key\r\n///\r\n0x50 --- P key\r\n///\r\n0x51 --- Q key\r\n///\r\n0x52 --- R key\r\n///\r\n0x53 --- S key\r\n///\r\n0x54 --- T key\r\n///\r\n0x55 --- U key\r\n///\r\n0x56 --- V key\r\n///\r\n0x57 --- W key\r\n///\r\n0x58 --- X key\r\n///\r\n0x59 --- Y key\r\n///\r\n0x5A --- Z key\r\n///\r\nVK_LWIN 0x5B --- Left Windows key (Natural keyboard)\r\n///\r\nVK_RWIN 0x5C --- Right Windows key (Natural keyboard)\r\n///\r\nVK_APPS 0x5D --- Applications key (Natural keyboard)\r\n///\r\n- 0x5E --- Reserved\r\n///\r\nVK_SLEEP 0x5F --- Computer Sleep key\r\n///\r\nVK_NUMPAD0 0x60 --- Numeric keypad 0 key\r\n///\r\nVK_NUMPAD1 0x61 --- Numeric keypad 1 key\r\n///\r\nVK_NUMPAD2 0x62 --- Numeric keypad 2 key\r\n///\r\nVK_NUMPAD3 0x63 --- Numeric keypad 3 key\r\n///\r\nVK_NUMPAD4 0x64 --- Numeric keypad 4 key\r\n///\r\nVK_NUMPAD5 0x65 --- Numeric keypad 5 key\r\n///\r\nVK_NUMPAD6 0x66 --- Numeric keypad 6 key\r\n///\r\nVK_NUMPAD7 0x67 --- Numeric keypad 7 key\r\n///\r\nVK_NUMPAD8 0x68 --- Numeric keypad 8 key\r\n///\r\nVK_NUMPAD9 0x69 --- Numeric keypad 9 key\r\n///\r\nVK_MULTIPLY 0x6A --- Multiply key\r\n///\r\nVK_ADD 0x6B --- Add key\r\n///\r\nVK_SEPARATOR 0x6C --- Separator key\r\n///\r\nVK_SUBTRACT 0x6D --- Subtract key\r\n///\r\nVK_DECIMAL 0x6E --- Decimal key\r\n///\r\nVK_DIVIDE 0x6F --- Divide key\r\n///\r\nVK_F1 0x70 --- F1 key\r\n///\r\nVK_F2 0x71 --- F2 key\r\n///\r\nVK_F3 0x72 --- F3 key\r\n///\r\nVK_F4 0x73 --- F4 key\r\n///\r\nVK_F5 0x74 --- F5 key\r\n///\r\nVK_F6 0x75 --- F6 key\r\n///\r\nVK_F7 0x76 --- F7 key\r\n///\r\nVK_F8 0x77 --- F8 key\r\n///\r\nVK_F9 0x78 --- F9 key\r\n///\r\nVK_F10 0x79 --- F10 key\r\n///\r\nVK_F11 0x7A --- F11 key\r\n///\r\nVK_F12 0x7B --- F12 key\r\n///\r\nVK_F13 0x7C --- F13 key\r\n///\r\nVK_F14 0x7D --- F14 key\r\n///\r\nVK_F15 0x7E --- F15 key\r\n///\r\nVK_F16 0x7F --- F16 key\r\n///\r\nVK_F17 0x80 --- F17 key\r\n///\r\nVK_F18 0x81 --- F18 key\r\n///\r\nVK_F19 0x82 --- F19 key\r\n///\r\nVK_F20 0x83 --- F20 key\r\n///\r\nVK_F21 0x84 --- F21 key\r\n///\r\nVK_F22 0x85 --- F22 key\r\n///\r\nVK_F23 0x86 --- F23 key\r\n///\r\nVK_F24 0x87 --- F24 key\r\n///\r\n- 0x88-8F --- Unassigned\r\n///\r\nVK_NUMLOCK 0x90 --- NUM LOCK key\r\n///\r\nVK_SCROLL 0x91 --- SCROLL LOCK key\r\n///\r\n0x92-96 --- OEM specific\r\n///\r\n- 0x97-9F --- Unassigned\r\n///\r\nVK_LSHIFT 0xA0 --- Left SHIFT key\r\n///\r\nVK_RSHIFT 0xA1 --- Right SHIFT key\r\n///\r\nVK_LCONTROL 0xA2 --- Left CONTROL key\r\n///\r\nVK_RCONTROL 0xA3 --- Right CONTROL key\r\n///\r\nVK_LMENU 0xA4 --- Left MENU key\r\n///\r\nVK_RMENU 0xA5 --- Right MENU key\r\n///\r\nVK_BROWSER_BACK 0xA6 --- Browser Back key\r\n///\r\nVK_BROWSER_FORWARD 0xA7 --- Browser Forward key\r\n///\r\nVK_BROWSER_REFRESH 0xA8 --- Browser Refresh key\r\n///\r\nVK_BROWSER_STOP 0xA9 --- Browser Stop key\r\n///\r\nVK_BROWSER_SEARCH 0xAA --- Browser Search key\r\n///\r\nVK_BROWSER_FAVORITES 0xAB --- Browser Favorites key\r\n///\r\nVK_BROWSER_HOME 0xAC --- Browser Start and Home key\r\n///\r\nVK_VOLUME_MUTE 0xAD --- Volume Mute key\r\n///\r\nVK_VOLUME_DOWN 0xAE --- Volume Down key\r\n///\r\nVK_VOLUME_UP 0xAF --- Volume Up key\r\n///\r\nVK_MEDIA_NEXT_TRACK 0xB0 --- Next Track key\r\n///\r\nVK_MEDIA_PREV_TRACK 0xB1 --- Previous Track key\r\n///\r\nVK_MEDIA_STOP 0xB2 --- Stop Media key\r\n///\r\nVK_MEDIA_PLAY_PAUSE 0xB3 --- Play/Pause Media key\r\n///\r\nVK_LAUNCH_MAIL 0xB4 --- Start Mail key\r\n///\r\nVK_LAUNCH_MEDIA_SELECT 0xB5 --- Select Media key\r\n///\r\nVK_LAUNCH_APP1 0xB6 --- Start Application 1 key\r\n///\r\nVK_LAUNCH_APP2 0xB7 --- Start Application 2 key\r\n///\r\n- 0xB8-B9 --- Reserved\r\n///\r\nVK_OEM_1 0xBA --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \';:\' key\r\n///\r\nVK_OEM_PLUS 0xBB --- For any country/region, the \'+\' key\r\n///\r\nVK_OEM_COMMA 0xBC --- For any country/region, the \',\' key\r\n///\r\nVK_OEM_MINUS 0xBD --- For any country/region, the \'-\' key\r\n///\r\nVK_OEM_PERIOD 0xBE --- For any country/region, the \'.\' key\r\n///\r\nVK_OEM_2 0xBF --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'/?\' key\r\n///\r\nVK_OEM_3 0xC0 --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'`~\' key\r\n///\r\n- 0xC1-D7 --- Reserved\r\n///\r\n- 0xD8-DA --- Unassigned\r\n///\r\nVK_OEM_4 0xDB --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'[{\' key\r\n///\r\nVK_OEM_5 0xDC --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'\\|\' key\r\n///\r\nVK_OEM_6 0xDD --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \']}\' key\r\n///\r\nVK_OEM_7 0xDE --- Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'single-quote/double-quote\' key\r\n///\r\nVK_OEM_8 0xDF --- Used for miscellaneous characters; it can vary by keyboard.\r\n///\r\n- 0xE0 --- Reserved\r\n///\r\n0xE1 --- OEM specific\r\n///\r\nVK_OEM_102 0xE2 --- Either the angle bracket key or the backslash key on the RT 102-key keyboard\r\n///\r\n0xE3-E4 --- OEM specific\r\n///\r\nVK_PROCESSKEY 0xE5 --- IME PROCESS key\r\n///\r\n0xE6 --- OEM specific\r\n///\r\nVK_PACKET 0xE7 --- Used to pass Unicode characters as if they were keystrokes. The VK_PACKET key is the low word of a 32-bit Virtual Key value used for non-keyboard input methods. For more information, see Remark in KEYBDINPUT, SendInput, WM_KEYDOWN, and WM_KEYUP\r\n///\r\n- 0xE8 --- Unassigned\r\n///\r\n0xE9-F5 --- OEM specific\r\n///\r\nVK_ATTN 0xF6 --- Attn key\r\n///\r\nVK_CRSEL 0xF7 --- CrSel key\r\n///\r\nVK_EXSEL 0xF8 --- ExSel key\r\n///\r\nVK_EREOF 0xF9 --- Erase EOF key\r\n///\r\nVK_PLAY 0xFA --- Play key\r\n///\r\nVK_ZOOM 0xFB --- Zoom key\r\n///\r\nVK_NONAME 0xFC --- Reserved\r\n///\r\nVK_PA1 0xFD --- PA1 key\r\n///\r\nVK_OEM_CLEAR 0xFE --- Clear key'),
('VkKeyScan_Table1', 'ビット値 --- 意味\r\n///\r\n1 --- どちらかの Shift キーが押されています。\r\n///\r\n2 --- どちらかの Ctrl キーが押されています。\r\n///\r\n4 --- どちらかの Alt キーが押されています。\r\n///\r\n8 --- Hankaku キーが押されています。\r\n///\r\n16 --- 予約済み（ キーボードレイアウトドライバによって定義されます）。\r\n///\r\n32 --- 予約済み（ キーボードレイアウトドライバによって定義されます）。'),
('VkKeyScanEx_Table1', 'ビット値 --- 意味\r\n///\r\n1 --- どちらかの Shift キーが押されています。\r\n///\r\n2 --- どちらかの Ctrl キーが押されています。\r\n///\r\n4 --- どちらかの Alt キーが押されています。\r\n///\r\n8 --- Hankaku キーが押されています。\r\n///\r\n16 --- 予約済み（ キーボードレイアウトドライバによって定義されます）。\r\n///\r\n32 --- 予約済み（ キーボードレイアウトドライバによって定義されます）。'),
('WM_CHAR_Table1', 'ビット --- 意味\r\n///\r\n0-15 --- 現在のメッセージに対するリピートカウント。この値は、\r\nユーザーがキーを押し続けた結果っとして自動リピートされた回数だ。もしキーが長く押され続ければ、複数回送信される。しかしながら、リピートカウントは、累積しない。\r\n///\r\n16-23 --- スキャンコード。この値はOEMに依存する。\r\n///\r\n24 --- 拡張101、102キーのキーボードの右AltやCtrlキーのように、拡張キーであることを表す。この値は拡張キーのとき1であり、さもなければゼロである。\r\n///\r\n25-28 --- 予約済み。使わない。\r\n///\r\n29 --- コンテキストコード。キーが押されている間にAltキーが押されていれば1であり、さもなくばゼロ。\r\n///\r\n30 --- 直前のキー状態。この値は、メッセージが送信さる前にキーが押されていれば、1であり、キーが上がっていれば、ゼロである。\r\n///\r\n31 --- トランジション状態。もしキーが離されていればこの値は1であり、キーが押されていれば、ゼロである。'),
('WM_IME_CHAR_Table1', 'ビット --- 意味\r\n///\r\n0-15 --- リピートカウント。最初のバイトと二番目のバイトは連続であるから、これは常に1です。\r\n///\r\n16-23 --- 完全なアジアの文字のためのスキャンコード。\r\n///\r\n24 --- 拡張キー。\r\n///\r\n25-28 --- 使われません。\r\n///\r\n29 --- コンテキストコード。\r\n///\r\n30 --- 直前のキー状態。\r\n///\r\n31 --- トランジション状態。'),
('WM_IME_COMPOSITION_Table1', '値 --- 意味\r\n///\r\nCS_INSERTCHAR --- 現在の挿入位置にコンポジション文字wParamを挿入します。アプリはこのメッセージを処理したなら、コンポジション文字を表示すべきです。\r\n///\r\nCS_NOMOVECARET --- このメッセージを処理した結果としてキャレット位置を動かしません。例えば、もしIMEがCS_INSERTCHARと CS_NOMOVECARETの組み合わせを指定したなら、アプリは、指定した文字を現在のキャレット位置に挿入すべきだが、キャレットを次の位置へ移動すべきではありません。GCS_RESULTSTRの付いた後続のWM_IME_COMPOSITION メッセージは、この文字を置換するでしょう。'),
('WM_IME_KEYDOWN_Table1', 'ビット --- 意味\r\n///\r\n0-15 --- リピートカウント。\r\n///\r\n16-23 --- スキャンコード。\r\n///\r\n24 --- 拡張キー。キーが拡張キーならこの値は1になります。その他の場合はゼロです。\r\n///\r\n25-28 --- 使われません。\r\n///\r\n29 --- コンテキストコード。この値は常にゼロです。\r\n///\r\n30 --- 直前のキー状態。キーが下がっていればこの値は1で、上がっていればゼロです。\r\n/// \r\n31 --- トランジション状態。この値は常にゼロです。'),
('WM_IME_KEYUP_Table1', 'ビット --- 意味\r\n///\r\n0-15 --- リピートカウント。この値は常に1です。\r\n///\r\n16-23 --- スキャンコード。\r\n///\r\n24 --- 拡張キー。この値は、拡張キーのとき1です。さもなければゼロです。\r\n///\r\n25-28 --- 使われません。\r\n///\r\n29 --- コンテキストコード。この値は常にゼロです。\r\n///\r\n30 --- 直前のキー状態。この値は常に1です。\r\n///\r\n31 --- トランジション状態。この値は常に1です。'),
('WM_IME_SETCONTEXT_Table1', '値 --- 意味\r\n///\r\nISC_SHOWUICOMPOSITIONWINDOW --- UIウィンドウによるコンポジションウィンドウを表示します。\r\n///\r\nISC_SHOWUIGUIDWINDOW --- UIウィンドウによるガイドウィンドウを表示します。\r\n//\r\nISC_SHOWUISOFTKBD --- UIウィンドウによるソフトキーボードを表示します。\r\n///\r\nISC_SHOWUICANDIDATEWINDOW --- UIウィンドウによるインデックス0の候補ウィンドウを表示します。\r\n///\r\nISC_SHOWUICANDIDATEWINDOW << 1  --- UIウィンドウによるインデックス1の候補ウィンドウを表示します。\r\n///\r\nISC_SHOWUICANDIDATEWINDOW << 2 --- UIウィンドウによるインデックス2の候補ウィンドウを表示します。\r\n///\r\nISC_SHOWUICANDIDATEWINDOW << 3 --- UIウィンドウによるインデックス3の候補ウィンドウを表示します。'),
('WM_INPUTLANGCHANGEREQUEST_Table1', '値 --- 意味\r\n///\r\nINPUTLANGCHANGE_BACKWARD 0x0004 --- 入力ロケールのインストール済みリストにおいて前の入力ロケールを選択するためにホットキーが使われた。このフラグはINPUTLANGCHANGE_FORWARDフラグと一緒に使えない。\r\n///\r\nINPUTLANGCHANGE_FORWARD 0x0002 --- 入力ロケールのインストール済みリストにおいて次の入力ロケールを選択するためにホットキーが使われた。このフラグはINPUTLANGCHANGE_BACKWARDフラグと一緒に使えない。\r\n///\r\nINPUTLANGCHANGE_SYSCHARSET 0x0001 --- システム文字セットで新しい入力ロケールのキーボードレイアウトが使える。'),
('WM_KEYDOWN_Table1', 'ビット --- 意味\r\n///\r\n0-15 --- 現在のメッセージに対するリピートカウント。この値は、ユーザーがキーを押し続けた結果としてキーストロークが自動リピートされた回数である。もしキーストロークが充分に長ければ、複数のメッセージが送信される。しかしながら、リピートカウントは累積しない。\r\n///\r\n16-23 --- スキャンコード。この値はOEMに依存する。\r\n///\r\n24 --- キーが拡張101、102キーのキーボードにおける右Alt、Ctrlキーのような、拡張キーであることを表す。この値は、拡張キーなら1であり、さもなければゼロである。  \r\n///\r\n25-28 --- 予約済み。使わない。\r\n///\r\n29 --- コンテキストコード。この値はWM_KEYDOWNメッセージにおいては常にゼロ。\r\n///\r\n30 --- 直前のキー状態。この値は、メッセージが送信される前にキーが押されていれば1であり、キーが上がっていればゼロである。\r\n///\r\n31 --- トランジション状態。この値はWM_KEYDOWNメッセージにおいては常にゼロである。'),
('WM_KEYUP_Table1', 'ビット --- 意味\r\n///\r\n0-15 --- 現在のメッセージに対するリピートカウント。この値は、ユーザーがキーを押し続けた結果としてキーストロークが自動リピートされた回数である。リピートカウントはWM_KEYUPメッセージについては常に1である。\r\n///\r\n16-23 --- スキャンコード。この値はOEMに依存する。\r\n///\r\n24 --- 拡張101、102キーのキーボードの右Atl、Ctrlっキーのように、キーが拡張キーであるかどうかを表す。この値はキーが拡張キーならば1であり、さもなければゼロである。\r\n///\r\n25-28 --- 予約済み。使わない。\r\n///\r\n29 --- コンテキストコード。この値はWM_KEYUPについては常にゼロである。\r\n///  \r\n30 --- 直前のキー状態。この値はWM_KEYUPメッセージについては常に1である。\r\n///\r\n31 --- トランジション状態。この値はWM_KEYUPメッセージについては常に1である。');

-- --------------------------------------------------------

--
-- テーブルの構造 `translation`
--

CREATE TABLE `translation` (
  `id` int(11) NOT NULL,
  `original` varchar(128) NOT NULL,
  `translated` varchar(128) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- テーブルのデータのダンプ `translation`
--

INSERT INTO `translation` (`id`, `original`, `translated`) VALUES
(1, 'IME Composition String Values', 'IMEコンポジション文字列の値'),
(2, 'IME Conversion Mode Values', 'IME変換モードの値'),
(3, 'IME Escapes', 'IMEエスケープ'),
(4, 'IME Sentence Mode Values', 'IMEセンテンスモードの値'),
(5, 'IME Hot Key Identifiers', 'IMEホットキー識別子'),
(6, 'Composition String', 'コンポジション文字列'),
(7, 'Dialog Box Keyboard Interface', 'ダイアログボックスのキーボードインターフェイス'),
(8, 'System-Defined Messages', 'システム定義のメッセージ'),
(9, 'Virtual-Key Codes', '仮想キーコード'),
(10, 'Input Method Editor Constants', 'IME定数'),
(11, 'About Messages and Message Queues', 'メッセージとメッセージキューについて'),
(12, 'Windows Messages', 'Windowsのメッセージ'),
(13, 'Message Types', 'メッセージの種類'),
(14, 'System-Defined Messages', 'システム定義のメッセージ'),
(15, 'Application-Defined Messages', 'アプリ定義のメッセージ'),
(16, 'Message Routing', 'メッセージの輸送'),
(17, 'Queued Messages', 'キューされたメッセージ'),
(18, 'Nonqueued Messages', 'キューされなかったメッセージ'),
(19, 'Message Handling', 'メッセージの処理'),
(20, 'Message Loop', 'メッセージループ'),
(21, 'Window Procedure', 'ウィンドウプロシージャ'),
(22, 'Message Filtering', 'メッセージのフィルタリング'),
(23, 'Posting and Sending Messages', 'メッセージのポストと送信'),
(24, 'Posting Messages', 'メッセージのポスト'),
(25, 'Sending Messages', 'メッセージの送信'),
(26, 'Message Deadlocks', 'メッセージのデッドロック'),
(27, 'Broadcasting Messages', 'メッセージの放映'),
(28, 'Query Messages', '問い合わせメッセージ'),
(29, 'Overview of IMM/IME', 'IMM/IMEの概要'),
(30, 'Win32 IME Structure', 'Win32 IMEの構造'),
(31, 'IME Aware Applications', 'IMEを意識したアプリ'),
(32, 'IME User Interface', 'IMEのユーザーインターフェイス'),
(33, 'Default and Application IME Window', '既定およびアプリのIMEウィンドウ'),
(34, 'IME Class', 'IMEクラス'),
(35, 'UI Class from IME', 'IMEからのUIクラス'),
(36, 'UI Window', 'UIウィンドウ'),
(37, 'Components of the UI Window', 'UIウィンドウのコンポーネントたち'),
(38, 'IME Input Context', 'IMEの入力コンテキスト'),
(39, 'Default Input Context', '既定の入力コンテキスト'),
(40, 'Application-Created Input Context', 'アプリ作成の入力コンテキスト'),
(41, 'Using the Input Context', '入力コンテキストの使用方法'),
(42, 'Accessing the HIMC', 'HIMCへのアクセス方法'),
(43, 'Accessing the HIMCC', 'HIMCCへのアクセス方法'),
(44, 'Generating Messages', 'メッセージの生成方法'),
(45, 'Using lpTransMsgList to Generate Messages', 'メッセージ生成にlpTransMsgListを使う方法'),
(46, 'Using the Message Buffer to Generate Messages', 'メッセージ生成にメッセージバッファを使う方法'),
(47, 'Soft Keyboard', 'ソフトキーボード'),
(48, 'Reconversion', '再変換'),
(49, 'Simple Reconversion', '単純な再変換'),
(50, 'Normal Reconversion', '普通の再変換'),
(51, 'Enhanced Reconversion', '強化された再変換'),
(52, 'IME Cancel Reconversion', 'IMEキャンセルの再変換'),
(53, 'IME Menu Functions', 'IMEメニュー関数たち'),
(54, 'IME Menu Notification', 'IMEメニュー通知'),
(55, 'Indicator Manager for IME', 'IME用のインディケータ管理'),
(56, 'Indicator Window', 'インディケータウィンドウ'),
(57, 'Indicator Messages', 'インディケータメッセージたち'),
(58, 'IME File Format', 'IMEファイル形式'),
(59, 'Security Concerns', 'セキュリティ関連'),
(60, 'Named Objects', '名前付きオブジェクト'),
(61, 'Winlogon', 'Winlogon'),
(62, 'Unicode Interface', 'Unicodeインターフェイス'),
(63, 'IME and Localized Language Compatibility', 'IMEとローカライズされた言語の互換性'),
(64, 'Keyboard Input Model', 'キーボード入力モデル'),
(65, 'Keyboard Focus and Activation', 'キーボードフォーカスとアクティベーション'),
(66, 'Keystroke Messages', 'キーストロークメッセージ'),
(67, 'System and Nonsystem Keystrokes', 'システムと非システムのキーストローク'),
(68, 'Virtual-Key Codes Described', '仮想キーコードの説明'),
(69, 'Keystroke Message Flags', 'キーストロークメッセージのフラグたち'),
(70, 'Repeat Count', 'リピートカウント'),
(71, 'Scan Code', 'スキャンコード'),
(72, 'Extended-Key Flag', '拡張キーフラグ'),
(73, 'Context Code', 'コンテキストコード'),
(74, 'Previous Key-State Flag', '直前のキー状態フラグ'),
(75, 'Transition-State Flag', 'トランジション状態フラグ'),
(76, 'Character Messages', '文字メッセージ'),
(77, 'Nonsystem Character Messages', '非システム文字メッセージ'),
(78, 'Key Status', 'キー状態'),
(79, 'Keystroke and Character Translations', 'キーストロークと文字の変換'),
(80, 'Hot-Key Support', 'ホットキーサポート'),
(81, 'Keyboard Keys for Browsing and Other Functions', 'ブラウジングなどの機能のためのキーボードのキーたち'),
(82, 'Simulating Input', '入力のシミュレート'),
(83, 'Languages, Locales, and Keyboard Layouts', '言語、ロケール、そしてキーボードレイアウト'),
(84, 'Dead-Character Messages', 'デッド文字メッセージ'),
(85, 'Unicode and Character Sets', 'Unicodeと文字セット'),
(86, 'About Unicode and Character Sets', 'Unicodeと文字セットについて'),
(87, 'Character Sets', '文字セット'),
(88, 'Code Pages', 'コードページ'),
(89, 'Double-byte Character Sets', 'ダブルバイト文字セット'),
(90, 'Single-byte Character Sets', 'シングルバイト文字セット'),
(91, 'Surrogates and Supplementary Characters', 'サロゲートと補助文字'),
(92, 'About Supplementary Characters', '補助文字について'),
(93, 'Unicode in the Windows API', 'Windows APIにおけるUnicode'),
(94, 'Using Supplementary Characters', '補助文字の使い方');

--
-- ダンプしたテーブルのインデックス
--

--
-- テーブルのインデックス `entries`
--
ALTER TABLE `entries`
  ADD PRIMARY KEY (`entry_name`),
  ADD UNIQUE KEY `entry_name` (`entry_name`);

--
-- テーブルのインデックス `tables`
--
ALTER TABLE `tables`
  ADD PRIMARY KEY (`table_name`),
  ADD UNIQUE KEY `table_name` (`table_name`);

--
-- テーブルのインデックス `translation`
--
ALTER TABLE `translation`
  ADD PRIMARY KEY (`id`);

--
-- ダンプしたテーブルの AUTO_INCREMENT
--

--
-- テーブルの AUTO_INCREMENT `translation`
--
ALTER TABLE `translation`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=95;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
